<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"xiaojianzheng.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.14.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><meta name="description" content="为什么在传统的单体服务中，我们经常会遇到多线程对于单一资源的抢占导致的线程安全问题以及对数据库数据操作的一致性问题，如果是在单体系统中，我们可以很方便的使用编程语言提供的锁以及数据库事务来解决这些问题。 一旦单体系统转为分布式架构，那么本地事务和线程锁就无法满足跨进程的锁效果；分布式锁则是用于进程间同步访问共享资源的一种方式，通过全局共享来实现全局锁的效果，保证数据的一致性。 总的来说，在分布式系"><meta property="og:type" content="article"><meta property="og:title" content="分布式最佳实践：分布式锁"><meta property="og:url" content="http://xiaojianzheng.cn/2022/09/25/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/index.html"><meta property="og:site_name" content="JIAHE"><meta property="og:description" content="为什么在传统的单体服务中，我们经常会遇到多线程对于单一资源的抢占导致的线程安全问题以及对数据库数据操作的一致性问题，如果是在单体系统中，我们可以很方便的使用编程语言提供的锁以及数据库事务来解决这些问题。 一旦单体系统转为分布式架构，那么本地事务和线程锁就无法满足跨进程的锁效果；分布式锁则是用于进程间同步访问共享资源的一种方式，通过全局共享来实现全局锁的效果，保证数据的一致性。 总的来说，在分布式系"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pic1.zhimg.com/80/v2-e3fc985099d4a5afc7a52a30300dd288_720w.jpg"><meta property="og:image" content="https://pic3.zhimg.com/80/v2-ce8a50e076035057f20bbc7527fb9496_720w.jpg"><meta property="og:image" content="https://pic3.zhimg.com/80/v2-3b5f6b1211a6b1ef0384d82a3ed2d202_720w.jpg"><meta property="og:image" content="https://pic2.zhimg.com/80/v2-f688f0fffc79c1cb684cdefe63277ee5_720w.jpg"><meta property="article:published_time" content="2022-09-25T01:11:46.000Z"><meta property="article:modified_time" content="2022-09-25T01:11:46.000Z"><meta property="article:author" content="JIAHE"><meta property="article:tag" content="分布式"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic1.zhimg.com/80/v2-e3fc985099d4a5afc7a52a30300dd288_720w.jpg"><link rel="canonical" href="http://xiaojianzheng.cn/2022/09/25/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://xiaojianzheng.cn/2022/09/25/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","path":"2022/09/25/分布式最佳实践：分布式锁/","title":"分布式最佳实践：分布式锁"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>分布式最佳实践：分布式锁 | JIAHE</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">JIAHE</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-导航"><a href="/navigation/" rel="section"><i class="fa fa-location-arrow fa-fw"></i>导航</a></li><li class="menu-item menu-item-文档"><a href="/docs/" rel="section"><i class="fa fa-book fa-fw fa-fw"></i>文档</a></li><li class="menu-item menu-item-应用下载"><a href="/app-download/" rel="section"><i class="fas fa-download fa-fw fa-fw"></i>应用下载</a></li><li class="menu-item menu-item-cheat-sheet"><a href="/cheat-sheet/" rel="section"><i class="fas fa-pen fa-fw"></i>Cheat Sheet</a></li><li class="menu-item menu-item-软件安装部署"><a href="/software-install-and-deploy/" rel="section"><i class="fab fa-windows fa-fw"></i>软件安装部署</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">为什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.</span> <span class="nav-text">基于数据库实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.</span> <span class="nav-text">乐观锁实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.</span> <span class="nav-text">悲观锁实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8ERedis-%EF%BC%9AAP%E6%9E%B6%E6%9E%84"><span class="nav-number">2.4.</span> <span class="nav-text">基于Redis ：AP架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EZookeeper-%EF%BC%9ACP-%E6%9E%B6%E6%9E%84"><span class="nav-number">2.5.</span> <span class="nav-text">基于Zookeeper ：CP 架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="JIAHE" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">JIAHE</p><div class="site-description" itemprop="description">Collection & Reuse</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">108</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">99</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://cook.aiurs.co/" title="https:&#x2F;&#x2F;cook.aiurs.co&#x2F;" rel="noopener" target="_blank">程序员做饭指南</a></li><li class="links-of-blogroll-item"> <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com&#x2F;" rel="noopener" target="_blank">Baidu</a></li><li class="links-of-blogroll-item"> <a href="https://cn.bing.com/" title="https:&#x2F;&#x2F;cn.bing.com&#x2F;" rel="noopener" target="_blank">Bing</a></li><li class="links-of-blogroll-item"> <a href="https://www.google.com/" title="https:&#x2F;&#x2F;www.google.com&#x2F;" rel="noopener" target="_blank">Google</a></li><li class="links-of-blogroll-item"> <a href="https://zh.wikipedia.org/wiki/Wikipedia:%E9%A6%96%E9%A1%B5" title="https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Wikipedia:%E9%A6%96%E9%A1%B5" rel="noopener" target="_blank">Wiki</a></li><li class="links-of-blogroll-item"> <a href="https://projectlombok.org/" title="https:&#x2F;&#x2F;projectlombok.org&#x2F;" rel="noopener" target="_blank">lombok</a></li><li class="links-of-blogroll-item"> <a href="https://logging.apache.org/log4j/2.x/" title="https:&#x2F;&#x2F;logging.apache.org&#x2F;log4j&#x2F;2.x&#x2F;" rel="noopener" target="_blank">log4j</a></li><li class="links-of-blogroll-item"> <a href="http://logback.qos.ch/" title="http:&#x2F;&#x2F;logback.qos.ch&#x2F;" rel="noopener" target="_blank">logback</a></li><li class="links-of-blogroll-item"> <a href="https://junit.org/junit5/" title="https:&#x2F;&#x2F;junit.org&#x2F;junit5&#x2F;" rel="noopener" target="_blank">junit</a></li><li class="links-of-blogroll-item"> <a href="https://element.eleme.cn/#/zh-CN" title="https:&#x2F;&#x2F;element.eleme.cn&#x2F;#&#x2F;zh-CN" rel="noopener" target="_blank">ElementUI</a></li><li class="links-of-blogroll-item"> <a href="https://zipkin.io/" title="https:&#x2F;&#x2F;zipkin.io&#x2F;" rel="noopener" target="_blank">Zipkin</a></li><li class="links-of-blogroll-item"> <a href="https://www.selenium.dev/zh-cn/" title="https:&#x2F;&#x2F;www.selenium.dev&#x2F;zh-cn&#x2F;" rel="noopener" target="_blank">Selenium</a></li><li class="links-of-blogroll-item"> <a href="https://nacos.io/zh-cn/docs/what-is-nacos.html" title="https:&#x2F;&#x2F;nacos.io&#x2F;zh-cn&#x2F;docs&#x2F;what-is-nacos.html" rel="noopener" target="_blank">Nacos</a></li><li class="links-of-blogroll-item"> <a href="https://dev.mysql.com/downloads/" title="https:&#x2F;&#x2F;dev.mysql.com&#x2F;downloads&#x2F;" rel="noopener" target="_blank">MySQL-Download</a></li><li class="links-of-blogroll-item"> <a href="https://redis.io/" title="https:&#x2F;&#x2F;redis.io&#x2F;" rel="noopener" target="_blank">Redis</a></li><li class="links-of-blogroll-item"> <a href="https://www.jetbrains.com/help/idea/discover-intellij-idea.html" title="https:&#x2F;&#x2F;www.jetbrains.com&#x2F;help&#x2F;idea&#x2F;discover-intellij-idea.html" rel="noopener" target="_blank">IDEA-Document</a></li><li class="links-of-blogroll-item"> <a href="https://jdk.java.net/" title="https:&#x2F;&#x2F;jdk.java.net&#x2F;" rel="noopener" target="_blank">JDK</a></li><li class="links-of-blogroll-item"> <a href="https://www.java.com/en/download/manual.jsp" title="https:&#x2F;&#x2F;www.java.com&#x2F;en&#x2F;download&#x2F;manual.jsp" rel="noopener" target="_blank">JDK8</a></li><li class="links-of-blogroll-item"> <a href="https://dev.java/" title="https:&#x2F;&#x2F;dev.java&#x2F;" rel="noopener" target="_blank">JAVA</a></li><li class="links-of-blogroll-item"> <a href="https://www.oracle.com/java/technologies/downloads/archive/" title="https:&#x2F;&#x2F;www.oracle.com&#x2F;java&#x2F;technologies&#x2F;downloads&#x2F;archive&#x2F;" rel="noopener" target="_blank">JDK-Oracle</a></li><li class="links-of-blogroll-item"> <a href="https://poi.apache.org/components/index.html" title="https:&#x2F;&#x2F;poi.apache.org&#x2F;components&#x2F;index.html" rel="noopener" target="_blank">POI</a></li><li class="links-of-blogroll-item"> <a href="https://assertj.github.io/doc/" title="https:&#x2F;&#x2F;assertj.github.io&#x2F;doc&#x2F;" rel="noopener" target="_blank">AssertJ</a></li><li class="links-of-blogroll-item"> <a href="https://docshome.gitbook.io/nginx-docs/" title="https:&#x2F;&#x2F;docshome.gitbook.io&#x2F;nginx-docs&#x2F;" rel="noopener" target="_blank">Nginx-CN</a></li><li class="links-of-blogroll-item"> <a href="https://github.com/cglib/cglib" title="https:&#x2F;&#x2F;github.com&#x2F;cglib&#x2F;cglib" rel="noopener" target="_blank">cglib</a></li><li class="links-of-blogroll-item"> <a href="https://docs.gitlab.com/ee/api/api_resources.html" title="https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;api&#x2F;api_resources.html" rel="noopener" target="_blank">Gitlab Api</a></li><li class="links-of-blogroll-item"> <a href="http://mockjs.com/examples.html" title="http:&#x2F;&#x2F;mockjs.com&#x2F;examples.html" rel="noopener" target="_blank">Mockjs Example</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://xiaojianzheng.cn/2022/09/25/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="JIAHE"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="JIAHE"><meta itemprop="description" content="Collection & Reuse"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="分布式最佳实践：分布式锁 | JIAHE"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 分布式最佳实践：分布式锁</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-09-25 09:11:46" itemprop="dateCreated datePublished" datetime="2022-09-25T09:11:46+08:00">2022-09-25</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>在传统的单体服务中，我们经常会遇到多线程对于单一资源的抢占导致的线程安全问题以及对数据库数据操作的一致性问题，如果是在单体系统中，我们可以很方便的使用编程语言提供的锁以及数据库事务来解决这些问题。</p><p>一旦单体系统转为分布式架构，那么本地事务和线程锁就无法满足跨进程的锁效果；分布式锁则是用于进程间同步访问共享资源的一种方式，通过全局共享来实现全局锁的效果，保证数据的一致性。</p><p>总的来说，<strong>在分布式系统中，当我们期望一个操作（一个请求、一个方法、一个数据库操作...）在整个系统中同一时间只能有一个线程执行，那我们就需要用到分布式锁；</strong> 抽象来看就是两个场景：</p><ul><li>单一资源的数据变更：比如对共享存储数据（数据库、缓存...）进行修改，多线程的互斥</li><li>access token：对于多个资源的原子性操作，期望整个业务逻辑就是单一线程执行保持一致性，在入口处就锁住</li></ul><p>分布式锁应该具备的特性：</p><ul><li>原子性：在分布式系统中，一个方法在同一时间只能被一个线程执行</li><li>阻塞性：在没获取到锁时可以进行阻塞也可以返回失败</li><li>高可用：能够正确的获取锁和释放锁，且具备锁失效的能力</li><li>高性能：获取锁与释放锁的性能保障</li><li>可重入：能够具备可重入特性</li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h3><h3 id="乐观锁实现"><a href="#乐观锁实现" class="headerlink" title="乐观锁实现"></a>乐观锁实现</h3><p>先去干，能不能干，能不能干成先不管，这就是乐观心态。在开发过程中，乐观锁用的非常多，比如典型的 CAS ；在不加锁的情况下保证数据的一致性。</p><p>使用方式也很简单，只需要在表中添加一个版本号的字段，每次对数据进行修改的时候，通过版本来确定是否能够更新 <code>update xx set version = OLD_VERSION+1 where id = ID and version = OLD_VERSION</code> , 如果更新不成功，客户端可以选择是否重试。当然，需要加上索引。</p><p>可见这种方式的优势其实很明显，不加锁，使用简单。但也有一些局限性</p><ul><li>只能支持单数据更新的一致性（对于数据的插入可以通过唯一索引来解决</li><li>由于是乐观锁（先干，在检查），也就意味着可能活干完咯，发现更新不了，浪费了计算资源</li><li>无法支持 access token</li></ul><h3 id="悲观锁实现"><a href="#悲观锁实现" class="headerlink" title="悲观锁实现"></a>悲观锁实现</h3><p>先自我审查自己能不能干，能不能干成，如果答案是no，那么就等着(阻塞)或先溜(返回)，这就是悲观心态。悲观锁在 access token 模式更加适用。</p><p>使用方式同样很好理解（这只是基于数据库的悲观锁的一种实现方式）</p><ol><li>有一张 <strong>资源锁</strong> 表，表中包含 <strong>锁</strong> 字段，并需要加上唯一索引</li><li>当有线程想要获取某个锁时，只需要在 <strong>资源锁</strong> 表中插入一条数据</li><li>如果插入成功，表示获取锁成功，插入失败则表示锁已经被占用</li><li>业务执行完释放锁，删除对应的锁记录即可</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 创建资源锁表</span><br><span class="line">CREATE TABLE &#96;resource_lock&#96; (</span><br><span class="line">  &#96;id&#96; int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,</span><br><span class="line">  &#96;lock_name&#96; varchar(64) NOT NULL COMMENT &#39;锁名&#39;,</span><br><span class="line">  &#96;update_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;uidx_method_name&#96; (&#96;lock_name&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2. 获取锁（插入成本表示获取到锁</span><br><span class="line">INSERT INTO resource_lock (lock_name) VALUES (&#39;lockName&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3. 释放锁</span><br><span class="line">delete from resource_lock where lock_name &#x3D;&#39;lockName&#39;;</span><br></pre></td></tr></table></figure><p>乍一看好像很简单，如果程序一直保证正确执行，这种方式好像也行，但没如果... 对于一个分布式系统，服务宕机是会出现的，所以还需要考虑一些新的可能发生的问题</p><ul><li>没有失效机制：持有锁的线程所在的服务宕机了，还没来的及释放锁怎么办？ 可以通过在表中新增过期时间，写一个定时任务定期删除过期锁</li><li>不可重入：需要在表中新增线程信息，重入的时候先查询是否存在锁</li><li>不支持锁阻塞：需要编写相应的逻辑</li><li>基于数据库实现，那么数据库的可用性就需要得到保证，而且在并发大的时候，对于数据库的性能的影响问题</li></ul><p>这么一分析...为了确保悲观锁的功能完整性，实现也会越来越复杂...以至于既然要用存储去实现，为撒不直接用缓存，性能至少有保障。</p><h3 id="基于Redis-：AP架构"><a href="#基于Redis-：AP架构" class="headerlink" title="基于Redis ：AP架构"></a>基于Redis ：AP架构</h3><p>既然想到存储用缓存来做，那必然想到的第一个就是 Redis 了，Redis 也很给力，可以很好的支撑分布式锁的能力，提供了比较好用的命令</p><ul><li><code>setnx</code>: 当且仅当 key 不存在，将 key 的值设为 value ，并返回1；若给定的 key 已经存在，则 SETNX 不做任何动作，并返回0。</li><li><code>expire</code>: 为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。</li></ul><p>大致的流程如下图</p><p><img data-src="https://pic1.zhimg.com/80/v2-e3fc985099d4a5afc7a52a30300dd288_720w.jpg" alt="img"></p><ol><li>client A 和 client B 同时执行 <code>setnx(&quot;lock&quot;,UUID)</code> 尝试获取到锁，Redis 的实现保证了只会有一个 client 成功，假如 client A 运气好成功了</li><li>client A 紧接着马上设置一个过期时间<code>expire(&quot;lock&quot;,10)</code></li><li>client A 继续执行业务逻辑</li><li>执行完业务逻辑后释放锁</li></ol><p>如果程序能够正常走，好像也没什么问题...但我们知道分布式架构中，网络是不可靠的，如果在设置过期时间前 client B 挂掉咯，那就 GG 了，因为没有设置过期时间，那就成死锁了.. 就像下面这样</p><p><img data-src="https://pic3.zhimg.com/80/v2-ce8a50e076035057f20bbc7527fb9496_720w.jpg" alt="img"></p><p>所以我们需要保证<code>setnx</code>和<code>expire</code>的原子性。在 Redis 2.6.12 之后增强了<code>setnx</code>命令，可以同时设置过期时间，从而保证原子性。</p><p><img data-src="https://pic3.zhimg.com/80/v2-3b5f6b1211a6b1ef0384d82a3ed2d202_720w.jpg" alt="img"></p><p>解决了死锁问题，再来看看过期时间的问题，我们如何判断我们应该设置多长时间的过期时间？</p><ul><li>设置短了，业务逻辑可能还没执行完，锁被释放了，被其它线程获取执行</li><li>设置长了，需要业务逻辑处理完了自己释放锁（同样会存在线程挂掉的情况）</li></ul><p>其实我们想要到达一种效果，如果能够自动<strong>续期</strong>，锁快要过期了，但是业务操作还没有处理完，就自动对锁进行续期。Java 中的 Redisson 客户端就通过 watch dog 机制（守护线程）来支持这个功能。</p><p>通过 Redisson 客户端获取锁时会创建一个守护线程，通过守护线程来定期 check 过期时间，如果业务逻辑还在运行，那么就会续时。如果程序宕机，那么守护线程也会一起挂掉，redis 中的锁也将不会再次续时，最后过期。从而自动实现续期且不会出现死锁的问题。</p><p>简单回顾一下，我们解决了</p><ul><li>获取锁和设置过期时间的原子性问题</li><li>过期时间自动续时的问题</li></ul><p>在单机模式下看起来已经没什么问题了。而在生产环境下一般都会是集群模式，比如哨兵模式。得益于 Redis 的 AP 架构，选择了可用性，使得其性能非常好，但也正是因为AP架构，可能会导致数据丢失的情况。</p><p><img data-src="https://pic2.zhimg.com/80/v2-f688f0fffc79c1cb684cdefe63277ee5_720w.jpg" alt="img"></p><ol><li>client A 获取锁成功</li><li>master 节点在同步锁信息到 slave 节点时，master 宕机，信息没有向 slave 节点同步成功</li><li>slave 节点通过选举成为 master 节点</li><li>client B 再次获取相同的锁，发现 slave 节点上并没有其它线程占用，所以也获取到了锁</li><li>client A 和 client B 获取到了相同的锁</li></ol><p>当然，这个是非常极端的情况下会出现的问题；虽然 Redis 之父 Antirez 提出来了分布式锁的一种 「健壮」 的实现算法 RedLock，但依旧还是会有新的问题，比如节点奔溃重启、时钟跳跃...</p><p>总的来看，基于 Redis 实现分布式锁是很常用的，性能也比较高，满足绝大部分业务场景，如果我们能够接受非常极端情况下带来的锁丢失问题，Redis 分布式锁是个很好的选择。</p><h3 id="基于Zookeeper-：CP-架构"><a href="#基于Zookeeper-：CP-架构" class="headerlink" title="基于Zookeeper ：CP 架构"></a>基于Zookeeper ：CP 架构</h3><p>Zookeeper 是一种提供「分布式服务协调」的中心化服务，是以 Paxos 算法为基础实现的。Zookeeper 采用的是 CP 架构，选择了强一致性，这也就意味着不会像 Redis 那样出现数据丢失的情况（主从切换时），但为了实现强一致性，那么性能肯定是要比 Redis 差一些。</p><p>使用 Zookeeper 来实现分布式锁是比较简单的</p><ol><li>client 会在 Zookeeper 中创建一个<strong>临时节点</strong>，比如`/zk/lock</li><li>如果获取成功，那么 client 会创建一个 session 保持和 Zookeeper <strong>临时节点</strong>的关联</li><li>client 处理业务逻辑</li><li>client 处理完业务逻辑后删除 <strong>临时节点</strong>，关闭 session</li></ol><p>如果 client 宕机，那么 session 就会结束，临时节点也会自动删除，其它 client 就可以创建 <code>lock</code> 节点。</p><p>session 的维护是依赖于 client 的定时心跳来维护的，也就是说，如果 client 没有及时的给 Zookeeper 发送心跳检查，那么 Zookeeper 就会认为这个 session 已经过期了，就会删除调临时节点。比如出现长时间的 GC 或者长时间的网络延迟，都可能会导致临时节点被删除的可能。</p><p>对于 Zookeeper 来说，实现分布式锁从使用者角度来看比较简单，不需要考虑太多的东西，比如过期时间的设置。但维护成本会比较高，性能相对 Redis 也会差一些，以及可能会出现长时间失联导致的节点数据丢失的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>优先使用基于数据库的乐观锁</li><li>如果期望更高的性能且能够接受极少数情况的锁丢失，那么优先选择 Redis</li><li>如果期望尽可能的避免锁丢失，优先选择 Zookeeper，且考虑 GC 时间和 心跳检查的设置</li><li>在分布式系统中极端情况下，分布式锁都不太可靠，所以需要我们在业务层面的入口也相应的隔离，在真的发生了锁丢失导致的数据不一致的情况做对应的补偿</li></ol></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag"># 分布式</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2022/09/24/MySQL-Explain/" rel="prev" title="MySQL Explain"><i class="fa fa-chevron-left"></i> MySQL Explain</a></div><div class="post-nav-item"> <a href="/2023/01/09/MySQL%E4%BD%BF%E7%94%A8LOAD-DATA-INFILE%E5%AF%BC%E5%85%A5%E5%A4%A7%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE/" rel="next" title="MySQL使用LOAD DATA INFILE导入大批量数据">MySQL使用LOAD DATA INFILE导入大批量数据<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">湘ICP备19011756号-1</a></div><div class="copyright"> &copy; 2021 – <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">JIAHE</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/quicklink@2.3.0/dist/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"ignores":null,"url":"http://xiaojianzheng.cn/2022/09/25/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}</script><script src="/js/third-party/quicklink.js"></script></body></html>