<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IdeaVim插件使用技巧</title>
    <url>/2021/02/07/IdeaVim%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>在 IDEA Intellij小技巧和插件 一文中简单介绍了一下IdeaVim插件。在这里详细总结一下这个插件在日常编程中的一些常用小技巧。</p>
<p>供有兴趣使用这个插件，但对Vim还不十分熟悉的朋友参考。当然基本的hjkl移动光标和几种常见模式等等基本概念就略过不提了。</p>
<p>为了确保只包含常用操作，这里提到的技巧都没有从现成文档里抄，而是凭记忆列出（不常用自然就不记得了）。</p>
<p>估计会有所遗漏，慢慢再补充。</p>
<a id="more"></a>

<h1 id="1-切换Vim模拟器状态"><a href="#1-切换Vim模拟器状态" class="headerlink" title="1. 切换Vim模拟器状态"></a>1. 切换Vim模拟器状态</h1><p>这个插件允许设置一个快捷键一键开启或关闭，在切换模式时会同时自动切换keymap，十分方便。默认键位是Ctrl+Alt+V，但这个键位覆盖了很常用的“抽取局部变量”功能，建议重设，在setting-&gt;keymap中查找VIM Emulator即可。</p>
<p>由于开启和关闭状态分别使用两套keymap，因此两套都需要设定。可以把两套keymap下的都设为一样的键，也就是用同一个键切换。但个人建议设为不同的键，这样能清楚知道当前处于那种模式中。并且，如果在开启Vim的插入模式下关闭Vim模拟器，下次进入时仍然是插入模式，比较混乱（因为你关闭模拟器就是为了使用默认keymap输入大段代码，重新开启Vim模拟器就是为了使用普通模式下的命令）。</p>
<p>因此建议把Vim keymap中的Exit Insert Mode设为与另一个keymap的Vim Emulator相同的键（也就是进入Vim模拟器的快捷键）。</p>
<p>例如，我使用的设定是：</p>
<p>Default keymap -&gt; Vim Emulator : Ctrl+;     (用Ctrl+分号开启Vim模拟器）<br>Vim keymap -&gt; Vim Emulator : Ctrl+,    (用Ctrl+逗号关闭Vim模拟器）<br>Vim keymap -&gt; Vim Emulator : Ctrl+;    (用Ctrl+分号退出插入模式，进入普通模式）<br>这样，在任何时候只要连按两下ctrl+分号，就能保证必定在Vim模拟器的普通模式中。</p>
<h1 id="2-ScrollOff-参数"><a href="#2-ScrollOff-参数" class="headerlink" title="2. ScrollOff 参数"></a>2. ScrollOff 参数</h1><p>启动Intellij后在Vim模拟器下输入命令 :</p>
<p>set so=5<br>可以令屏幕滚动时在光标上下方保留5行预览代码（也就是光标会在第5行触发向上滚动，或者在倒数第5行触发向下滚动）。</p>
<p>在代码窗口比较狭小时（例如单步跟踪调试时）非常方便。可惜仅在Vim模拟器开启时有效。</p>
<h1 id="3-行号定位"><a href="#3-行号定位" class="headerlink" title="3. 行号定位"></a>3. 行号定位</h1><p>普通模式下输入 行号G 或 :行号&lt;回车&gt; 都能快速定位到某一行。</p>
<p>区别在于前者在输入行号时屏幕上没有任何提示，后者则在Vim命令输入框中可以看到输入过程。</p>
<p>（题外话：Sublime Text 2也是用 :行号 来快速定位到某行，应该是沿用了Vim的习惯）</p>
<h1 id="4-进入修改"><a href="#4-进入修改" class="headerlink" title="4. 进入修改"></a>4. 进入修改</h1><p>进入插入模式的方式有很多，直接选用合适的方式进入插入模式比进入后再用箭头键移动光标要好。常用的有：</p>
<p>o - 在当前行下方插入新行并自动缩进<br>O - 在当前行上方插入新行并自动缩进 （普通模式下的大写字母命令用 shift+字母键 输入，下同）<br>i - 在当前字符左方开始插入字符<br>a - 在当前字符右方开始插入字符<br>I - 光标移动到行首并进入插入模式<br>A - 光标移动到行尾并进入插入模式<br>s - 删除光标所在字符并进入插入模式<br>S - 删除光标所在行并进入插入模式<br>c&lt;范围&gt; - 删除光标所在位置周围某个范围的文本并进入插入模式。关于范围请看第5点，常用的组合有：caw - 删除一个单词包括它后面的空格并开始插入；ciw - 删除一个单词并开始插入；ci” - 删除一个字符串内部文本并开始插入；c$ - 从光标位置删除到行尾并开始插入；ct字符 - 从光标位置删除本行某个字符之前（保留该字符）并开始插入。等等。<br>C - 删除光标位置到行尾的内容并进入插入模式 (相当于c$)<br>r - 修改光标所在字符，然后返回普通模式<br>R - 进入覆盖模式</p>
<h1 id="5-范围操作"><a href="#5-范围操作" class="headerlink" title="5. 范围操作"></a>5. 范围操作</h1><p>某些普通模式的动作命令后面可以追加一些表示范围的指令，表示该动作将作用在整个范围上。这类命令常用的有：</p>
<p>d&lt;范围&gt; - 删除一定范围内的文本<br>c&lt;范围&gt; - 删除一定范围内的文本并进入插入模式<br>y&lt;范围&gt; - 将范围内的文本放入0号和”号注册栏<br>v&lt;范围&gt; - 选择范围内的文本<br>=&lt;范围&gt; - 自动缩进范围内的文本<br>gU&lt;范围&gt; - 将范围内的字符转换为大写<br>gu&lt;范围&gt; - 将范围内的字符转换为小写</p>
<blockquote>
<p>&lt;范围&gt; - 将范围中的内容缩进一格<br>&lt;&lt;范围&gt; - 将范围中的内容取消缩进一格<br>常用的范围指令有：</p>
</blockquote>
<p>空格 - 光标所在位置字符。（例如 gU空格 - 将光标位置字符转为大写）<br>重复某些动作命令 - 光标所在行。 （例如dd删除一行，yy复制一行，cc删除一行文本并开始插入，&gt;&gt; 当前行缩进一格，==自动缩进当前行）<br>$ - 从光标位置到行尾<br>^ - 从光标位置到行首，不包含缩进空白<br>0 - 从光标位置到行首，包含缩进空白<br>gg - 从光标位置到文件开头<br>G - 从光标位置到文件结尾<br>% - 从光标位置到另一边匹配的括号<br>f&lt;字符&gt; - 从光标位置到光标右边某个字符首次出现的位置，包括该字符<br>F&lt;字符&gt; - 从光标位置到光标左边某个字符首次出现的位置，包括该字符<br>t&lt;字符&gt; - 从光标位置到光标右边某个字符首次出现的位置，包括该字符<br>F&lt;字符&gt; - 从光标位置到光标左边某个字符首次出现的位置，包括该字符<br>/正则表达式 - 从光标位置到下一个匹配正则表达式的位置（跨行）<br>?正则表达式 - 从光标位置到上一个匹配正则表达式的位置（跨行）<br>aw - 一个单词加一个空格 （a可理解为“一个”，下同）<br>iw - 一个单词 （i可理解为in，下同）<br>a” - 一个字符串包括双引号<br>i” - 一个字符串内部文本<br>a&lt; - 一组&lt; &gt;包含的文本，包括&lt; &gt;号本身<br>同理类推：i&lt;, a[, i[, a(, i(<br>注意：真正vim中的it范围（一对xml标签内部）在ideaVim中不生效。<br>用/或?命令查找时，正则表达式默认大小写敏感，如果需要不敏感，可以在正则表达式开始处加上\c标志。</p>
<p>例如 /\cabc 可以匹配到 ABC。下面提到的:s命令同样适用。</p>
<h1 id="6-选择文本"><a href="#6-选择文本" class="headerlink" title="6. 选择文本"></a>6. 选择文本</h1><p>在Vim中，选择文本需要进入“可视模式”（Visual Mode），这个名称比较奇怪，它的来由据说是因为在Vim的前身Vi中，选择区域是不可见的。</p>
<p>在Vim中选择区域会高亮显示，因此称为“可视模式”。</p>
<p>v - 进入字符选择模式， V - 进入行选择模式， Ctrl+v - 进入块选择模式。<br>进入相应模式后移动光标即可选中文本。过程中可按o键令光标在选区两端切换。</p>
<p>在块选择模式中选中多行，然后按I或A后输入文本，再退出插入模式，所输入的文本将自动加入到每一行的开头或结尾。</p>
<h1 id="7-复制粘贴"><a href="#7-复制粘贴" class="headerlink" title="7. 复制粘贴"></a>7. 复制粘贴</h1><p>在Vim模式下，复制粘贴并不直接使用系统的剪贴板，而是使用Vim提供的多个“寄存器”，每个寄存器都以一个字符来表示。</p>
<p>关于寄存器的详细说明可以看这里 <a href="http://blah.blogsome.com/2006/04/27/vim_tut_register/">http://blah.blogsome.com/2006/04/27/vim_tut_register/</a> （随便google的一个网页），这里简单列一些常用的操作技巧</p>
<p>（注意，vim使用双引号”来作为选择寄存器的命令，因此下文中的双引号均指在普通模式下按双引号键）：</p>
<p>a）用y命令将文本存入寄存器后，如果想在别处替换原有内容，可以先用v命令选中原有内容，然后用p命令粘贴。</p>
<p>但第一次粘贴后，默认的寄存器”将被替换为刚刚删除的内容。如果要再次粘贴之前复制的内容，需要使用 “0p 命令组合来复制。</p>
<p>也可以进入插入模式后用 Ctrl+r 0 来复制，例如 ciw&lt;Ctrl+r&gt;0 命令组合将用粘贴内容替换光标处的一个单词，并停留在插入模式。</p>
<p>b）在Windows下，寄存器 + 和 * 都代表系统剪贴板，可以互换使用，选一个顺手的即可。</p>
<p>例如 “+yy 命令组合可将当前行复制到系统剪贴板。ci”&lt;Ctrl+r&gt;* 命令组合则将系统剪贴板的内容替换字符串的内部文本。</p>
<p>c) 寄存器1至9记录之前九次的删除大段文本，每次超过一行的删除操作都会导致这9个寄存器的内容发生位移，最近删除的文本会存入寄存器1。</p>
<p>但只有删除超过1行时才会影响寄存器1至9，行内的删除内容则会被存入寄存器-（减号）。</p>
<p>如果用q命令录制宏时不涉及跨行删除，可以在宏中直接使用这9个寄存器来暂存文本。</p>
<p>（在Vim中，复制内容与录制宏共享同一套寄存器，因此我习惯把字母寄存器留给宏使用）</p>
<p>d) 普通模式下小写p把寄存器内容复制到当前位置之后，大写P把寄存器内容复制到当前位置之前。</p>
<p>e) 使用 :regs 命令可以列出当前所有寄存器的内容</p>
<p>8.一些插入模式下的常用快捷键<br>Ctrl+h - 删除光标左边字符<br>Ctrl+w - 删除光标左边的单词<br>Ctrl+y - 复制上方的一个字符<br>Ctrl+e - 复制下方的一个字符<br>Ctrl+r 0 - 插入前一次用y命令寄存的内容<br>Ctrl+r * - 插入系统剪贴板的内容<br>Ctrl+r &lt;寄存器名称&gt; - 插入指定寄存器的内容<br>Ctrl+a - 插入前一次插入模式所键入的内容<br>Ctrl+o - 执行一个普通模式下的命令然后返回插入模式。 例如 Ctrl+o A 相当于按 End键， Ctrl+o I相当于按Home键</p>
<h1 id="9-退出插入模式"><a href="#9-退出插入模式" class="headerlink" title="9. 退出插入模式"></a>9. 退出插入模式</h1><p>退出插入模式可以用 ESC 键，但键位太远。其实也可以用 Ctrl+[ 键退出插入模式 。</p>
<p>当然也可以用第1点自定义的Ctrl+;快捷键，但这不是标准vim按键，会养成不良习惯，不建议使用。</p>
<h1 id="10-重复操作"><a href="#10-重复操作" class="headerlink" title="10. 重复操作"></a>10. 重复操作</h1><p>普通模式下按. （小数点）可重复上一次的修改操作</p>
<p>&amp; - 重复上一次的:s替换命令<br>@@ - 重复上一次执行的宏</p>
<h1 id="11-跳转"><a href="#11-跳转" class="headerlink" title="11. 跳转"></a>11. 跳转</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">Ctrl+] 跳转到当前标识符的定义位置 （相当于在当前光标位置的单词上按住ctrl用鼠标点击）<br>Ctrl+o 回退一步 (go back)<br>Ctrl+i 前进一步 (go forward)<br>\`. 跳转到之前修改位置<br>\<span class="hljs-code">`\`</span> 在前一次跳转位置与当前位置间切换<br>行号G 或 :行号&lt;回车&gt;  跳转到某一行<br>gg 跳转到文件开头<br>G  跳转到文件末尾<br>H  跳转到屏幕顶端（如果设置了set so=n，则跳转到第n行）<br>L  跳转到屏幕底端（如果设置了set so=n，则跳转到倒数第n行）<br>M  跳转到屏幕中间<br>f 或 F 跳转到本行某个字符，小写f向右查找，大写F向左查找。用;或,在匹配间切换<br>t 或 T 跳转到本行某个字符之前，小写t向右查找，大写T向左查找。用;或,在匹配间切换<br>/正则表达式  跳转到下一个匹配。用n或N在匹配间切换。<br>?正则表达式  跳转到上一个匹配。用n或N在匹配间切换。<br></code></pre></td></tr></table></figure>
<p>（结合前面第5点，你也许注意到了，在指定范围时，使用跳转命令将指定一个从光标位置到跳转目标的区域）</p>
<h1 id="12-书签"><a href="#12-书签" class="headerlink" title="12. 书签"></a>12. 书签</h1><p>在普通模式下按 m&lt;小写字母&gt; 即可定义书签，按 &lt;字母&gt; 则可跳转到某个书签的精确位置，按 &lt;字母&gt;可跳转到某个书签所在行的行首（用来录制宏时比较有用）。</p>
<p>最常用的自然是mm, mn, mj, mk, ml这几个顺手的键位。</p>
<p>真正的vim中的全局书签 m&lt;大写字母&gt; 在目前IdeaVim版本中不生效。需要定义全局书签可以使用Idea原本的 F11 + 数字 方式</p>
<h1 id="13-文本替换"><a href="#13-文本替换" class="headerlink" title="13. 文本替换"></a>13. 文本替换</h1><p>使用 :s/正则表达式/替换文本/ 可在本行内替换首次出现的匹配</p>
<p>使用 :s/正则表达式/替换文本/g 在本行内替换所有出现的匹配</p>
<p>使用 :%s/正则表达式/替换文本/g 在当前文件内替换所有出现的匹配</p>
<p>在可视模式下选中文本后，使用:’&lt;,’&gt;s/正则表达式/替换文本/g 命令可在选中区域中替换文本。</p>
<p>其中’&lt;,’&gt;部分在可视模式下，按:冒号后自动加入，直接输入s命令即可。但有效区域只能以行为单位。</p>
<p>真正Vim中的 %V 标志在IdeaVim中不生效。</p>
<h1 id="14-宏定义"><a href="#14-宏定义" class="headerlink" title="14. 宏定义"></a>14. 宏定义</h1><p>在IdeaVim中定义宏比Idea自带的宏功能要轻量许多。</p>
<p>按在普通模式下 q&lt;寄存器名称&gt; 即可开始把后续按键序列录制到指定寄存器中（寄存器参考前面第7条）。录制完毕进入普通模式再按q键即可停止录制。</p>
<p>之后用 @&lt;寄存器名称&gt; 即可重放。需要注意的是宏和复制粘贴共用一套寄存器，因此在录制宏时就注意不要把当前宏正在使用的寄存器用来复制了。</p>
<p>寄存器内容是自动保存的，重启Idea仍然生效。但IdeaVim没有导出宏独立保存的功能。因此最好把用来保存宏的寄存器和用来复制粘贴的寄存器分开，不要同一个寄存器有时用来记录宏，有时用来复制粘贴。我的习惯是键盘左手区用来保存一些长期使用的宏（比如说我有一个宏专门用来把pom.xml中的版本号抽取到property区域，原来的位置则改用${property}引用）。</p>
<p>右手区的hjklnm键用来保存一些临时宏。yuiop五个寄存器保留用来复制粘贴。如果录制的宏不涉及删除大段代码，寄存器1至9也可以用来进行复制粘贴。</p>
<p>执行一次宏后，可以用@@命令重复上一次执行的宏。</p>
<p>在Idea中录制宏时，如果触发了代码自动完成，在自动完成列表启动的状态输入的字符不会被记录。因此最好在Setting -&gt; Code Completion -&gt; Autopopup code completion中把延迟设为500ms以上或干脆关掉。在录制宏的过程中避免触发代码自动完成功能。</p>
<p>录制一些长期有效的宏时，开始录制后，最好先用0，^，T, F, $等命令把光标对齐到行首行末或某个特定起始位置（比如说用 F” 跳转到字符串的左边引号），再用一个f或/指令跳转到操作位置，这样的宏就不用必须把光标放在某个特定字符才能使用了。</p>
<h1 id="15-一些常用组合技"><a href="#15-一些常用组合技" class="headerlink" title="15. 一些常用组合技"></a>15. 一些常用组合技</h1><p>全选：ggvG<br>调换两个字符位置：xp<br>复制一行：yyp<br>调换两行位置：ddp<br>插入模式下到行尾继续输入（相当于End键）：Ctrl+o A 或 Ctrl+[ A<br>插入模式下到行首继续输入（相当于Home键）：Ctrl+o I 或 Ctrl+[ I<br>到类定义位置（适用于正确缩进的public，protected类） ：?^p回车</p>
<h1 id="16-一些在目前版本已知没有实现的一些常用Vim功能"><a href="#16-一些在目前版本已知没有实现的一些常用Vim功能" class="headerlink" title="16. 一些在目前版本已知没有实现的一些常用Vim功能"></a>16. 一些在目前版本已知没有实现的一些常用Vim功能</h1><p>（如果对Vim不熟悉可以跳过这节）</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">a）let命令 （没有let命令就无法导出/导入寄存器内容，也就是无法导入宏）<br>b）:g命令 （在文本处理中很有用的一个命令，在编程中倒是不那么常用）<br>c）!命令 （执行shell命令）<br>d）大部分正则表达式标记 （例如 \%V， \v 等等）<br>e) 某些多键命令双击最后一个字符表示作用于当前行。例如在Vim中gUU可以把当前行转换为大写，在IdeaVim中无效，实现同样功能可以先用V命令选中当前行，再用gU转换为大写。<br>f）关于窗口操作的大部分命令 （Ctrl+w系列命令, :split等）<br>g）所有Vim脚本插件 （不过大部分可以用Idea自身的功能和插件来补偿）<br>zo - 打开折叠<br>zc - 关闭折叠<br></code></pre></td></tr></table></figure>
<p>嗯，差点忘了，在普通模式下按u撤销上一个修改（相当于其他IDE的Ctrl+z），按Ctrl+r重做被撤销的修改。</p>
<blockquote>
<p>转载于：<a href="https://www.iteye.com/blog/kidneyball-1828427">https://www.iteye.com/blog/kidneyball-1828427</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Vim</tag>
        <tag>Idea</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim常用配置</title>
    <url>/2021/02/03/Vim%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><br><span class="hljs-string">&quot; 基本配置 &quot;</span><br><span class="hljs-keyword">set</span> nocompatible <span class="hljs-comment">&quot; 不与 Vi 兼容（采用 Vim 自己的操作命令）。</span><br><span class="hljs-keyword">syntax</span> <span class="hljs-keyword">on</span> <span class="hljs-comment">&quot; 打开语法高亮。自动识别代码，使用多种颜色显示。</span><br><span class="hljs-keyword">set</span> showmode <span class="hljs-comment">&quot; 在底部显示，当前处于命令模式还是插入模式。</span><br><span class="hljs-keyword">set</span> showcmd <span class="hljs-comment">&quot; 命令模式下，在底部显示，当前键入的指令。比如，键入的指令是2y3d，那么底部就会显示2y3，当键入d的时候，操作完成，显示消失。</span><br><span class="hljs-keyword">set</span> t_Co = <span class="hljs-number">256</span> <span class="hljs-comment">&quot; 启动256色</span><br><span class="hljs-comment">&quot; 设置编码</span><br><span class="hljs-keyword">set</span> fileencodings=utf-<span class="hljs-number">8</span>,ucs-bom,gb18030,gbk,gb2312,cp936<br><span class="hljs-keyword">set</span> termencoding=utf-<span class="hljs-number">8</span><br><span class="hljs-keyword">set</span> encoding=utf-<span class="hljs-number">8</span><br><span class="hljs-keyword">set</span> langmenu=zh_CN.UTF-<span class="hljs-number">8</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">version</span> &gt;= <span class="hljs-number">603</span><br>    <span class="hljs-keyword">set</span> helplang=<span class="hljs-keyword">cn</span><br><span class="hljs-keyword">endif</span><br><span class="hljs-comment">&quot; 启用鼠标</span><br><span class="hljs-keyword">set</span> mouse = <span class="hljs-keyword">a</span><br><span class="hljs-keyword">set</span> selection = exclusive<br><span class="hljs-keyword">set</span> selectmode = mouse, key<br><span class="hljs-comment">&quot; 打开文件类型检测</span><br><span class="hljs-keyword">filetype</span> plugin <span class="hljs-keyword">on</span><br><span class="hljs-keyword">filetype</span> <span class="hljs-built_in">indent</span> <span class="hljs-keyword">on</span> <span class="hljs-comment">&quot; 开启文件类型检查，并且载入与该类型对应的缩进规则。比如，如果编辑的是.py文件，Vim 就是会找 Python 的缩进规则~/.vim/indent/python.vim</span><br><br><span class="hljs-string">&quot; 搜索相关 &quot;</span><br><span class="hljs-keyword">set</span> showmatch <span class="hljs-comment">&quot; 光标遇到圆括号、方括号、大括号时，自动高亮对应的另一个圆括号、方括号和大括号</span><br><span class="hljs-keyword">set</span> hlsearch <span class="hljs-comment">&quot; 高亮搜索匹配结果</span><br><span class="hljs-keyword">set</span> ignorecase <span class="hljs-comment">&quot; 搜索时忽略大小写</span><br><span class="hljs-keyword">set</span> incsearch <span class="hljs-comment">&quot; 搜索模式下，每输入一个字符，就自动跳至第一个匹配结果</span><br><span class="hljs-keyword">set</span> smartcase <span class="hljs-comment">&quot; 同时打开了ignorecase, 仅对只有一个大写字母的单词敏感</span><br><br><br><span class="hljs-string">&quot; 编辑相关 &quot;</span><br><span class="hljs-keyword">set</span> spell spelllang=en_us <span class="hljs-comment">&quot; 英语单词 拼写检查</span><br><span class="hljs-keyword">set</span> nobackup <span class="hljs-comment">&quot; 不创建备份文件, 默认情况下，文件保存时，会额外创建一个备份文件，它的文件名是在原文件名的末尾，再添加一个波浪号（〜）</span><br><span class="hljs-keyword">set</span> noswapfile <span class="hljs-comment">&quot; 不创建交换文件, 交换文件主要用于系统崩溃时恢复文件，文件名的开头是.、结尾是.swp</span><br><span class="hljs-keyword">set</span> <span class="hljs-built_in">undofile</span> <span class="hljs-comment">&quot; 保留撤销历史, Vim 会在编辑时保存操作历史，用来供用户撤消更改。默认情况下，操作记录只在本次编辑时有效，一旦编辑结束、文件关闭，操作历史就消失了。打开这个设置，可以在文件关闭后，操作记录保留在一个文件里面，继续存在。这意味着，重新打开一个文件，可以撤销上一次编辑时的操作。撤消文件是跟原文件保存在一起的隐藏文件，文件名以.un~开头。</span><br><span class="hljs-keyword">set</span> paste <span class="hljs-comment">&quot; 粘贴模式</span><br><span class="hljs-keyword">set</span> autochdir <span class="hljs-comment">&quot; 自动切换工作目录。这主要用在一个 Vim 会话之中打开多个文件的情况，默认的工作目录是打开的第一个文件的目录。该配置可以将工作目录自动切换到，正在编辑的文件的目录。</span><br><span class="hljs-keyword">set</span> visualbell <span class="hljs-comment">&quot; 出错时，发出视觉提示，通常是屏幕闪烁。</span><br><span class="hljs-keyword">set</span> noerrorbells <span class="hljs-comment">&quot; 出错时，不要发出响声。</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">history</span> = <span class="hljs-number">1000</span> <span class="hljs-comment">&quot; Vim 需要记住多少次历史操作。</span><br><span class="hljs-keyword">set</span> listchars=<span class="hljs-keyword">ta</span><span class="hljs-variable">b:</span>»■,trai<span class="hljs-variable">l:</span>■ <span class="hljs-comment">&quot; 如果行尾有多余的空格（包括 Tab 键），该配置将让这些空格显示成可见的小方块。</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">list</span><br><span class="hljs-keyword">set</span> wildmenu <span class="hljs-comment">&quot; 命令模式下，底部操作指令按下 Tab 键自动补全。第一次按下 Tab，会显示所有匹配的操作指令的清单；第二次按下 Tab，会依次选择各个指令。</span><br><span class="hljs-keyword">set</span> wildmode=longes<span class="hljs-variable">t:list</span>,full<br><br><br><span class="hljs-string">&quot; 外观相关 &quot;</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">number</span> <span class="hljs-comment">&quot; 显示行号</span><br><span class="hljs-keyword">set</span> relativenumber <span class="hljs-comment">&quot; 显示光标所在的当前行的行号，其他行都为相对于该行的相对行号</span><br><span class="hljs-keyword">set</span> guifont = Courier_Ne<span class="hljs-variable">w:h10</span>:cANSI <span class="hljs-comment">&quot; 字体</span><br><span class="hljs-keyword">set</span> cursorline <span class="hljs-comment">&quot; 光标所在的当前行高亮</span><br><span class="hljs-keyword">set</span> cursorcolumn <span class="hljs-comment">&quot; 突显当前列</span><br><span class="hljs-keyword">set</span> textwidth = <span class="hljs-number">80</span><br><span class="hljs-keyword">set</span> wrap <span class="hljs-comment">&quot; 自动折行，即太长的行分成几行显示, nowrap</span><br><span class="hljs-keyword">set</span> linebreak <span class="hljs-comment">&quot; 只有遇到指定的符号（比如空格、连词号和其他标点符号），才发生折行。也就是说，不会在单词内部折行</span><br><span class="hljs-keyword">set</span> wrapmargin = <span class="hljs-number">2</span> <span class="hljs-comment">&quot; 指定折行处与编辑窗口的右边缘之间空出的字符数</span><br><span class="hljs-keyword">set</span> scrolloff = <span class="hljs-number">5</span> <span class="hljs-comment">&quot; 垂直滚动时，光标距离顶部/底部的位置（单位：行）</span><br><span class="hljs-string">&quot; set sidescrolloff = 15 &quot;</span> 水平滚动时，光标距离行首或行尾的位置（单位：字符）。该配置在不折行时比较有用<br><span class="hljs-keyword">set</span> laststatus = <span class="hljs-number">2</span> <span class="hljs-comment">&quot; 是否显示状态栏。0 表示不显示，1 表示只在多窗口时显示，2 表示显示</span><br><span class="hljs-keyword">set</span> ruler <span class="hljs-comment">&quot; 在状态栏显示光标的当前位置（位于哪一行哪一列）</span><br><br><br><span class="hljs-string">&quot; 缩进相关 &quot;</span><br><span class="hljs-keyword">set</span> autoindent <span class="hljs-comment">&quot; 按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致。</span><br><span class="hljs-keyword">set</span> tabstop = <span class="hljs-number">4</span> <span class="hljs-comment">&quot; Tab长度</span><br><span class="hljs-keyword">set</span> <span class="hljs-built_in">shiftwidth</span> = <span class="hljs-number">4</span> <span class="hljs-comment">&quot; 自动缩进长度</span><br><span class="hljs-keyword">set</span> expandtab <span class="hljs-comment">&quot; 由于 Tab 键在不同的编辑器缩进不一致，该设置自动将 Tab 转为空格。</span><br><span class="hljs-keyword">set</span> softtabstop = <span class="hljs-number">4</span> <span class="hljs-comment">&quot; Tab 转为多少个空格</span><br><br><br><span class="hljs-string">&quot;让vimrc配置变更立即生效&quot;</span><br><span class="hljs-keyword">autocmd</span> BufWritePost $MYVIMRC <span class="hljs-keyword">source</span> $MYVIMRC<br><br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vim</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10常用快捷键</title>
    <url>/2021/02/05/Windows10%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="窗口相关"><a href="#窗口相关" class="headerlink" title="窗口相关"></a>窗口相关</h1><h1 id="虚拟桌面"><a href="#虚拟桌面" class="headerlink" title="虚拟桌面"></a>虚拟桌面</h1><p><code>Ctrl + Win + d</code>    新建桌面<br><code>Ctrl + Win + ←/→</code>  左右切换桌面</p>
]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows卸载自带Flash</title>
    <url>/2021/02/02/Windows%E5%8D%B8%E8%BD%BD%E8%87%AA%E5%B8%A6Flash/</url>
    <content><![CDATA[<p>参考该链接完成操作<br><a href="https://helpx.adobe.com/flash-player/kb/uninstall-flash-player-windows.html#main_Download_the_Adobe_Flash_Player_uninstaller">https://helpx.adobe.com/flash-player/kb/uninstall-flash-player-windows.html#main_Download_the_Adobe_Flash_Player_uninstaller</a></p>
]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>Flash</tag>
      </tags>
  </entry>
  <entry>
    <title>redis常用命令</title>
    <url>/2021/02/26/redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>下面总结并演示了 Redis 的 常用管理命令、key 操作、字符串、集合、列表、散列类型的操作命令。</p>
<a id="more"></a>

<h1 id="常用管理命令"><a href="#常用管理命令" class="headerlink" title="常用管理命令"></a>常用管理命令</h1><h2 id="1、启动-Redis"><a href="#1、启动-Redis" class="headerlink" title="1、启动 Redis"></a>1、启动 Redis</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> redis-server [--port 6379]</span><br></code></pre></td></tr></table></figure>
<p>如果命令参数过多，建议通过配置文件来启动 Redis。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> redis-server [xx/xx/redis.conf]</span><br></code></pre></td></tr></table></figure>
<p>6379 是 Redis 默认端口号。</p>
<h2 id="2、连接-Redis"><a href="#2、连接-Redis" class="headerlink" title="2、连接 Redis"></a>2、连接 Redis</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> ./redis-cli [-h 127.0.0.1 -p 6379]</span><br></code></pre></td></tr></table></figure>
<h2 id="3、停止-Redis"><a href="#3、停止-Redis" class="headerlink" title="3、停止 Redis"></a>3、停止 Redis</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> redis-cli shutdown</span><br><br><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">kill</span> redis-pid</span><br></code></pre></td></tr></table></figure>
<p>以上两条停止 Redis 命令效果一样。</p>
<h2 id="4、发送命令"><a href="#4、发送命令" class="headerlink" title="4、发送命令"></a>4、发送命令</h2><p>给 Redis 发送命令有两种方式：</p>
<h3 id="1、redis-cli-带参数运行，如："><a href="#1、redis-cli-带参数运行，如：" class="headerlink" title="1、redis-cli 带参数运行，如："></a>1、redis-cli 带参数运行，如：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> redis-cli shutdown</span><br>not connected&gt;<br></code></pre></td></tr></table></figure>
<p>这样默认是发送到本地的 6379 端口。</p>
<h3 id="2、redis-cli-不带参数运行，如："><a href="#2、redis-cli-不带参数运行，如：" class="headerlink" title="2、redis-cli 不带参数运行，如："></a>2、redis-cli 不带参数运行，如：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> ./redis-cli</span><br><br>127.0.0.1:6379&gt; shutdown<br>not connected&gt;<br></code></pre></td></tr></table></figure>
<h2 id="5、测试连通性"><a href="#5、测试连通性" class="headerlink" title="5、测试连通性"></a>5、测试连通性</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; ping<br>PONG<br></code></pre></td></tr></table></figure>
<h1 id="key-操作命令"><a href="#key-操作命令" class="headerlink" title="key 操作命令"></a>key 操作命令</h1><h2 id="获取所有键"><a href="#获取所有键" class="headerlink" title="获取所有键"></a>获取所有键</h2><blockquote>
<p>语法：keys pattern  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; keys *<br>1) &quot;javastack&quot;<br></code></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>表示通配符，表示任意字符，会遍历所有键显示所有的键列表，时间复杂度 O(n)，在生产环境不建议使用。</li>
</ul>
</li>
</ul>
<h2 id="获取键总数"><a href="#获取键总数" class="headerlink" title="获取键总数"></a>获取键总数</h2><blockquote>
<p>语法：dbsize  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; dbsize<br>(integer) 6<br></code></pre></td></tr></table></figure>
<p>获取键总数时不会遍历所有的键，直接获取内部变量，时间复杂度 O(1)。</p>
<h2 id="查询键是否存在"><a href="#查询键是否存在" class="headerlink" title="查询键是否存在"></a>查询键是否存在</h2><blockquote>
<p>语法：exists key [key …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; exists javastack java<br>(integer) 2<br></code></pre></td></tr></table></figure>
<p>查询查询多个，返回存在的个数。</p>
<h2 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h2><blockquote>
<p>语法：del key [key …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; del java javastack<br>(integer) 1<br></code></pre></td></tr></table></figure>
<p>可以删除多个，返回删除成功的个数。</p>
<h2 id="查询键类型"><a href="#查询键类型" class="headerlink" title="查询键类型"></a>查询键类型</h2><blockquote>
<p>语法： type key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; type javastack<br>string<br></code></pre></td></tr></table></figure>
<h2 id="移动键"><a href="#移动键" class="headerlink" title="移动键"></a>移动键</h2><blockquote>
<p>语法：move key db  </p>
</blockquote>
<p>如把 javastack 移到 2 号数据库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; move javastack 2<br>(integer) 1<br>127.0.0.1:6379&gt; select 2<br>OK<br>127.0.0.1:6379[2]&gt; keys *<br>1) &quot;javastack&quot;<br></code></pre></td></tr></table></figure>
<h2 id="查询-key-的生命周期（秒）"><a href="#查询-key-的生命周期（秒）" class="headerlink" title="查询 key 的生命周期（秒）"></a>查询 key 的生命周期（秒）</h2><blockquote>
<p>秒语法：ttl key<br>毫秒语法：pttl key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379[2]&gt; ttl javastack<br>(integer) -1<br></code></pre></td></tr></table></figure>
<p>-1：永远不过期。</p>
<h2 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h2><blockquote>
<p>秒语法：expire key seconds<br>毫秒语法：pexpire key milliseconds  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379[2]&gt; expire javastack 60<br>(integer) 1<br>127.0.0.1:6379[2]&gt; ttl javastack<br>(integer) 55<br></code></pre></td></tr></table></figure>
<h2 id="设置永不过期"><a href="#设置永不过期" class="headerlink" title="设置永不过期"></a>设置永不过期</h2><blockquote>
<p>语法：persist key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379[2]&gt; persist javastack<br>(integer) 1<br></code></pre></td></tr></table></figure>
<h2 id="更改键名称"><a href="#更改键名称" class="headerlink" title="更改键名称"></a>更改键名称</h2><blockquote>
<p>语法：rename key newkey  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379[2]&gt; rename javastack javastack123<br>OK<br></code></pre></td></tr></table></figure>
<h1 id="字符串操作命令"><a href="#字符串操作命令" class="headerlink" title="字符串操作命令"></a>字符串操作命令</h1><p><strong>字符串是 Redis 中最基本的数据类型，单个数据能存储的最大空间是 512M。</strong></p>
<h2 id="存放键值"><a href="#存放键值" class="headerlink" title="存放键值"></a>存放键值</h2><blockquote>
<p>语法：set key value [EX seconds] [PX milliseconds] [NX|XX]  </p>
</blockquote>
<p>nx：如果 key 不存在则建立，xx：如果 key 存在则修改其值，也可以直接使用 setnx/setex 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set javastack 666<br>OK<br></code></pre></td></tr></table></figure>
<h2 id="获取键值"><a href="#获取键值" class="headerlink" title="获取键值"></a>获取键值</h2><blockquote>
<p>语法：get key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379[2]&gt; get javastack<br>&quot;666&quot;<br></code></pre></td></tr></table></figure>
<h2 id="值递增-递减"><a href="#值递增-递减" class="headerlink" title="值递增 / 递减"></a>值递增 / 递减</h2><p>如果字符串中的值是数字类型的，可以使用 incr 命令每次递增，不是数字类型则报错。</p>
<blockquote>
<p>语法：incr key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379[2]&gt; incr javastack<br>(integer) 667<br></code></pre></td></tr></table></figure>
<p>一次想递增 N 用 incrby 命令，如果是浮点型数据可以用 incrbyfloat 命令递增。</p>
<p>同样，递减使用 decr、decrby 命令。</p>
<h2 id="批量存放键值"><a href="#批量存放键值" class="headerlink" title="批量存放键值"></a>批量存放键值</h2><blockquote>
<p>语法：mset key value [key value …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379[2]&gt; mset java1 1 java2 2 java3 3<br>OK<br></code></pre></td></tr></table></figure>
<h2 id="获取获取键值"><a href="#获取获取键值" class="headerlink" title="获取获取键值"></a>获取获取键值</h2><blockquote>
<p>语法：mget key [key …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379[2]&gt; mget java1 java2<br>1) &quot;1&quot;<br>2) &quot;2&quot;<br></code></pre></td></tr></table></figure>
<p>Redis 接收的是 UTF-8 的编码，如果是中文一个汉字将占 3 位返回。</p>
<h2 id="获取值长度"><a href="#获取值长度" class="headerlink" title="获取值长度"></a>获取值长度</h2><blockquote>
<p>语法：strlen key<br>127.0.0.1:6379[2]&gt; strlen javastack (integer) 3  </p>
</blockquote>
<h2 id="追加内容"><a href="#追加内容" class="headerlink" title="追加内容"></a>追加内容</h2><blockquote>
<p>语法：append key value  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379[2]&gt; append javastack hi<br>(integer) 5<br></code></pre></td></tr></table></figure>
<p>向键值尾部添加，如上命令执行后由 666 变成 666hi</p>
<h2 id="获取部分字符"><a href="#获取部分字符" class="headerlink" title="获取部分字符"></a>获取部分字符</h2><blockquote>
<p>语法：getrange key start end  </p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">&gt; 127.0.0.1<span class="hljs-selector-pseudo">:6379</span><span class="hljs-selector-attr">[2]</span>&gt; <span class="hljs-selector-tag">getrange</span> <span class="hljs-selector-tag">javastack</span> 0 4<br>&quot;<span class="hljs-selector-tag">javas</span>&quot;<br></code></pre></td></tr></table></figure>
<h1 id="集合操作命令"><a href="#集合操作命令" class="headerlink" title="集合操作命令"></a>集合操作命令</h1><p>集合类型和列表类型相似，只不过是集合是无序且不可重复的。</p>
<p>集合</p>
<h2 id="存储值"><a href="#存储值" class="headerlink" title="存储值"></a>存储值</h2><blockquote>
<p>语法：sadd key member [member …]  </p>
</blockquote>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">// 这里有<span class="hljs-number">8</span>个值（<span class="hljs-number">2</span>个java），只存了<span class="hljs-number">7</span>个<br><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd langs java php c++ go ruby python kotlin java<br>(integer) <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>
<h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><blockquote>
<p>获取所有元素语法：smembers key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; smembers langs<br>1) &quot;php&quot;<br>2) &quot;kotlin&quot;<br>3) &quot;c++&quot;<br>4) &quot;go&quot;<br>5) &quot;ruby&quot;<br>6) &quot;python&quot;<br>7) &quot;java&quot;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>随机获取语法：srandmember langs count  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; srandmember langs 3<br>1) &quot;c++&quot;<br>2) &quot;java&quot;<br>3) &quot;php&quot;<br></code></pre></td></tr></table></figure>
<h2 id="判断集合是否存在元素"><a href="#判断集合是否存在元素" class="headerlink" title="判断集合是否存在元素"></a>判断集合是否存在元素</h2><blockquote>
<p>语法：sismember key member  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; sismember langs go<br>(integer) 1<br></code></pre></td></tr></table></figure>
<h2 id="获取集合元素个数"><a href="#获取集合元素个数" class="headerlink" title="获取集合元素个数"></a>获取集合元素个数</h2><blockquote>
<p>语法：scard key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; scard langs<br>(integer) 7<br></code></pre></td></tr></table></figure>
<h2 id="删除集合元素"><a href="#删除集合元素" class="headerlink" title="删除集合元素"></a>删除集合元素</h2><blockquote>
<p>语法：srem key member [member …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; srem langs ruby kotlin<br>(integer) 2<br></code></pre></td></tr></table></figure>
<h2 id="弹出元素"><a href="#弹出元素" class="headerlink" title="弹出元素"></a>弹出元素</h2><blockquote>
<p>语法：spop key [count]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; spop langs 2<br>1) &quot;go&quot;<br>2) &quot;java&quot;<br></code></pre></td></tr></table></figure>
<h1 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h1><blockquote>
<p>和列表的区别：</p>
<p>1、列表使用链表实现，两头快，中间慢。有序集合是散列表和跳跃表实现的，即使读取中间的元素也比较快。</p>
<p>2、列表不能调整元素位置，有序集合能。</p>
<p>3、有序集合比列表更占内存。</p>
</blockquote>
<h2 id="存储值-1"><a href="#存储值-1" class="headerlink" title="存储值"></a>存储值</h2><blockquote>
<p>语法：zadd key [NX|XX] [CH] [INCR] score member [score member …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; zadd footCounts 16011 tid 20082 huny 2893 nosy<br>(integer) 3<br></code></pre></td></tr></table></figure>
<h2 id="获取元素分数"><a href="#获取元素分数" class="headerlink" title="获取元素分数"></a>获取元素分数</h2><blockquote>
<p>语法：zscore key member  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; zscore footCounts tid<br>&quot;16011&quot;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>获取排名范围排名语法：zrange key start stop [WITHSCORES]  </p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 获取所有，没有分数<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrange footCounts <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;nosy&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;tid&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;huny&quot;</span><br><br><span class="hljs-regexp">//</span> 获取所有及分数<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrange footCounts <span class="hljs-number">0</span> -<span class="hljs-number">1</span> Withscores<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;nosy&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;2893&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;tid&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;16011&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;huny&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;20082&quot;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>获取指定分数范围排名语法：zrangebyscore key min max [WITHSCORES] [LIMIT offset count]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; zrangebyscore footCounts 3000 30000 withscores limit 0 1<br>1) &quot;tid&quot;<br>2) &quot;16011&quot;<br></code></pre></td></tr></table></figure>
<h2 id="增加指定元素分数"><a href="#增加指定元素分数" class="headerlink" title="增加指定元素分数"></a>增加指定元素分数</h2><blockquote>
<p>语法：zincrby key increment member  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; zincrby footCounts 2000 tid<br>&quot;18011&quot;<br></code></pre></td></tr></table></figure>
<h2 id="获取集合元素个数-1"><a href="#获取集合元素个数-1" class="headerlink" title="获取集合元素个数"></a>获取集合元素个数</h2><blockquote>
<p>语法：zcard key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; zcard footCounts<br>(integer) 3<br></code></pre></td></tr></table></figure>
<h2 id="获取指定范围分数个数"><a href="#获取指定范围分数个数" class="headerlink" title="获取指定范围分数个数"></a>获取指定范围分数个数</h2><blockquote>
<p>语法：zcount key min max  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; zcount footCounts 2000 20000<br>(integer) 2<br></code></pre></td></tr></table></figure>
<h2 id="删除指定元素"><a href="#删除指定元素" class="headerlink" title="删除指定元素"></a>删除指定元素</h2><blockquote>
<p>语法：zrem key member [member …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; zrem footCounts huny<br>(integer) 1<br></code></pre></td></tr></table></figure>
<h2 id="获取元素排名"><a href="#获取元素排名" class="headerlink" title="获取元素排名"></a>获取元素排名</h2><blockquote>
<p>语法：zrank key member  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; zrank footCounts tid<br>(integer) 1<br></code></pre></td></tr></table></figure>
<h1 id="列表操作命令"><a href="#列表操作命令" class="headerlink" title="列表操作命令"></a>列表操作命令</h1><p>列表类型是一个有序的字段串列表，内部是使用双向链表实现，所有可以向两端操作元素，获取两端的数据速度快，通过索引到具体的行数比较慢。</p>
<p>列表类型的元素是有序且可以重复的。</p>
<h2 id="存储值-2"><a href="#存储值-2" class="headerlink" title="存储值"></a>存储值</h2><blockquote>
<p>左端存值语法：lpush key value [value …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; lpush list lily sandy<br>(integer) 2<br></code></pre></td></tr></table></figure>
<blockquote>
<p>右端存值语法：rpush key value [value …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; rpush list tom kitty<br>(integer) 4<br></code></pre></td></tr></table></figure>
<blockquote>
<p>索引存值语法：lset key index value  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; lset list 3 uto<br>OK<br></code></pre></td></tr></table></figure>
<h2 id="弹出元素-1"><a href="#弹出元素-1" class="headerlink" title="弹出元素"></a>弹出元素</h2><blockquote>
<p>左端弹出语法：lpop key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; lpop list<br>&quot;sandy&quot;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>右端弹出语法：rpop key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; rpop list<br>&quot;kitty&quot;<br></code></pre></td></tr></table></figure>
<h2 id="获取元素个数"><a href="#获取元素个数" class="headerlink" title="获取元素个数"></a>获取元素个数</h2><blockquote>
<p>语法：llen key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; llen list<br>(integer) 2<br></code></pre></td></tr></table></figure>
<h2 id="获取列表元素"><a href="#获取列表元素" class="headerlink" title="获取列表元素"></a>获取列表元素</h2><blockquote>
<p>两边获取语法：lrange key start stop  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; lpush users tom kitty land pony jack maddy<br>(integer) 6<br><br>127.0.0.1:6379&gt; lrange users 0 3<br>1) &quot;maddy&quot;<br>2) &quot;jack&quot;<br>3) &quot;pony&quot;<br>4) &quot;land&quot;<br><br>// 获取所有<br>127.0.0.1:6379&gt; lrange users 0 -1<br>1) &quot;maddy&quot;<br>2) &quot;jack&quot;<br>3) &quot;pony&quot;<br>4) &quot;land&quot;<br>5) &quot;kitty&quot;<br>6) &quot;tom&quot;<br><br>// 从右端索引<br>127.0.0.1:6379&gt; lrange users -3 -1<br>1) &quot;land&quot;<br>2) &quot;kitty&quot;<br>3) &quot;tom&quot;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>索引获取语法：lindex key index  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; lindex list 2<br>&quot;ketty&quot;<br><br>// 从右端获取<br>127.0.0.1:6379&gt; lindex list -5<br>&quot;sady&quot;<br></code></pre></td></tr></table></figure>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><blockquote>
<p>根据值删除语法：lrem key count value  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; lpush userids 111 222 111 222 222 333 222 222<br>(integer) 8<br><br>// count=0 删除所有<br>127.0.0.1:6379&gt; lrem userids 0 111<br>(integer) 2<br><br>// count &gt; 0 从左端删除前count个<br>127.0.0.1:6379&gt; lrem userids 3 222<br>(integer) 3<br><br>// count &lt; 0 从右端删除前count个<br>127.0.0.1:6379&gt; lrem userids -3 222<br>(integer) 2<br></code></pre></td></tr></table></figure>
<blockquote>
<p>范围删除语法：ltrim key start stop  </p>
</blockquote>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">// 只保留<span class="hljs-number">2</span>-<span class="hljs-number">4</span>之间的元素<br><span class="hljs-number">127.0.0.1:6379</span>&gt; ltrim list <span class="hljs-number">2</span> <span class="hljs-number">4</span><br>OK<br></code></pre></td></tr></table></figure>
<h1 id="散列操作命令"><a href="#散列操作命令" class="headerlink" title="散列操作命令"></a>散列操作命令</h1><p>redis 字符串类型键和值是字典结构形式，这里的散列类型其值也可以是字典结构。</p>
<h2 id="存放键值-1"><a href="#存放键值-1" class="headerlink" title="存放键值"></a>存放键值</h2><blockquote>
<p>单个语法：hset key field value  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; hset user name javastack<br>(integer) 1<br></code></pre></td></tr></table></figure>
<blockquote>
<p>多个语法：hmset key field value [field value …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; hmset user name javastack age 20 address china<br>OK<br></code></pre></td></tr></table></figure>
<blockquote>
<p>不存在时语法：hsetnx key field value  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; hsetnx user tall 180<br>(integer) 0<br></code></pre></td></tr></table></figure>
<h2 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a>获取字段值</h2><blockquote>
<p>单个语法：hget key field  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; hget user age<br>&quot;20&quot;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>多个语法：hmget key field [field …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; hmget user name age address<br>1) &quot;javastack&quot;<br>2) &quot;20&quot;<br>3) &quot;china&quot;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>获取所有键与值语法：hgetall key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; hgetall user<br>1) &quot;name&quot;<br>2) &quot;javastack&quot;<br>3) &quot;age&quot;<br>4) &quot;20&quot;<br>5) &quot;address&quot;<br>6) &quot;china&quot;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>获取所有字段语法：hkeys key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; hkeys user<br>1) &quot;name&quot;<br>2) &quot;address&quot;<br>3) &quot;tall&quot;<br>4) &quot;age&quot;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>获取所有值语法：hvals key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; hvals user<br>1) &quot;javastack&quot;<br>2) &quot;china&quot;<br>3) &quot;170&quot;<br>4) &quot;20&quot;<br></code></pre></td></tr></table></figure>
<h2 id="判断字段是否存在"><a href="#判断字段是否存在" class="headerlink" title="判断字段是否存在"></a>判断字段是否存在</h2><blockquote>
<p>语法：hexists key field  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; hexists user address<br>(integer) 1<br></code></pre></td></tr></table></figure>
<h2 id="获取字段数量"><a href="#获取字段数量" class="headerlink" title="获取字段数量"></a>获取字段数量</h2><blockquote>
<p>语法：hlen key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; hlen user<br>(integer) 4<br></code></pre></td></tr></table></figure>
<h2 id="递增-减"><a href="#递增-减" class="headerlink" title="递增 / 减"></a>递增 / 减</h2><blockquote>
<p>语法：hincrby key field increment  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; hincrby user tall -10<br>(integer) 170<br></code></pre></td></tr></table></figure>
<h2 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h2><blockquote>
<p>语法：hdel key field [field …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; hdel user age<br>(integer) 1<br></code></pre></td></tr></table></figure>
<p>都是基本的命令用法，不会用了就来翻一下吧！</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>配置免密登录linux</title>
    <url>/2021/02/01/%E9%85%8D%E7%BD%AE%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95linux/</url>
    <content><![CDATA[<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><p>切换到git环境下</p>
<p><strong>没有git环境的，自行百度安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 切换目录</span><br>cd ~/.ssh<br><br><span class="hljs-meta">#</span><span class="bash"> 新建config文件</span><br>vim config<br><br><span class="hljs-meta">#</span><span class="bash"> 输入以下内容</span><br>Host centos # 自定义, 用于后续的免密登录<br>HostName 192.168.117.29 # 服务器地址ip<br>User root # 登录的用户名<br>Port 22 # 端口<br>IdentityFile ~/.ssh/id_rsa # 私钥路径, id_rsa.pub是公钥<br><br><span class="hljs-meta">#</span><span class="bash"> 生成密钥对, 可以自行指定文件名, 默认为id_rsa和id_rsa.pub</span><br>ssh-keygen<br><br><span class="hljs-meta">#</span><span class="bash"> 发送id_rsa.pub文件至Linux服务器上</span><br>scp id_rsa.pub 用户名@ip:/home/<br><br><span class="hljs-meta">#</span><span class="bash"> 登录Linux服务器后, 进行操作</span><br>mv /home/id_rsa.pub ~/.ssh/authorized_keys<br><br><span class="hljs-meta">#</span><span class="bash"> 修改sshd_config配置, 确保以下几项配置前面没有<span class="hljs-comment">#字符</span></span><br>vim /etc/ssh/sshd_config<br><br>PubkeyAuthentication yes<br>AuthorizedKeysFile  .ssh/authorized_keys<br><br><span class="hljs-meta">#</span><span class="bash"> 重启ssh服务</span><br>systemctl restart sshd<br><br><span class="hljs-meta">#</span><span class="bash"> 返回Windows，打开cmd</span><br>ssh centos # 这里的centos, 对应config文件中Host配置的内容<br></code></pre></td></tr></table></figure>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>操作顺序一致，无需安装git环境，不过需要确保ssh和scp命令可执行</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
</search>
