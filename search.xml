<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IdeaVim插件使用技巧</title>
    <url>/2021/02/07/IdeaVim%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>在 IDEA Intellij小技巧和插件 一文中简单介绍了一下IdeaVim插件。在这里详细总结一下这个插件在日常编程中的一些常用小技巧。</p>
<p>供有兴趣使用这个插件，但对Vim还不十分熟悉的朋友参考。当然基本的hjkl移动光标和几种常见模式等等基本概念就略过不提了。</p>
<p>为了确保只包含常用操作，这里提到的技巧都没有从现成文档里抄，而是凭记忆列出（不常用自然就不记得了）。</p>
<p>估计会有所遗漏，慢慢再补充。</p>
<span id="more"></span>

<h1 id="1-切换Vim模拟器状态"><a href="#1-切换Vim模拟器状态" class="headerlink" title="1. 切换Vim模拟器状态"></a>1. 切换Vim模拟器状态</h1><p>这个插件允许设置一个快捷键一键开启或关闭，在切换模式时会同时自动切换keymap，十分方便。默认键位是Ctrl+Alt+V，但这个键位覆盖了很常用的“抽取局部变量”功能，建议重设，在setting-&gt;keymap中查找VIM Emulator即可。</p>
<p>由于开启和关闭状态分别使用两套keymap，因此两套都需要设定。可以把两套keymap下的都设为一样的键，也就是用同一个键切换。但个人建议设为不同的键，这样能清楚知道当前处于那种模式中。并且，如果在开启Vim的插入模式下关闭Vim模拟器，下次进入时仍然是插入模式，比较混乱（因为你关闭模拟器就是为了使用默认keymap输入大段代码，重新开启Vim模拟器就是为了使用普通模式下的命令）。</p>
<p>因此建议把Vim keymap中的Exit Insert Mode设为与另一个keymap的Vim Emulator相同的键（也就是进入Vim模拟器的快捷键）。</p>
<p>例如，我使用的设定是：</p>
<p>Default keymap -&gt; Vim Emulator : Ctrl+;     (用Ctrl+分号开启Vim模拟器）<br>Vim keymap -&gt; Vim Emulator : Ctrl+,    (用Ctrl+逗号关闭Vim模拟器）<br>Vim keymap -&gt; Vim Emulator : Ctrl+;    (用Ctrl+分号退出插入模式，进入普通模式）<br>这样，在任何时候只要连按两下ctrl+分号，就能保证必定在Vim模拟器的普通模式中。</p>
<h1 id="2-ScrollOff-参数"><a href="#2-ScrollOff-参数" class="headerlink" title="2. ScrollOff 参数"></a>2. ScrollOff 参数</h1><p>启动Intellij后在Vim模拟器下输入命令 :</p>
<p>set so=5<br>可以令屏幕滚动时在光标上下方保留5行预览代码（也就是光标会在第5行触发向上滚动，或者在倒数第5行触发向下滚动）。</p>
<p>在代码窗口比较狭小时（例如单步跟踪调试时）非常方便。可惜仅在Vim模拟器开启时有效。</p>
<h1 id="3-行号定位"><a href="#3-行号定位" class="headerlink" title="3. 行号定位"></a>3. 行号定位</h1><p>普通模式下输入 行号G 或 :行号&lt;回车&gt; 都能快速定位到某一行。</p>
<p>区别在于前者在输入行号时屏幕上没有任何提示，后者则在Vim命令输入框中可以看到输入过程。</p>
<p>（题外话：Sublime Text 2也是用 :行号 来快速定位到某行，应该是沿用了Vim的习惯）</p>
<h1 id="4-进入修改"><a href="#4-进入修改" class="headerlink" title="4. 进入修改"></a>4. 进入修改</h1><p>进入插入模式的方式有很多，直接选用合适的方式进入插入模式比进入后再用箭头键移动光标要好。常用的有：</p>
<p>o - 在当前行下方插入新行并自动缩进<br>O - 在当前行上方插入新行并自动缩进 （普通模式下的大写字母命令用 shift+字母键 输入，下同）<br>i - 在当前字符左方开始插入字符<br>a - 在当前字符右方开始插入字符<br>I - 光标移动到行首并进入插入模式<br>A - 光标移动到行尾并进入插入模式<br>s - 删除光标所在字符并进入插入模式<br>S - 删除光标所在行并进入插入模式<br>c&lt;范围&gt; - 删除光标所在位置周围某个范围的文本并进入插入模式。关于范围请看第5点，常用的组合有：caw - 删除一个单词包括它后面的空格并开始插入；ciw - 删除一个单词并开始插入；ci” - 删除一个字符串内部文本并开始插入；c$ - 从光标位置删除到行尾并开始插入；ct字符 - 从光标位置删除本行某个字符之前（保留该字符）并开始插入。等等。<br>C - 删除光标位置到行尾的内容并进入插入模式 (相当于c$)<br>r - 修改光标所在字符，然后返回普通模式<br>R - 进入覆盖模式</p>
<h1 id="5-范围操作"><a href="#5-范围操作" class="headerlink" title="5. 范围操作"></a>5. 范围操作</h1><p>某些普通模式的动作命令后面可以追加一些表示范围的指令，表示该动作将作用在整个范围上。这类命令常用的有：</p>
<p>d&lt;范围&gt; - 删除一定范围内的文本<br>c&lt;范围&gt; - 删除一定范围内的文本并进入插入模式<br>y&lt;范围&gt; - 将范围内的文本放入0号和”号注册栏<br>v&lt;范围&gt; - 选择范围内的文本<br>=&lt;范围&gt; - 自动缩进范围内的文本<br>gU&lt;范围&gt; - 将范围内的字符转换为大写<br>gu&lt;范围&gt; - 将范围内的字符转换为小写</p>
<blockquote>
<p>&lt;范围&gt; - 将范围中的内容缩进一格<br>&lt;&lt;范围&gt; - 将范围中的内容取消缩进一格<br>常用的范围指令有：</p>
</blockquote>
<p>空格 - 光标所在位置字符。（例如 gU空格 - 将光标位置字符转为大写）<br>重复某些动作命令 - 光标所在行。 （例如dd删除一行，yy复制一行，cc删除一行文本并开始插入，&gt;&gt; 当前行缩进一格，==自动缩进当前行）<br>$ - 从光标位置到行尾<br>^ - 从光标位置到行首，不包含缩进空白<br>0 - 从光标位置到行首，包含缩进空白<br>gg - 从光标位置到文件开头<br>G - 从光标位置到文件结尾<br>% - 从光标位置到另一边匹配的括号<br>f&lt;字符&gt; - 从光标位置到光标右边某个字符首次出现的位置，包括该字符<br>F&lt;字符&gt; - 从光标位置到光标左边某个字符首次出现的位置，包括该字符<br>t&lt;字符&gt; - 从光标位置到光标右边某个字符首次出现的位置，包括该字符<br>F&lt;字符&gt; - 从光标位置到光标左边某个字符首次出现的位置，包括该字符<br>/正则表达式 - 从光标位置到下一个匹配正则表达式的位置（跨行）<br>?正则表达式 - 从光标位置到上一个匹配正则表达式的位置（跨行）<br>aw - 一个单词加一个空格 （a可理解为“一个”，下同）<br>iw - 一个单词 （i可理解为in，下同）<br>a” - 一个字符串包括双引号<br>i” - 一个字符串内部文本<br>a&lt; - 一组&lt; &gt;包含的文本，包括&lt; &gt;号本身<br>同理类推：i&lt;, a[, i[, a(, i(<br>注意：真正vim中的it范围（一对xml标签内部）在ideaVim中不生效。<br>用/或?命令查找时，正则表达式默认大小写敏感，如果需要不敏感，可以在正则表达式开始处加上\c标志。</p>
<p>例如 /\cabc 可以匹配到 ABC。下面提到的:s命令同样适用。</p>
<h1 id="6-选择文本"><a href="#6-选择文本" class="headerlink" title="6. 选择文本"></a>6. 选择文本</h1><p>在Vim中，选择文本需要进入“可视模式”（Visual Mode），这个名称比较奇怪，它的来由据说是因为在Vim的前身Vi中，选择区域是不可见的。</p>
<p>在Vim中选择区域会高亮显示，因此称为“可视模式”。</p>
<p>v - 进入字符选择模式， V - 进入行选择模式， Ctrl+v - 进入块选择模式。<br>进入相应模式后移动光标即可选中文本。过程中可按o键令光标在选区两端切换。</p>
<p>在块选择模式中选中多行，然后按I或A后输入文本，再退出插入模式，所输入的文本将自动加入到每一行的开头或结尾。</p>
<h1 id="7-复制粘贴"><a href="#7-复制粘贴" class="headerlink" title="7. 复制粘贴"></a>7. 复制粘贴</h1><p>在Vim模式下，复制粘贴并不直接使用系统的剪贴板，而是使用Vim提供的多个“寄存器”，每个寄存器都以一个字符来表示。</p>
<p>关于寄存器的详细说明可以看这里 <a href="http://blah.blogsome.com/2006/04/27/vim_tut_register/">http://blah.blogsome.com/2006/04/27/vim_tut_register/</a> （随便google的一个网页），这里简单列一些常用的操作技巧</p>
<p>（注意，vim使用双引号”来作为选择寄存器的命令，因此下文中的双引号均指在普通模式下按双引号键）：</p>
<p>a）用y命令将文本存入寄存器后，如果想在别处替换原有内容，可以先用v命令选中原有内容，然后用p命令粘贴。</p>
<p>但第一次粘贴后，默认的寄存器”将被替换为刚刚删除的内容。如果要再次粘贴之前复制的内容，需要使用 “0p 命令组合来复制。</p>
<p>也可以进入插入模式后用 Ctrl+r 0 来复制，例如 ciw&lt;Ctrl+r&gt;0 命令组合将用粘贴内容替换光标处的一个单词，并停留在插入模式。</p>
<p>b）在Windows下，寄存器 + 和 * 都代表系统剪贴板，可以互换使用，选一个顺手的即可。</p>
<p>例如 “+yy 命令组合可将当前行复制到系统剪贴板。ci”&lt;Ctrl+r&gt;* 命令组合则将系统剪贴板的内容替换字符串的内部文本。</p>
<p>c) 寄存器1至9记录之前九次的删除大段文本，每次超过一行的删除操作都会导致这9个寄存器的内容发生位移，最近删除的文本会存入寄存器1。</p>
<p>但只有删除超过1行时才会影响寄存器1至9，行内的删除内容则会被存入寄存器-（减号）。</p>
<p>如果用q命令录制宏时不涉及跨行删除，可以在宏中直接使用这9个寄存器来暂存文本。</p>
<p>（在Vim中，复制内容与录制宏共享同一套寄存器，因此我习惯把字母寄存器留给宏使用）</p>
<p>d) 普通模式下小写p把寄存器内容复制到当前位置之后，大写P把寄存器内容复制到当前位置之前。</p>
<p>e) 使用 :regs 命令可以列出当前所有寄存器的内容</p>
<p>8.一些插入模式下的常用快捷键<br>Ctrl+h - 删除光标左边字符<br>Ctrl+w - 删除光标左边的单词<br>Ctrl+y - 复制上方的一个字符<br>Ctrl+e - 复制下方的一个字符<br>Ctrl+r 0 - 插入前一次用y命令寄存的内容<br>Ctrl+r * - 插入系统剪贴板的内容<br>Ctrl+r &lt;寄存器名称&gt; - 插入指定寄存器的内容<br>Ctrl+a - 插入前一次插入模式所键入的内容<br>Ctrl+o - 执行一个普通模式下的命令然后返回插入模式。 例如 Ctrl+o A 相当于按 End键， Ctrl+o I相当于按Home键</p>
<h1 id="9-退出插入模式"><a href="#9-退出插入模式" class="headerlink" title="9. 退出插入模式"></a>9. 退出插入模式</h1><p>退出插入模式可以用 ESC 键，但键位太远。其实也可以用 Ctrl+[ 键退出插入模式 。</p>
<p>当然也可以用第1点自定义的Ctrl+;快捷键，但这不是标准vim按键，会养成不良习惯，不建议使用。</p>
<h1 id="10-重复操作"><a href="#10-重复操作" class="headerlink" title="10. 重复操作"></a>10. 重复操作</h1><p>普通模式下按. （小数点）可重复上一次的修改操作</p>
<p>&amp; - 重复上一次的:s替换命令<br>@@ - 重复上一次执行的宏</p>
<h1 id="11-跳转"><a href="#11-跳转" class="headerlink" title="11. 跳转"></a>11. 跳转</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Ctrl+] 跳转到当前标识符的定义位置 （相当于在当前光标位置的单词上按住ctrl用鼠标点击）</span><br><span class="line">Ctrl+o 回退一步 (go back)</span><br><span class="line">Ctrl+i 前进一步 (go forward)</span><br><span class="line">\`. 跳转到之前修改位置</span><br><span class="line">\<span class="code">`\`</span> 在前一次跳转位置与当前位置间切换</span><br><span class="line">行号G 或 :行号&lt;回车&gt;  跳转到某一行</span><br><span class="line">gg 跳转到文件开头</span><br><span class="line">G  跳转到文件末尾</span><br><span class="line">H  跳转到屏幕顶端（如果设置了set so=n，则跳转到第n行）</span><br><span class="line">L  跳转到屏幕底端（如果设置了set so=n，则跳转到倒数第n行）</span><br><span class="line">M  跳转到屏幕中间</span><br><span class="line">f 或 F 跳转到本行某个字符，小写f向右查找，大写F向左查找。用;或,在匹配间切换</span><br><span class="line">t 或 T 跳转到本行某个字符之前，小写t向右查找，大写T向左查找。用;或,在匹配间切换</span><br><span class="line">/正则表达式  跳转到下一个匹配。用n或N在匹配间切换。</span><br><span class="line">?正则表达式  跳转到上一个匹配。用n或N在匹配间切换。</span><br></pre></td></tr></table></figure>
<p>（结合前面第5点，你也许注意到了，在指定范围时，使用跳转命令将指定一个从光标位置到跳转目标的区域）</p>
<h1 id="12-书签"><a href="#12-书签" class="headerlink" title="12. 书签"></a>12. 书签</h1><p>在普通模式下按 m&lt;小写字母&gt; 即可定义书签，按 &lt;字母&gt; 则可跳转到某个书签的精确位置，按 &lt;字母&gt;可跳转到某个书签所在行的行首（用来录制宏时比较有用）。</p>
<p>最常用的自然是mm, mn, mj, mk, ml这几个顺手的键位。</p>
<p>真正的vim中的全局书签 m&lt;大写字母&gt; 在目前IdeaVim版本中不生效。需要定义全局书签可以使用Idea原本的 F11 + 数字 方式</p>
<h1 id="13-文本替换"><a href="#13-文本替换" class="headerlink" title="13. 文本替换"></a>13. 文本替换</h1><p>使用 :s/正则表达式/替换文本/ 可在本行内替换首次出现的匹配</p>
<p>使用 :s/正则表达式/替换文本/g 在本行内替换所有出现的匹配</p>
<p>使用 :%s/正则表达式/替换文本/g 在当前文件内替换所有出现的匹配</p>
<p>在可视模式下选中文本后，使用:’&lt;,’&gt;s/正则表达式/替换文本/g 命令可在选中区域中替换文本。</p>
<p>其中’&lt;,’&gt;部分在可视模式下，按:冒号后自动加入，直接输入s命令即可。但有效区域只能以行为单位。</p>
<p>真正Vim中的 %V 标志在IdeaVim中不生效。</p>
<h1 id="14-宏定义"><a href="#14-宏定义" class="headerlink" title="14. 宏定义"></a>14. 宏定义</h1><p>在IdeaVim中定义宏比Idea自带的宏功能要轻量许多。</p>
<p>按在普通模式下 q&lt;寄存器名称&gt; 即可开始把后续按键序列录制到指定寄存器中（寄存器参考前面第7条）。录制完毕进入普通模式再按q键即可停止录制。</p>
<p>之后用 @&lt;寄存器名称&gt; 即可重放。需要注意的是宏和复制粘贴共用一套寄存器，因此在录制宏时就注意不要把当前宏正在使用的寄存器用来复制了。</p>
<p>寄存器内容是自动保存的，重启Idea仍然生效。但IdeaVim没有导出宏独立保存的功能。因此最好把用来保存宏的寄存器和用来复制粘贴的寄存器分开，不要同一个寄存器有时用来记录宏，有时用来复制粘贴。我的习惯是键盘左手区用来保存一些长期使用的宏（比如说我有一个宏专门用来把pom.xml中的版本号抽取到property区域，原来的位置则改用${property}引用）。</p>
<p>右手区的hjklnm键用来保存一些临时宏。yuiop五个寄存器保留用来复制粘贴。如果录制的宏不涉及删除大段代码，寄存器1至9也可以用来进行复制粘贴。</p>
<p>执行一次宏后，可以用@@命令重复上一次执行的宏。</p>
<p>在Idea中录制宏时，如果触发了代码自动完成，在自动完成列表启动的状态输入的字符不会被记录。因此最好在Setting -&gt; Code Completion -&gt; Autopopup code completion中把延迟设为500ms以上或干脆关掉。在录制宏的过程中避免触发代码自动完成功能。</p>
<p>录制一些长期有效的宏时，开始录制后，最好先用0，^，T, F, $等命令把光标对齐到行首行末或某个特定起始位置（比如说用 F” 跳转到字符串的左边引号），再用一个f或/指令跳转到操作位置，这样的宏就不用必须把光标放在某个特定字符才能使用了。</p>
<h1 id="15-一些常用组合技"><a href="#15-一些常用组合技" class="headerlink" title="15. 一些常用组合技"></a>15. 一些常用组合技</h1><p>全选：ggvG<br>调换两个字符位置：xp<br>复制一行：yyp<br>调换两行位置：ddp<br>插入模式下到行尾继续输入（相当于End键）：Ctrl+o A 或 Ctrl+[ A<br>插入模式下到行首继续输入（相当于Home键）：Ctrl+o I 或 Ctrl+[ I<br>到类定义位置（适用于正确缩进的public，protected类） ：?^p回车</p>
<h1 id="16-一些在目前版本已知没有实现的一些常用Vim功能"><a href="#16-一些在目前版本已知没有实现的一些常用Vim功能" class="headerlink" title="16. 一些在目前版本已知没有实现的一些常用Vim功能"></a>16. 一些在目前版本已知没有实现的一些常用Vim功能</h1><p>（如果对Vim不熟悉可以跳过这节）</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">a）let命令 （没有let命令就无法导出/导入寄存器内容，也就是无法导入宏）</span><br><span class="line">b）:g命令 （在文本处理中很有用的一个命令，在编程中倒是不那么常用）</span><br><span class="line">c）!命令 （执行shell命令）</span><br><span class="line">d）大部分正则表达式标记 （例如 \%V， \v 等等）</span><br><span class="line">e) 某些多键命令双击最后一个字符表示作用于当前行。例如在Vim中gUU可以把当前行转换为大写，在IdeaVim中无效，实现同样功能可以先用V命令选中当前行，再用gU转换为大写。</span><br><span class="line">f）关于窗口操作的大部分命令 （Ctrl+w系列命令, :split等）</span><br><span class="line">g）所有Vim脚本插件 （不过大部分可以用Idea自身的功能和插件来补偿）</span><br><span class="line">zo - 打开折叠</span><br><span class="line">zc - 关闭折叠</span><br></pre></td></tr></table></figure>

<p>嗯，差点忘了，在普通模式下按u撤销上一个修改（相当于其他IDE的Ctrl+z），按Ctrl+r重做被撤销的修改。</p>
<blockquote>
<p>转载于：<a href="https://www.iteye.com/blog/kidneyball-1828427">https://www.iteye.com/blog/kidneyball-1828427</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Vim</tag>
        <tag>Idea</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对Zip格式压缩和解压缩</title>
    <url>/2021/03/01/Java%E5%AF%B9Zip%E6%A0%BC%E5%BC%8F%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h1 id="ZIP-和-GZIP-的区别"><a href="#ZIP-和-GZIP-的区别" class="headerlink" title="ZIP 和 GZIP 的区别"></a>ZIP 和 GZIP 的区别</h1><p><strong>gzip 是一种文件压缩工具（或该压缩工具产生的压缩文件格式），它的设计目标是处理单个的文件。gzip 在压缩文件中的数据时使用的就是 zlib。为了保存与文件属性有关的信息，gzip 需要在压缩文件（*.gz）中保存更多的头信息内容，而 zlib 不用考虑这一点。但 gzip 只适用于单个文件，所以我们在 UNIX/Linux 上经常看到的压缩包后缀都是 *.tar.gz 或 *.tgz，也就是先用 tar 把多个文件打包成单个文件，再用 gzip 压缩的结果。</strong></p>
<p><strong>zip 只是一种数据结构，跟 rar 同类型。zip 是适用于压缩多个文件的格式（相应的工具有 PkZip 和 WinZip 等），因此，zip 文件还要进一步包含文件目录结构的信息，比 gzip 的头信息更多。但需要注意，zip 格式可采用多种压缩算法，我们常见的 zip 文件大多不是用 zlib 的算法压缩的，其压缩数据的格式与 gzip 大不一样。</strong></p>
<span id="more"></span>

<h1 id="相关类与接口"><a href="#相关类与接口" class="headerlink" title="相关类与接口"></a>相关类与接口</h1><p><strong>Checksum</strong>：表示数据校验和的接口, 被类 Adler32 和 CRC32 实现<br><strong>Adler32</strong> ：使用 Alder32 算法来计算 Checksum 数目<br><strong>CRC32</strong>：使用 CRC32 算法来计算 Checksum 数目</p>
<p><strong>CheckedInputStream</strong>：InputStream 派生类，可得到输入流的校验和 Checksum, 用于校验数据的完整性<br><strong>CheckedOutputStream</strong> ：OutputStream 派生类，可得到输出流的校验 Checksum， 用于校验数据的完整性</p>
<p><strong>DeflaterOutputStream</strong> ：压缩类的基类<br><strong>ZipOutputStream</strong>：DeflaterOutputStream 的一个子类，把数据压缩成 Zip 文件格式<br><strong>GZIPOutputStream</strong> ：DeflaterOutputStream 的一个子类，把数据压缩成 GZip 文件格式</p>
<p>I<strong>nflaterInputStream</strong>：解压缩类的基类<br><strong>ZipInputStream</strong>：InflaterInputStream 的一个子类，能解压缩 Zip 格式的数据<br><strong>GZIPInputStream</strong>：InflaterInputStream 的一个子类，能解压缩 Zip 格式的数据</p>
<p><strong>ZipEntry</strong>：表示 ZIP 文件条目<br><strong>ZipFile</strong>：此类用于从 ZIP 文件读取条目</p>
<h1 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h1><p>下面实例我们使用了 apache 的 zip 工具包（所在包为 ant.jar ），因为 java 类型自带的不支持中文路径，不过两者使用的方式是一样的，只是 apache 压缩工具多了设置编码方式的接口，其他基本上是一样的。另外，如果使用 org.apache.tools.zip.ZipOutputStream 来压缩的话，我们只能使用 org.apache.tools.zip.ZipEntry 来解压，而不能使用 java.util.zip.ZipInputStream 来解压读取了，当然 apache 并未提供 ZipInputStream 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 压缩</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">(String srcFilePath, String destFilePath)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    File src = <span class="keyword">new</span> File(srcFilePath);</span><br><span class="line">    <span class="keyword">if</span> (!src.exists()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(srcFilePath + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File zipFile = <span class="keyword">new</span> File(destFilePath);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(zipFile);</span><br><span class="line">        CheckedOutputStream cos = <span class="keyword">new</span> CheckedOutputStream(fos, <span class="keyword">new</span> CRC32());</span><br><span class="line">        ZipOutputStream zos = <span class="keyword">new</span> ZipOutputStream(cos);</span><br><span class="line">        String baseDir = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        compressbyType(src, zos, baseDir);</span><br><span class="line">        zos.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据文件类型压缩</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compressbyType</span><span class="params">(File src, ZipOutputStream zos, String baseDir)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!src.exists())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;压缩&quot;</span> + baseDir + src.getName());</span><br><span class="line">    <span class="keyword">if</span> (src.isFile()) &#123;</span><br><span class="line">        compressFile(src, zos, baseDir);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (src.isDirectory()) &#123;</span><br><span class="line">        compressDir(src, zos, baseDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 压缩文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compressFile</span><span class="params">(File file, ZipOutputStream zos, String baseDir)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file.exists())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        ZipEntry entry = <span class="keyword">new</span> ZipEntry(baseDir + file.getName());</span><br><span class="line">        zos.putNextEntry(entry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFSIZE];</span><br><span class="line">        <span class="keyword">while</span> ((count = bis.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            zos.write(buf, <span class="number">0</span>, count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bis.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 压缩文件夹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compressDir</span><span class="params">(File dir, ZipOutputStream zos, String baseDir)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dir.exists())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    File[] files = dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span>(files.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zos.putNextEntry(<span class="keyword">new</span> ZipEntry(baseDir + dir.getName() + File.separator));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        compressbyType(file, zos, baseDir + dir.getName() + File.separator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结步骤：</p>
<ol>
<li><p>创建压缩到的文件 File zipFile = <strong>new</strong> File(destFilePath);</p>
</li>
<li><p>根据 zipFile 生成 ZipOutputStream 用于写入即将被压缩的文件</p>
<p> <strong>FileOutputStream fos = new FileOutputStream(zipFile);</strong></p>
<p> <strong>CheckedOutputStream cos = new CheckedOutputStream(fos, new CRC32());</strong></p>
<p> <strong>ZipOutputStream zos = new ZipOutputStream(cos);</strong></p>
</li>
<li><p>循环遍历源文件，首先需要创建 ZipEntry 用于标记压缩文件中含有的条目</p>
<p> <strong>ZipEntry entry = new ZipEntry(baseDir + file.getName());</strong></p>
<p> 然后将条目增加到 ZipOutputStream 中，<strong>zos.putNextEntry(entry);</strong></p>
<p> 最后再调用要写入条目对应文件的输入流读取文件内容写入到压缩文件中。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">ZipEntry entry = <span class="keyword">new</span> ZipEntry(baseDir + file.getName());</span><br><span class="line">zos.putNextEntry(entry);</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[_BUFSIZE_];</span><br><span class="line"><span class="keyword">while</span> ((count = bis.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    zos.write(buf, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>注意：</strong>如果是空目录<strong>直接</strong> <strong>zos.putNextEntry(new ZipEntry(baseDir +     dir.getName()+ File.<em>separator</em>))</strong> 并不用写入文件内容，<strong>其中最主要的涉及到目录的压缩的，就是这一句话  out.putNextEntry(new ZipEntry(base + “/“)); // 放入一级目录 (防止空目录被丢弃)</strong></p>
</li>
</ol>
<h1 id="解压-zip-文件"><a href="#解压-zip-文件" class="headerlink" title="解压 zip 文件"></a>解压 zip 文件</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解压缩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcPath 	压缩文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest		解压路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decompress</span><span class="params">(String srcPath, String dest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    File file = <span class="keyword">new</span> File(srcPath);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(srcPath + <span class="string">&quot; 所指文件不存在 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ZipFile zf = <span class="keyword">new</span> ZipFile(file);</span><br><span class="line">    Enumeration entries = zf.getEntries();</span><br><span class="line">    ZipEntry entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">        entry = (ZipEntry) entries.nextElement();</span><br><span class="line">        System._out_.println(<span class="string">&quot; 解压 &quot;</span> + entry.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line"></span><br><span class="line">            String dirPath = dest + File._separator_ + entry.getName();</span><br><span class="line">            File dir = <span class="keyword">new</span> File(dirPath);</span><br><span class="line">            dir.mkdirs();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 表示文件</span></span><br><span class="line">            File f = <span class="keyword">new</span> File(dest + File._separator_ + entry.getName());</span><br><span class="line">            <span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">                String dirs = FileUtils._getParentPath_(f);</span><br><span class="line">                File parentDir = <span class="keyword">new</span> File(dirs);</span><br><span class="line">                parentDir.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            f.createNewFile();</span><br><span class="line">            <span class="comment">// 将压缩文件内容写入到这个文件中</span></span><br><span class="line">            InputStream is = zf.getInputStream(entry);</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">            <span class="keyword">int</span> count;</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">            <span class="keyword">while</span> ((count = is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(buf, <span class="number">0</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">            is.close();</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>原文地址 <a href="https://www.cnblogs.com/ljdblog/p/5844184.html">https://www.cnblogs.com/ljdblog/p/5844184.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>zip</tag>
        <tag>java</tag>
        <tag>压缩</tag>
        <tag>解压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim常用配置</title>
    <url>/2021/02/03/Vim%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot; 基本配置 &quot;</span></span><br><span class="line"><span class="keyword">set</span> nocompatible <span class="comment">&quot; 不与 Vi 兼容（采用 Vim 自己的操作命令）。</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span> <span class="comment">&quot; 打开语法高亮。自动识别代码，使用多种颜色显示。</span></span><br><span class="line"><span class="keyword">set</span> showmode <span class="comment">&quot; 在底部显示，当前处于命令模式还是插入模式。</span></span><br><span class="line"><span class="keyword">set</span> showcmd <span class="comment">&quot; 命令模式下，在底部显示，当前键入的指令。比如，键入的指令是2y3d，那么底部就会显示2y3，当键入d的时候，操作完成，显示消失。</span></span><br><span class="line"><span class="keyword">set</span> t_Co = <span class="number">256</span> <span class="comment">&quot; 启动256色</span></span><br><span class="line"><span class="comment">&quot; 设置编码</span></span><br><span class="line"><span class="keyword">set</span> fileencodings=utf-<span class="number">8</span>,ucs-bom,gb18030,gbk,gb2312,cp936</span><br><span class="line"><span class="keyword">set</span> termencoding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">set</span> encoding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">set</span> langmenu=zh_CN.UTF-<span class="number">8</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">version</span> &gt;= <span class="number">603</span></span><br><span class="line">    <span class="keyword">set</span> helplang=<span class="keyword">cn</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment">&quot; 启用鼠标</span></span><br><span class="line"><span class="keyword">set</span> mouse = <span class="keyword">a</span></span><br><span class="line"><span class="keyword">set</span> selection = exclusive</span><br><span class="line"><span class="keyword">set</span> selectmode = mouse, key</span><br><span class="line"><span class="comment">&quot; 打开文件类型检测</span></span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="keyword">on</span></span><br><span class="line"><span class="keyword">filetype</span> <span class="built_in">indent</span> <span class="keyword">on</span> <span class="comment">&quot; 开启文件类型检查，并且载入与该类型对应的缩进规则。比如，如果编辑的是.py文件，Vim 就是会找 Python 的缩进规则~/.vim/indent/python.vim</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 搜索相关 &quot;</span></span><br><span class="line"><span class="keyword">set</span> showmatch <span class="comment">&quot; 光标遇到圆括号、方括号、大括号时，自动高亮对应的另一个圆括号、方括号和大括号</span></span><br><span class="line"><span class="keyword">set</span> hlsearch <span class="comment">&quot; 高亮搜索匹配结果</span></span><br><span class="line"><span class="keyword">set</span> ignorecase <span class="comment">&quot; 搜索时忽略大小写</span></span><br><span class="line"><span class="keyword">set</span> incsearch <span class="comment">&quot; 搜索模式下，每输入一个字符，就自动跳至第一个匹配结果</span></span><br><span class="line"><span class="keyword">set</span> smartcase <span class="comment">&quot; 同时打开了ignorecase, 仅对只有一个大写字母的单词敏感</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 编辑相关 &quot;</span></span><br><span class="line"><span class="keyword">set</span> spell spelllang=en_us <span class="comment">&quot; 英语单词 拼写检查</span></span><br><span class="line"><span class="keyword">set</span> nobackup <span class="comment">&quot; 不创建备份文件, 默认情况下，文件保存时，会额外创建一个备份文件，它的文件名是在原文件名的末尾，再添加一个波浪号（〜）</span></span><br><span class="line"><span class="keyword">set</span> noswapfile <span class="comment">&quot; 不创建交换文件, 交换文件主要用于系统崩溃时恢复文件，文件名的开头是.、结尾是.swp</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">undofile</span> <span class="comment">&quot; 保留撤销历史, Vim 会在编辑时保存操作历史，用来供用户撤消更改。默认情况下，操作记录只在本次编辑时有效，一旦编辑结束、文件关闭，操作历史就消失了。打开这个设置，可以在文件关闭后，操作记录保留在一个文件里面，继续存在。这意味着，重新打开一个文件，可以撤销上一次编辑时的操作。撤消文件是跟原文件保存在一起的隐藏文件，文件名以.un~开头。</span></span><br><span class="line"><span class="keyword">set</span> paste <span class="comment">&quot; 粘贴模式</span></span><br><span class="line"><span class="keyword">set</span> autochdir <span class="comment">&quot; 自动切换工作目录。这主要用在一个 Vim 会话之中打开多个文件的情况，默认的工作目录是打开的第一个文件的目录。该配置可以将工作目录自动切换到，正在编辑的文件的目录。</span></span><br><span class="line"><span class="keyword">set</span> visualbell <span class="comment">&quot; 出错时，发出视觉提示，通常是屏幕闪烁。</span></span><br><span class="line"><span class="keyword">set</span> noerrorbells <span class="comment">&quot; 出错时，不要发出响声。</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">history</span> = <span class="number">1000</span> <span class="comment">&quot; Vim 需要记住多少次历史操作。</span></span><br><span class="line"><span class="keyword">set</span> listchars=<span class="keyword">ta</span><span class="variable">b:</span>»■,trai<span class="variable">l:</span>■ <span class="comment">&quot; 如果行尾有多余的空格（包括 Tab 键），该配置将让这些空格显示成可见的小方块。</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">list</span></span><br><span class="line"><span class="keyword">set</span> wildmenu <span class="comment">&quot; 命令模式下，底部操作指令按下 Tab 键自动补全。第一次按下 Tab，会显示所有匹配的操作指令的清单；第二次按下 Tab，会依次选择各个指令。</span></span><br><span class="line"><span class="keyword">set</span> wildmode=longes<span class="variable">t:list</span>,full</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 外观相关 &quot;</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span> <span class="comment">&quot; 显示行号</span></span><br><span class="line"><span class="keyword">set</span> relativenumber <span class="comment">&quot; 显示光标所在的当前行的行号，其他行都为相对于该行的相对行号</span></span><br><span class="line"><span class="keyword">set</span> guifont = Courier_Ne<span class="variable">w:h10</span>:cANSI <span class="comment">&quot; 字体</span></span><br><span class="line"><span class="keyword">set</span> cursorline <span class="comment">&quot; 光标所在的当前行高亮</span></span><br><span class="line"><span class="keyword">set</span> cursorcolumn <span class="comment">&quot; 突显当前列</span></span><br><span class="line"><span class="keyword">set</span> textwidth = <span class="number">80</span></span><br><span class="line"><span class="keyword">set</span> wrap <span class="comment">&quot; 自动折行，即太长的行分成几行显示, nowrap</span></span><br><span class="line"><span class="keyword">set</span> linebreak <span class="comment">&quot; 只有遇到指定的符号（比如空格、连词号和其他标点符号），才发生折行。也就是说，不会在单词内部折行</span></span><br><span class="line"><span class="keyword">set</span> wrapmargin = <span class="number">2</span> <span class="comment">&quot; 指定折行处与编辑窗口的右边缘之间空出的字符数</span></span><br><span class="line"><span class="keyword">set</span> scrolloff = <span class="number">5</span> <span class="comment">&quot; 垂直滚动时，光标距离顶部/底部的位置（单位：行）</span></span><br><span class="line"><span class="string">&quot; set sidescrolloff = 15 &quot;</span> 水平滚动时，光标距离行首或行尾的位置（单位：字符）。该配置在不折行时比较有用</span><br><span class="line"><span class="keyword">set</span> laststatus = <span class="number">2</span> <span class="comment">&quot; 是否显示状态栏。0 表示不显示，1 表示只在多窗口时显示，2 表示显示</span></span><br><span class="line"><span class="keyword">set</span> ruler <span class="comment">&quot; 在状态栏显示光标的当前位置（位于哪一行哪一列）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 缩进相关 &quot;</span></span><br><span class="line"><span class="keyword">set</span> autoindent <span class="comment">&quot; 按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致。</span></span><br><span class="line"><span class="keyword">set</span> tabstop = <span class="number">4</span> <span class="comment">&quot; Tab长度</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span> = <span class="number">4</span> <span class="comment">&quot; 自动缩进长度</span></span><br><span class="line"><span class="keyword">set</span> expandtab <span class="comment">&quot; 由于 Tab 键在不同的编辑器缩进不一致，该设置自动将 Tab 转为空格。</span></span><br><span class="line"><span class="keyword">set</span> softtabstop = <span class="number">4</span> <span class="comment">&quot; Tab 转为多少个空格</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;让vimrc配置变更立即生效&quot;</span></span><br><span class="line"><span class="keyword">autocmd</span> BufWritePost $MYVIMRC <span class="keyword">source</span> $MYVIMRC</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Vim</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10常用快捷键</title>
    <url>/2021/02/05/Windows10%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="窗口相关"><a href="#窗口相关" class="headerlink" title="窗口相关"></a>窗口相关</h1><h1 id="虚拟桌面"><a href="#虚拟桌面" class="headerlink" title="虚拟桌面"></a>虚拟桌面</h1><p><code>Ctrl + Win + d</code>    新建桌面<br><code>Ctrl + Win + ←/→</code>  左右切换桌面</p>
]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows卸载自带Flash</title>
    <url>/2021/02/02/Windows%E5%8D%B8%E8%BD%BD%E8%87%AA%E5%B8%A6Flash/</url>
    <content><![CDATA[<p>参考该链接完成操作<br><a href="https://helpx.adobe.com/flash-player/kb/uninstall-flash-player-windows.html#main_Download_the_Adobe_Flash_Player_uninstaller">https://helpx.adobe.com/flash-player/kb/uninstall-flash-player-windows.html#main_Download_the_Adobe_Flash_Player_uninstaller</a></p>
]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>Flash</tag>
      </tags>
  </entry>
  <entry>
    <title>redis常用命令</title>
    <url>/2021/02/26/redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>下面总结并演示了 Redis 的 常用管理命令、key 操作、字符串、集合、列表、散列类型的操作命令。</p>
<span id="more"></span>

<h1 id="常用管理命令"><a href="#常用管理命令" class="headerlink" title="常用管理命令"></a>常用管理命令</h1><h2 id="1、启动-Redis"><a href="#1、启动-Redis" class="headerlink" title="1、启动 Redis"></a>1、启动 Redis</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> redis-server [--port 6379]</span></span><br></pre></td></tr></table></figure>

<p>如果命令参数过多，建议通过配置文件来启动 Redis。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> redis-server [xx/xx/redis.conf]</span></span><br></pre></td></tr></table></figure>

<p>6379 是 Redis 默认端口号。</p>
<h2 id="2、连接-Redis"><a href="#2、连接-Redis" class="headerlink" title="2、连接 Redis"></a>2、连接 Redis</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ./redis-cli [-h 127.0.0.1 -p 6379]</span></span><br></pre></td></tr></table></figure>

<h2 id="3、停止-Redis"><a href="#3、停止-Redis" class="headerlink" title="3、停止 Redis"></a>3、停止 Redis</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> redis-cli shutdown</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">kill</span> redis-pid</span></span><br></pre></td></tr></table></figure>

<p>以上两条停止 Redis 命令效果一样。</p>
<h2 id="4、发送命令"><a href="#4、发送命令" class="headerlink" title="4、发送命令"></a>4、发送命令</h2><p>给 Redis 发送命令有两种方式：</p>
<h3 id="1、redis-cli-带参数运行，如："><a href="#1、redis-cli-带参数运行，如：" class="headerlink" title="1、redis-cli 带参数运行，如："></a>1、redis-cli 带参数运行，如：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> redis-cli shutdown</span></span><br><span class="line">not connected&gt;</span><br></pre></td></tr></table></figure>

<p>这样默认是发送到本地的 6379 端口。</p>
<h3 id="2、redis-cli-不带参数运行，如："><a href="#2、redis-cli-不带参数运行，如：" class="headerlink" title="2、redis-cli 不带参数运行，如："></a>2、redis-cli 不带参数运行，如：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ./redis-cli</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; shutdown</span><br><span class="line">not connected&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5、测试连通性"><a href="#5、测试连通性" class="headerlink" title="5、测试连通性"></a>5、测试连通性</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>

<h1 id="key-操作命令"><a href="#key-操作命令" class="headerlink" title="key 操作命令"></a>key 操作命令</h1><h2 id="获取所有键"><a href="#获取所有键" class="headerlink" title="获取所有键"></a>获取所有键</h2><blockquote>
<p>语法：keys pattern  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;javastack&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>表示通配符，表示任意字符，会遍历所有键显示所有的键列表，时间复杂度 O(n)，在生产环境不建议使用。</li>
</ul>
</li>
</ul>
<h2 id="获取键总数"><a href="#获取键总数" class="headerlink" title="获取键总数"></a>获取键总数</h2><blockquote>
<p>语法：dbsize  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure>

<p>获取键总数时不会遍历所有的键，直接获取内部变量，时间复杂度 O(1)。</p>
<h2 id="查询键是否存在"><a href="#查询键是否存在" class="headerlink" title="查询键是否存在"></a>查询键是否存在</h2><blockquote>
<p>语法：exists key [key …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists javastack java</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<p>查询查询多个，返回存在的个数。</p>
<h2 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h2><blockquote>
<p>语法：del key [key …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del java javastack</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>可以删除多个，返回删除成功的个数。</p>
<h2 id="查询键类型"><a href="#查询键类型" class="headerlink" title="查询键类型"></a>查询键类型</h2><blockquote>
<p>语法： type key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; type javastack</span><br><span class="line">string</span><br></pre></td></tr></table></figure>

<h2 id="移动键"><a href="#移动键" class="headerlink" title="移动键"></a>移动键</h2><blockquote>
<p>语法：move key db  </p>
</blockquote>
<p>如把 javastack 移到 2 号数据库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; move javastack 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; select 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[2]&gt; keys *</span><br><span class="line">1) &quot;javastack&quot;</span><br></pre></td></tr></table></figure>

<h2 id="查询-key-的生命周期（秒）"><a href="#查询-key-的生命周期（秒）" class="headerlink" title="查询 key 的生命周期（秒）"></a>查询 key 的生命周期（秒）</h2><blockquote>
<p>秒语法：ttl key<br>毫秒语法：pttl key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; ttl javastack</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure>

<p>-1：永远不过期。</p>
<h2 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h2><blockquote>
<p>秒语法：expire key seconds<br>毫秒语法：pexpire key milliseconds  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; expire javastack 60</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[2]&gt; ttl javastack</span><br><span class="line">(integer) 55</span><br></pre></td></tr></table></figure>

<h2 id="设置永不过期"><a href="#设置永不过期" class="headerlink" title="设置永不过期"></a>设置永不过期</h2><blockquote>
<p>语法：persist key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; persist javastack</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h2 id="更改键名称"><a href="#更改键名称" class="headerlink" title="更改键名称"></a>更改键名称</h2><blockquote>
<p>语法：rename key newkey  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; rename javastack javastack123</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h1 id="字符串操作命令"><a href="#字符串操作命令" class="headerlink" title="字符串操作命令"></a>字符串操作命令</h1><p><strong>字符串是 Redis 中最基本的数据类型，单个数据能存储的最大空间是 512M。</strong></p>
<h2 id="存放键值"><a href="#存放键值" class="headerlink" title="存放键值"></a>存放键值</h2><blockquote>
<p>语法：set key value [EX seconds] [PX milliseconds] [NX|XX]  </p>
</blockquote>
<p>nx：如果 key 不存在则建立，xx：如果 key 存在则修改其值，也可以直接使用 setnx/setex 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set javastack 666</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h2 id="获取键值"><a href="#获取键值" class="headerlink" title="获取键值"></a>获取键值</h2><blockquote>
<p>语法：get key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; get javastack</span><br><span class="line">&quot;666&quot;</span><br></pre></td></tr></table></figure>

<h2 id="值递增-递减"><a href="#值递增-递减" class="headerlink" title="值递增 / 递减"></a>值递增 / 递减</h2><p>如果字符串中的值是数字类型的，可以使用 incr 命令每次递增，不是数字类型则报错。</p>
<blockquote>
<p>语法：incr key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; incr javastack</span><br><span class="line">(integer) 667</span><br></pre></td></tr></table></figure>

<p>一次想递增 N 用 incrby 命令，如果是浮点型数据可以用 incrbyfloat 命令递增。</p>
<p>同样，递减使用 decr、decrby 命令。</p>
<h2 id="批量存放键值"><a href="#批量存放键值" class="headerlink" title="批量存放键值"></a>批量存放键值</h2><blockquote>
<p>语法：mset key value [key value …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; mset java1 1 java2 2 java3 3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h2 id="获取获取键值"><a href="#获取获取键值" class="headerlink" title="获取获取键值"></a>获取获取键值</h2><blockquote>
<p>语法：mget key [key …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; mget java1 java2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br></pre></td></tr></table></figure>

<p>Redis 接收的是 UTF-8 的编码，如果是中文一个汉字将占 3 位返回。</p>
<h2 id="获取值长度"><a href="#获取值长度" class="headerlink" title="获取值长度"></a>获取值长度</h2><blockquote>
<p>语法：strlen key<br>127.0.0.1:6379[2]&gt; strlen javastack (integer) 3  </p>
</blockquote>
<h2 id="追加内容"><a href="#追加内容" class="headerlink" title="追加内容"></a>追加内容</h2><blockquote>
<p>语法：append key value  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; append javastack hi</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>

<p>向键值尾部添加，如上命令执行后由 666 变成 666hi</p>
<h2 id="获取部分字符"><a href="#获取部分字符" class="headerlink" title="获取部分字符"></a>获取部分字符</h2><blockquote>
<p>语法：getrange key start end  </p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt; 127.0.0.1<span class="selector-pseudo">:6379</span><span class="selector-attr">[2]</span>&gt; <span class="selector-tag">getrange</span> <span class="selector-tag">javastack</span> 0 4</span><br><span class="line">&quot;<span class="selector-tag">javas</span>&quot;</span><br></pre></td></tr></table></figure>

<h1 id="集合操作命令"><a href="#集合操作命令" class="headerlink" title="集合操作命令"></a>集合操作命令</h1><p>集合类型和列表类型相似，只不过是集合是无序且不可重复的。</p>
<p>集合</p>
<h2 id="存储值"><a href="#存储值" class="headerlink" title="存储值"></a>存储值</h2><blockquote>
<p>语法：sadd key member [member …]  </p>
</blockquote>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">// 这里有<span class="number">8</span>个值（<span class="number">2</span>个java），只存了<span class="number">7</span>个</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; sadd langs java php c++ go ruby python kotlin java</span><br><span class="line">(integer) <span class="number">7</span></span><br></pre></td></tr></table></figure>

<h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><blockquote>
<p>获取所有元素语法：smembers key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers langs</span><br><span class="line">1) &quot;php&quot;</span><br><span class="line">2) &quot;kotlin&quot;</span><br><span class="line">3) &quot;c++&quot;</span><br><span class="line">4) &quot;go&quot;</span><br><span class="line">5) &quot;ruby&quot;</span><br><span class="line">6) &quot;python&quot;</span><br><span class="line">7) &quot;java&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>随机获取语法：srandmember langs count  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srandmember langs 3</span><br><span class="line">1) &quot;c++&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;php&quot;</span><br></pre></td></tr></table></figure>

<h2 id="判断集合是否存在元素"><a href="#判断集合是否存在元素" class="headerlink" title="判断集合是否存在元素"></a>判断集合是否存在元素</h2><blockquote>
<p>语法：sismember key member  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sismember langs go</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h2 id="获取集合元素个数"><a href="#获取集合元素个数" class="headerlink" title="获取集合元素个数"></a>获取集合元素个数</h2><blockquote>
<p>语法：scard key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scard langs</span><br><span class="line">(integer) 7</span><br></pre></td></tr></table></figure>

<h2 id="删除集合元素"><a href="#删除集合元素" class="headerlink" title="删除集合元素"></a>删除集合元素</h2><blockquote>
<p>语法：srem key member [member …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srem langs ruby kotlin</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<h2 id="弹出元素"><a href="#弹出元素" class="headerlink" title="弹出元素"></a>弹出元素</h2><blockquote>
<p>语法：spop key [count]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; spop langs 2</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;java&quot;</span><br></pre></td></tr></table></figure>

<h1 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h1><blockquote>
<p>和列表的区别：</p>
<p>1、列表使用链表实现，两头快，中间慢。有序集合是散列表和跳跃表实现的，即使读取中间的元素也比较快。</p>
<p>2、列表不能调整元素位置，有序集合能。</p>
<p>3、有序集合比列表更占内存。</p>
</blockquote>
<h2 id="存储值-1"><a href="#存储值-1" class="headerlink" title="存储值"></a>存储值</h2><blockquote>
<p>语法：zadd key [NX|XX] [CH] [INCR] score member [score member …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd footCounts 16011 tid 20082 huny 2893 nosy</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<h2 id="获取元素分数"><a href="#获取元素分数" class="headerlink" title="获取元素分数"></a>获取元素分数</h2><blockquote>
<p>语法：zscore key member  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscore footCounts tid</span><br><span class="line">&quot;16011&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取排名范围排名语法：zrange key start stop [WITHSCORES]  </p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 获取所有，没有分数</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange footCounts <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;nosy&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;tid&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;huny&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 获取所有及分数</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange footCounts <span class="number">0</span> -<span class="number">1</span> Withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;nosy&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;2893&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;tid&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;16011&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;huny&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;20082&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取指定分数范围排名语法：zrangebyscore key min max [WITHSCORES] [LIMIT offset count]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrangebyscore footCounts 3000 30000 withscores limit 0 1</span><br><span class="line">1) &quot;tid&quot;</span><br><span class="line">2) &quot;16011&quot;</span><br></pre></td></tr></table></figure>

<h2 id="增加指定元素分数"><a href="#增加指定元素分数" class="headerlink" title="增加指定元素分数"></a>增加指定元素分数</h2><blockquote>
<p>语法：zincrby key increment member  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zincrby footCounts 2000 tid</span><br><span class="line">&quot;18011&quot;</span><br></pre></td></tr></table></figure>

<h2 id="获取集合元素个数-1"><a href="#获取集合元素个数-1" class="headerlink" title="获取集合元素个数"></a>获取集合元素个数</h2><blockquote>
<p>语法：zcard key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zcard footCounts</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<h2 id="获取指定范围分数个数"><a href="#获取指定范围分数个数" class="headerlink" title="获取指定范围分数个数"></a>获取指定范围分数个数</h2><blockquote>
<p>语法：zcount key min max  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zcount footCounts 2000 20000</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<h2 id="删除指定元素"><a href="#删除指定元素" class="headerlink" title="删除指定元素"></a>删除指定元素</h2><blockquote>
<p>语法：zrem key member [member …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrem footCounts huny</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h2 id="获取元素排名"><a href="#获取元素排名" class="headerlink" title="获取元素排名"></a>获取元素排名</h2><blockquote>
<p>语法：zrank key member  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrank footCounts tid</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h1 id="列表操作命令"><a href="#列表操作命令" class="headerlink" title="列表操作命令"></a>列表操作命令</h1><p>列表类型是一个有序的字段串列表，内部是使用双向链表实现，所有可以向两端操作元素，获取两端的数据速度快，通过索引到具体的行数比较慢。</p>
<p>列表类型的元素是有序且可以重复的。</p>
<h2 id="存储值-2"><a href="#存储值-2" class="headerlink" title="存储值"></a>存储值</h2><blockquote>
<p>左端存值语法：lpush key value [value …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list lily sandy</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>右端存值语法：rpush key value [value …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush list tom kitty</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<blockquote>
<p>索引存值语法：lset key index value  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lset list 3 uto</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h2 id="弹出元素-1"><a href="#弹出元素-1" class="headerlink" title="弹出元素"></a>弹出元素</h2><blockquote>
<p>左端弹出语法：lpop key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpop list</span><br><span class="line">&quot;sandy&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>右端弹出语法：rpop key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpop list</span><br><span class="line">&quot;kitty&quot;</span><br></pre></td></tr></table></figure>

<h2 id="获取元素个数"><a href="#获取元素个数" class="headerlink" title="获取元素个数"></a>获取元素个数</h2><blockquote>
<p>语法：llen key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen list</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<h2 id="获取列表元素"><a href="#获取列表元素" class="headerlink" title="获取列表元素"></a>获取列表元素</h2><blockquote>
<p>两边获取语法：lrange key start stop  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush users tom kitty land pony jack maddy</span><br><span class="line">(integer) 6</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lrange users 0 3</span><br><span class="line">1) &quot;maddy&quot;</span><br><span class="line">2) &quot;jack&quot;</span><br><span class="line">3) &quot;pony&quot;</span><br><span class="line">4) &quot;land&quot;</span><br><span class="line"></span><br><span class="line">// 获取所有</span><br><span class="line">127.0.0.1:6379&gt; lrange users 0 -1</span><br><span class="line">1) &quot;maddy&quot;</span><br><span class="line">2) &quot;jack&quot;</span><br><span class="line">3) &quot;pony&quot;</span><br><span class="line">4) &quot;land&quot;</span><br><span class="line">5) &quot;kitty&quot;</span><br><span class="line">6) &quot;tom&quot;</span><br><span class="line"></span><br><span class="line">// 从右端索引</span><br><span class="line">127.0.0.1:6379&gt; lrange users -3 -1</span><br><span class="line">1) &quot;land&quot;</span><br><span class="line">2) &quot;kitty&quot;</span><br><span class="line">3) &quot;tom&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>索引获取语法：lindex key index  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lindex list 2</span><br><span class="line">&quot;ketty&quot;</span><br><span class="line"></span><br><span class="line">// 从右端获取</span><br><span class="line">127.0.0.1:6379&gt; lindex list -5</span><br><span class="line">&quot;sady&quot;</span><br></pre></td></tr></table></figure>

<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><blockquote>
<p>根据值删除语法：lrem key count value  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush userids 111 222 111 222 222 333 222 222</span><br><span class="line">(integer) 8</span><br><span class="line"></span><br><span class="line">// count=0 删除所有</span><br><span class="line">127.0.0.1:6379&gt; lrem userids 0 111</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">// count &gt; 0 从左端删除前count个</span><br><span class="line">127.0.0.1:6379&gt; lrem userids 3 222</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">// count &lt; 0 从右端删除前count个</span><br><span class="line">127.0.0.1:6379&gt; lrem userids -3 222</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>范围删除语法：ltrim key start stop  </p>
</blockquote>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">// 只保留<span class="number">2</span>-<span class="number">4</span>之间的元素</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; ltrim list <span class="number">2</span> <span class="number">4</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h1 id="散列操作命令"><a href="#散列操作命令" class="headerlink" title="散列操作命令"></a>散列操作命令</h1><p>redis 字符串类型键和值是字典结构形式，这里的散列类型其值也可以是字典结构。</p>
<h2 id="存放键值-1"><a href="#存放键值-1" class="headerlink" title="存放键值"></a>存放键值</h2><blockquote>
<p>单个语法：hset key field value  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user name javastack</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多个语法：hmset key field value [field value …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user name javastack age 20 address china</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不存在时语法：hsetnx key field value  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hsetnx user tall 180</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<h2 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a>获取字段值</h2><blockquote>
<p>单个语法：hget key field  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget user age</span><br><span class="line">&quot;20&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多个语法：hmget key field [field …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmget user name age address</span><br><span class="line">1) &quot;javastack&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;china&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取所有键与值语法：hgetall key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;javastack&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;address&quot;</span><br><span class="line">6) &quot;china&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取所有字段语法：hkeys key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys user</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;address&quot;</span><br><span class="line">3) &quot;tall&quot;</span><br><span class="line">4) &quot;age&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取所有值语法：hvals key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hvals user</span><br><span class="line">1) &quot;javastack&quot;</span><br><span class="line">2) &quot;china&quot;</span><br><span class="line">3) &quot;170&quot;</span><br><span class="line">4) &quot;20&quot;</span><br></pre></td></tr></table></figure>

<h2 id="判断字段是否存在"><a href="#判断字段是否存在" class="headerlink" title="判断字段是否存在"></a>判断字段是否存在</h2><blockquote>
<p>语法：hexists key field  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists user address</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h2 id="获取字段数量"><a href="#获取字段数量" class="headerlink" title="获取字段数量"></a>获取字段数量</h2><blockquote>
<p>语法：hlen key  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hlen user</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<h2 id="递增-减"><a href="#递增-减" class="headerlink" title="递增 / 减"></a>递增 / 减</h2><blockquote>
<p>语法：hincrby key field increment  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hincrby user tall -10</span><br><span class="line">(integer) 170</span><br></pre></td></tr></table></figure>

<h2 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h2><blockquote>
<p>语法：hdel key field [field …]  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel user age</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>都是基本的命令用法，不会用了就来翻一下吧！</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>配置免密登录linux</title>
    <url>/2021/02/01/%E9%85%8D%E7%BD%AE%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95linux/</url>
    <content><![CDATA[<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><p>切换到git环境下</p>
<p><strong>没有git环境的，自行百度安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换目录</span></span><br><span class="line">cd ~/.ssh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建config文件</span></span><br><span class="line">vim config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入以下内容</span></span><br><span class="line">Host centos # 自定义, 用于后续的免密登录</span><br><span class="line">HostName 192.168.117.29 # 服务器地址ip</span><br><span class="line">User root # 登录的用户名</span><br><span class="line">Port 22 # 端口</span><br><span class="line">IdentityFile ~/.ssh/id_rsa # 私钥路径, id_rsa.pub是公钥</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成密钥对, 可以自行指定文件名, 默认为id_rsa和id_rsa.pub</span></span><br><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发送id_rsa.pub文件至Linux服务器上</span></span><br><span class="line">scp id_rsa.pub 用户名@ip:/home/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录Linux服务器后, 进行操作</span></span><br><span class="line">mv /home/id_rsa.pub ~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改sshd_config配置, 确保以下几项配置前面没有<span class="comment">#字符</span></span></span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile  .ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启ssh服务</span></span><br><span class="line">systemctl restart sshd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回Windows，打开cmd</span></span><br><span class="line">ssh centos # 这里的centos, 对应config文件中Host配置的内容</span><br></pre></td></tr></table></figure>

<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>操作顺序一致，无需安装git环境，不过需要确保ssh和scp命令可执行</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqlpump使用说明</title>
    <url>/2021/02/27/mysqlpump%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>下面介绍 MySQL5.7 之后新添加的备份工具 mysqlpump。</p>
<p>mysqlpump 是 mysqldump 的一个衍生，mysqldump 备份功能这里就不多说了，现在看看 mysqlpump 到底有了哪些提升，详细可以查看<a href="https%EF%BC%9A//dev.mysql.com/doc/refman/5.7/en/mysqlpump.html">官网文档</a>。</p>
<p>mysqlpump 和 mysqldump 一样，属于逻辑备份，备份以 SQL 形式的文本保存。逻辑备份相对物理备份好处是不关心 log 的大小，直接备份数据即可。</p>
<span id="more"></span>

<h2 id="mysqlpump-主要特点"><a href="#mysqlpump-主要特点" class="headerlink" title="mysqlpump 主要特点"></a>mysqlpump 主要特点</h2><p>-  并行备份数据库和数据库中的对象的，加快备份过程。<br>-  更好的控制数据库和数据库对象（表，存储过程，用户帐户）的备份。<br>-  备份用户账号作为帐户管理语句（CREATE USER，GRANT），而不是直接插入到 MySQL 的系统数据库。<br>-  备份出来直接生成压缩后的备份文件。<br>-  备份进度指示（估计值）。<br>-  重新加载（还原）备份文件，先建表后插入数据最后建立索引，减少了索引维护开销，加快了还原速度。<br>-  备份可以排除或则指定数据库。</p>
<h2 id="mysqlpump-缺点"><a href="#mysqlpump-缺点" class="headerlink" title="mysqlpump 缺点"></a>mysqlpump 缺点</h2><p><a href="https://theme-next.js.org/highlight/">https://theme-next.js.org/highlight/</a><br>-  只能并行到表级别, 如果表特别大, 开多线程和单线程是一样的, 并行度不如 mydumper；<br>-  无法获取当前备份对应的 binlog 位置；<br>-  MySQL5.7.11 之前的版本不要使用, 并行导出和 single-transaction 是互斥的；</p>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>mysqlpump 绝大部分参数使用和 Mysqldump 一致，下面顺便重温一下。注意对于 mysqlpump 专有参数会用<strong>加粗</strong>标记出来。</p>
<p>1) –add-drop-database： 在建立库之前先执行删库操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `...`;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>–add-drop-table：在建表之前先执行删表操作</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `...`.`...`;</span><br></pre></td></tr></table></figure>

<p><strong>3) –add-drop-user：在 CREATE USER 语句之前增加 DROP USER。 注意：这个参数需要和 –users 一起使用，否者不生效。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;backup&#x27;</span>@<span class="string">&#x27;172.16.60.%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>–add-locks：备份表时，使用 LOCK TABLES 和 UNLOCK TABLES。注意：这个参数不支持并行备份，需要关闭并行备份功能：–default-parallelism=0</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LOCK TABLES `...`.`...` WRITE;</span><br><span class="line">...</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>–all-databases：备份所有库，即 -A。</p>
</li>
<li><p>–bind-address：指定通过哪个网络接口来连接 Mysql 服务器（一台服务器可能有多个 IP），防止同一个网卡出去影响业务。</p>
</li>
<li><p>–complete-insert：dump 出包含所有列的完整 insert 语句。</p>
</li>
<li><p>–compress： 压缩客户端和服务器传输的所有的数据，即 -C。</p>
</li>
<li><p><strong>–compress-output</strong>：<strong>默认不压缩输出，目前可以使用的压缩算法有 LZ4 和 ZLIB</strong></p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mysqlpump --compress-output=LZ4 &gt; dump.lz4</span><br><span class="line">[root@localhost ~]# lz4_decompress dump.lz4 dump.txt</span><br><span class="line"> </span><br><span class="line">[root@localhost ~]# mysqlpump --compress-output=ZLIB &gt; dump.zlib</span><br><span class="line">[root@localhost ~]# zlib_decompress dump.zlib dump.txt</span><br></pre></td></tr></table></figure>

<ol start="10">
<li><p>–databases：手动指定要备份的库，支持多个数据库，用空格分隔，即 - B。</p>
</li>
<li><p>–default-character-set：指定备份的字符集。</p>
</li>
</ol>
<p><strong>12) –default-parallelism：指定并行线程数，默认是 2，如果设置成 0，表示不使用并行备份。</strong>注意：每个线程的备份步骤是：先 create table 但不建立二级索引（主键会在 create table 时候建立），再写入数据，最后建立二级索引。</p>
<p><strong>13) –defer-table-indexes：延迟创建索引，直到所有数据都加载完之后，再创建索引，默认开启。</strong>若关闭则会和 mysqldump 一样：先创建一个表和所有索引，再导入数据，因为在加载还原数据的时候要维护二级索引的开销，导致效率比较低。关闭使用参数：–skip–defer-table-indexes。</p>
<ol start="14">
<li>–events：备份数据库的事件，默认开启，关闭使用 –skip-events 参数。</li>
</ol>
<p><strong>15) –exclude-databases：备份排除该参数指定的数据库，多个用逗号分隔。类似的还有 –exclude-events、–exclude-routines、–exclude-tables、–exclude-triggers、–exclude-users</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mysqlpump --exclude-databases=mysql,sys -p123456 --set-gtid-purged=off &gt;/root/db.sql   #备份过滤mysql和sys数据库</span><br><span class="line">[root@localhost ~]# mysqlpump --exclude-tables=rr,tt -p123456 --set-gtid-purged=off &gt; /root/db.sql      #备份过滤所有数据库中rr、tt表</span><br><span class="line">[root@localhost ~]# mysqlpump -B test --exclude-tables=tmp_ifulltext,tt -p123456 --set-gtid-purged=off &gt;/root/db.sql   #备份过滤test库中的rr、tt表</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>要是只备份数据库的账号，需要添加参数 <a href="https%EF%BC%9A//dev.mysql.com/doc/refman/5.7/en/mysqlpump.html#option_mysqlpump_users">–users</a>，并且需要过滤掉所有的数据库，如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">备份除dba和backup的所有账号。</span></span><br><span class="line">[root@localhost ~]# mysqlpump --users --exclude-databases=sys,mysql,db1,db2 --exclude-users=dba,backup -p123456 --set-gtid-purged=off &gt;/root/db.sql</span><br></pre></td></tr></table></figure>

<p><strong>16) –include-databases：指定备份数据库，多个用逗号分隔，类似的还有 –include-events、–include-routines、–include-tables、–include-triggers、–include-users，大致方法使用同 15。</strong></p>
<ol start="17">
<li><p>–insert-ignore：备份用 insert ignore 语句代替 insert 语句。</p>
</li>
<li><p>–log-error-file：备份出现的 warnings 和 erros 信息输出到一个指定的文件。</p>
</li>
<li><p>–max-allowed-packet：备份时用于 client/server 直接通信的最大 buffer 包的大小。</p>
</li>
<li><p>–net-buffer-length：备份时用于 client/server 通信的初始 buffer 大小，当创建多行插入语句的时候，mysqlpump 创建行到 N 个字节长。</p>
</li>
<li><p>–no-create-db：备份不写 CREATE DATABASE 语句。要是备份多个库，需要使用参数 - B，而使用 - B 的时候会出现 create database 语句，该参数可以屏蔽 create database 语句。</p>
</li>
<li><p>–no-create-info：备份不写建表语句，即不备份表结构，只备份数据，即 -t。</p>
</li>
<li><p>–hex-blob： 备份 binary 字段的时候使用十六进制计数法，受影响的字段类型有 BINARY、VARBINARY、BLOB、BIT。</p>
</li>
<li><p>–host ：备份指定的数据库地址，即 -h。</p>
</li>
</ol>
<p><strong>25) –parallel-schemas=[N：]db_list：指定并行备份的库，多个库用逗号分隔，如果指定了 N，将使用 N 个线程的地队列，如果 N 不指定，将由 –default-parallelism 才确认 N 的值，可以设置多个 –parallel-schemas</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">4个线程备份vs和aa，3个线程备份pt。通过show processlist 可以看到有7个线程。</span></span><br><span class="line">[root@localhost ~]# mysqlpump --parallel-schemas=4：vs,aa --parallel-schemas=3：pt  -p123456 --set-gtid-purged=off &gt; /root/db.sql  </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">默认2个线程，即2个线程备份vs和abc，2个线程备份pt</span></span><br><span class="line">[root@localhost ~]# mysqlpump --parallel-schemas=vs,abc --parallel-schemas=pt  -p123456 --set-gtid-purged=off &gt; /root/db.sql  </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">当然要是硬盘IO不允许的话，可以少开几个线程和数据库进行并行备份</span></span><br></pre></td></tr></table></figure>

<ol start="26">
<li><p>–password<strong>：</strong>备份需要的密码。</p>
</li>
<li><p>–port ：备份数据库的端口。</p>
</li>
<li><p>–protocol={TCP|SOCKET|PIPE|MEMORY}：指定连接服务器的协议。</p>
</li>
<li><p>–replace：备份出来 replace into 语句。</p>
</li>
<li><p>–routines：备份出来包含存储过程和函数，默认开启，需要对 mysql.proc 表有查看权限。生成的文件中会包含 CREATE PROCEDURE 和 CREATE FUNCTION 语句以用于恢复，关闭则需要用 –skip-routines 参数。</p>
</li>
<li><p>–triggers：备份出来包含触发器，默认开启，使用 –skip-triggers 来关闭。</p>
</li>
<li><p>–set-charset：备份文件里写 SET NAMES default_character_set 到输出，此参默认开启。 – skip-set-charset 禁用此参数，不会在备份文件里面写出 set names…</p>
</li>
<li><p>–single-transaction<strong>：</strong>该参数在事务隔离级别设置成 Repeatable Read，并在 dump 之前发送 start transaction 语句给服务端**。这在使用 innodb 时很有用，因为在发出 start transaction 时，保证了在不阻塞任何应用下的一致性状态。对 myisam 和 memory 等非事务表，还是会改变状态的，当使用此参的时候要确保没有其他连接在使用 ALTER TABLE、CREATE TABLE、DROP TABLE、RENAME TABLE、TRUNCATE TABLE 等语句，否则会出现不正确的内容或则失败。–add-locks 和此参互斥，在 mysql5.7.11 之前，–default-parallelism 大于 1 的时候和此参也互斥，必须使用 –default-parallelism=0。5.7.11 之后解决了 –single-transaction 和 –default-parallelism 的互斥问题。</p>
</li>
<li><p>–skip-definer：忽略那些创建视图和存储过程用到的 DEFINER 和 SQL SECURITY 语句，恢复的时候，会使用默认值，否则会在还原的时候看到没有 DEFINER 定义时的账号而报错。**</p>
</li>
<li><p>–skip-dump-rows：只备份表结构，不备份数据，即 -d。注意：mysqldump 支持 –no-data，mysqlpump 不支持 –no-data**</p>
</li>
<li><p>–socket：对于连接到 localhost，Unix 使用套接字文件，在 Windows 上是命名管道的名称使用，即 -S。</p>
</li>
<li><p>–ssl<strong>：</strong>–ssl 参数将要被去除，用 –ssl-mode 取代**。关于 ssl 相关的备份。</p>
</li>
<li><p>–tz-utc：备份时会在备份文件的最前几行添加 SET TIME_ZONE=’+00：00’。注意：如果还原的服务器不在同一个时区并且还原表中的列有 timestamp 字段，会导致还原出来的结果不一致。默认开启该参数，用 –skip-tz-utc 来关闭参数。</p>
</li>
<li><p>–user：备份时候的用户名，即 -u。</p>
</li>
<li><p>–users：备份数据库用户，备份的形式是 CREATE USER…，GRANT…，只备份数据库账号可以通过如下命令**</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">过滤掉所有数据库</span></span><br><span class="line">[root@localhost ~]# mysqlpump --exclude-databases=% --users  -p123456 --set-gtid-purged=off &gt;/root/db.sql</span><br></pre></td></tr></table></figure>

<ol start="40">
<li><strong>–watch-progress</strong>：<strong>定期显示进度的完成，包括总数表、行和其他对象。该参数默认开启，用 –skip-watch-progress 来关闭。</strong> </li>
</ol>
<p><strong>mysqlpump 的多线程架构图如下</strong></p>
<p><img data-src="https://img2018.cnblogs.com/blog/907596/201901/907596-20190115162636956-1342333863.png"></p>
<p>-  mysqlpump 是 MySQL5.7 的官方工具, 用于取代 mysqldump, 其参数与 mysqldump 基本一样；<br>-  mysqlpump 是多线程备份, 但只能到表级别, 单表备份还是单线程；<br>-  mysqldump 备份时, 有个默认队列（default）, 队列下开 N 个线程去备份数据库 / 数据库中的表；<br>-  支持开多个队列 (对应不同库 / 表), 然后每个队列设置不同线程, 进行备份；</p>
<p><strong>mysqlpump 支持基于库和表的并行导出</strong>，mysqlpump 的并行导出功能的架构为：队列 + 线程，允许有多个队列（**–parallel-schemas<strong>），每个队列下有多个线程（N），而一个队列可以绑定 1 个或者多个数据库（逗号分隔）。</strong>mysqlpump 的备份是基于表并行的，对于每张表的导出只能是单个线程的**，这里会有个限制是如果某个数据库有一张表非常大，可能大部分的时间都是消耗在这个表的备份上面，并行备份的效果可能就不明显。这里可以利用 <strong>Mydumper</strong> 其是以 chunk 的方式批量导出，即 <strong>Mydumper 支持一张表多个线程以 chunk 的方式批量导出</strong>。但相对于 Mysqldump 有很大提升。</p>
<h2 id="对比测试如下"><a href="#对比测试如下" class="headerlink" title="对比测试如下"></a><strong>对比测试如下</strong></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlpump压缩备份kevin数据库 三个并发线程备份，消耗时间：222s</span><br><span class="line">[root@localhost ~]# mysqlpump -uroot -p123456 -h172.16.60.211 --single-transaction --default-character-set=utf8 --compress-output=LZ4 --default-parallelism=3 -B kevin &gt; /data/db_backup/kevin_db.sql.lz4</span><br><span class="line"> </span><br><span class="line">mysqldump备份压缩kevin数据库 单个线程备份，消耗时间：900s，gzip的压缩率比LZ4的高</span><br><span class="line">[root@localhost ~]# mysqldump -uroot -p123456 -h172.16.60.211 --default-character-set=utf8 -P3306 --skip-opt --add-drop-table --create-options  --quick --extended-insert --single-transaction -B kevin | gzip &gt; /data/db_backup/kevin.sql.gz</span><br><span class="line"> </span><br><span class="line">mydumper备份kevin数据库 三个并发线程备份，消耗时间：300s，gzip的压缩率比LZ4的高</span><br><span class="line">[root@localhost ~]# mydumper -u root -p123456  -h 172.16.60.211 -P 3306 -t 3 -c -l 3600 -s 10000000 -B kevin -o /data/db_backup/kevin/</span><br><span class="line"> </span><br><span class="line">mydumper备份kevin数据库，五个并发线程备份，并且开启对一张表多个线程以chunk的方式批量导出，-r。消耗时间：180s</span><br><span class="line">[root@localhost ~]# mydumper -u root -p123456  -h 172.16.60.211 -P 3306 -t 5 -c -r 300000 -l 3600 -s 10000000 -B kevin -o /data/db_backup/kevin/</span><br><span class="line"> </span><br><span class="line">注意： 如果是开启了GTID功能的数据库，备份时还需要添加&quot;--set-gtid-purged=off&quot;参数，否则可能会报错！</span><br></pre></td></tr></table></figure>

<p>从上面看出，mysqlpump 的备份效率是最快的，mydumper 次之，mysqldump 最差。所以在 IO 允许的情况下，能用多线程就别用单线程备份。并且 mysqlpump 还支持多数据库的并行备份，而 mydumper 要么备份一个库，要么就备份所有库。可以看出，在 mysql 数据库备份方面，mysqlpump 比 mysqldump 的测试结果要好。由于实际情况不同，测试给出的速度提升只是参考。到底开启多少个并行备份的线程，这个看磁盘 IO 的承受能力，若该服务器只进行备份任务，可以最大限制的来利用磁盘。</p>
<p>测试中发现 mysqlpump 和 mysqldump 对比：  </p>
<ul>
<li>mysqldump 默认是不会有建库命令， 但是默认会有 drop table 的命令;  </li>
<li>mysqlpump 默认是有建库命令，但是不会有 drop table 的命令，所以 mysqlpump 恢复的时候不要直接 &lt; file.sql ;  </li>
<li>mysqldump 恢复时会先创建表及其所有索引，然后再导入数据；mysqlpump 恢复时会先创建表，然后再导入数据，最后建索引;  </li>
<li>mysqlpump 可以指定多线程并发备份，默认是 2 个；备份时会有进度指示，虽然只是估计值，但不会再想 mysqldump 备份时那么枯燥，看不到过程.</li>
</ul>
<p>注意：mysqlpump 备份的几个重要参数</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">--default-parallelism   指定线程数,默认开2个线程进行并发备份</span></span><br><span class="line"><span class="comment">--parallel-schemas      指定哪些数据库进行并发备份</span></span><br><span class="line"><span class="comment">--set-gtid-purged=OFF   这个是5.7.18版本后加入的参数,</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">--set-gtid-purged=OFF这个参数很重要，如果备份命令里不加上，则备份可能会报错：</span></span><br><span class="line">Warning： A partial dump <span class="keyword">from</span> a server <span class="keyword">that</span> has GTIDs will <span class="keyword">by</span> default include <span class="keyword">the</span> GTIDs <span class="keyword">of</span> all transactions, even those <span class="keyword">that</span> changed </span><br><span class="line">suppressed parts <span class="keyword">of</span> <span class="keyword">the</span> database. If you don&#x27;t want <span class="keyword">to</span> restore GTIDs, pass <span class="comment">--set-gtid-purged=OFF. To make a complete dump, pass </span></span><br><span class="line"><span class="comment">--all-databases --triggers --routines --events.</span></span><br></pre></td></tr></table></figure>

<h2 id="备份演示"><a href="#备份演示" class="headerlink" title="备份演示"></a>备份演示</h2><h3 id="备份命令"><a href="#备份命令" class="headerlink" title="备份命令"></a>备份命令</h3><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">[root<span class="meta">@localhost</span> ~]<span class="comment"># mysqlpump --single-transaction --set-gtid-purged=OFF --parallel-schemas=2：kevin --parallel-schemas=4：dbt3 -B kevin dbt3 -p123456 &gt; /tmp/backup.sql</span></span><br><span class="line">mysqlpump： [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Dump progress： 1/5 tables, 0/7559817 rows</span><br><span class="line">Dump progress： 3/15 tables, 286750/12022332 rows</span><br><span class="line">Dump progress： 3/15 tables, 686750/12022332 rows</span><br><span class="line">Dump progress： 3/15 tables, 1042250/12022332 rows</span><br><span class="line">...</span><br><span class="line">Dump completed in 43732 milliseconds</span><br><span class="line"> </span><br><span class="line">接着另外打开一个终端会话，登录mysql看下情况</span><br><span class="line">(root<span class="meta">@172.16.0.10)</span> [(none)]&gt; show processlist;</span><br><span class="line">+--------+------+------------------+------+---------+------+-------------------+------------------------------------------------------------------------------------------------------+</span><br><span class="line">|<span class="string"> Id     </span>|<span class="string"> User </span>|<span class="string"> Host             </span>|<span class="string"> db   </span>|<span class="string"> Command </span>|<span class="string"> Time </span>|<span class="string"> State             </span>|<span class="string"> Info                                                                                                 </span>|</span><br><span class="line">+--------+------+------------------+------+---------+------+-------------------+------------------------------------------------------------------------------------------------------+</span><br><span class="line">|<span class="string"> 138199 </span>|<span class="string"> root </span>|<span class="string"> 172.16.60.50：39238 </span>|<span class="string"> NULL </span>|<span class="string"> Query   </span>|<span class="string">    0 </span>|<span class="string"> starting          </span>|<span class="string"> show processlist                                                                                     </span>|</span><br><span class="line">|<span class="string"> 138267 </span>|<span class="string"> root </span>|<span class="string"> 172.16.60.50：39776 </span>|<span class="string"> NULL </span>|<span class="string"> Sleep   </span>|<span class="string">    2 </span>|<span class="string">                   </span>|<span class="string"> NULL                                                                                                 </span>|</span><br><span class="line">|<span class="string"> 138268 </span>|<span class="string"> root </span>|<span class="string"> 172.16.60.50：39778 </span>|<span class="string"> NULL </span>|<span class="string"> Query   </span>|<span class="string">    2 </span>|<span class="string"> Sending to client </span>|<span class="string"> SELECT SQL_NO_CACHE `emp_no`,`dept_no`,`from_date`,`to_date`  FROM `kevin`.`dept_emp`            </span>|</span><br><span class="line">|<span class="string"> 138269 </span>|<span class="string"> root </span>|<span class="string"> 172.16.60.50：39780 </span>|<span class="string"> NULL </span>|<span class="string"> Query   </span>|<span class="string">    2 </span>|<span class="string"> Sending to client </span>|<span class="string"> SELECT SQL_NO_CACHE `emp_no`,`birth_date`,`first_name`,`last_name`,`gender`,`hire_date`  FROM `emplo </span>|</span><br><span class="line">|<span class="string"> 138270 </span>|<span class="string"> root </span>|<span class="string"> 172.16.60.50：39782 </span>|<span class="string"> NULL </span>|<span class="string"> Query   </span>|<span class="string">    2 </span>|<span class="string"> Sending to client </span>|<span class="string"> SELECT SQL_NO_CACHE `o_orderkey`,`o_custkey`,`o_orderstatus`,`o_totalprice`,`o_orderDATE`,`o_orderpr </span>|</span><br><span class="line">|<span class="string"> 138271 </span>|<span class="string"> root </span>|<span class="string"> 172.16.60.50：39784 </span>|<span class="string"> NULL </span>|<span class="string"> Query   </span>|<span class="string">    2 </span>|<span class="string"> Sending to client </span>|<span class="string"> SELECT SQL_NO_CACHE `p_partkey`,`p_name`,`p_mfgr`,`p_brand`,`p_type`,`p_size`,`p_container`,`p_retai </span>|</span><br><span class="line">|<span class="string"> 138272 </span>|<span class="string"> root </span>|<span class="string"> 172.16.60.50：39786 </span>|<span class="string"> NULL </span>|<span class="string"> Query   </span>|<span class="string">    2 </span>|<span class="string"> Sending data      </span>|<span class="string"> SELECT SQL_NO_CACHE `l_orderkey`,`l_partkey`,`l_suppkey`,`l_linenumber`,`l_quantity`,`l_extendedpric </span>|</span><br><span class="line">|<span class="string"> 138273 </span>|<span class="string"> root </span>|<span class="string"> 172.16.60.50：39788 </span>|<span class="string"> NULL </span>|<span class="string"> Query   </span>|<span class="string">    2 </span>|<span class="string"> Sending to client </span>|<span class="string"> SELECT SQL_NO_CACHE `c_custkey`,`c_name`,`c_address`,`c_nationkey`,`c_phone`,`c_acctbal`,`c_mktsegme </span>|</span><br><span class="line">|<span class="string"> 138274 </span>|<span class="string"> root </span>|<span class="string"> 172.16.60.50：39790 </span>|<span class="string"> NULL </span>|<span class="string"> Sleep   </span>|<span class="string">    2 </span>|<span class="string">                   </span>|<span class="string"> NULL                                                                                                 </span>|</span><br><span class="line">|<span class="string"> 138275 </span>|<span class="string"> root </span>|<span class="string"> 172.16.60.50：39792 </span>|<span class="string"> NULL </span>|<span class="string"> Sleep   </span>|<span class="string">    1 </span>|<span class="string">                   </span>|<span class="string"> NULL                                                                                                 </span>|</span><br><span class="line">+--------+------+------------------+------+---------+------+-------------------+------------------------------------------------------------------------------------------------------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">可以看到138268和138269在备份kevin库,138270,138271,138272,138273在备份dbt3,这里没打印全。</span><br></pre></td></tr></table></figure>

<h3 id="备份过程如下"><a href="#备份过程如下" class="headerlink" title="备份过程如下"></a>备份过程如下</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">终端会话<span class="number">1</span>：</span><br><span class="line">(root<span class="variable">@localhost</span>) [(<span class="keyword">none</span>)]<span class="operator">&gt;</span> <span class="keyword">truncate</span> mysql.general_log;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.10</span> sec)</span><br><span class="line"> </span><br><span class="line">(root<span class="variable">@localhost</span>) [(<span class="keyword">none</span>)]<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> log_output <span class="operator">=</span> <span class="string">&#x27;table&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"> </span><br><span class="line">(root<span class="variable">@localhost</span>) [(<span class="keyword">none</span>)]<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> general_log <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">终端会话<span class="number">2</span>：</span><br><span class="line">[root<span class="variable">@VM</span>_0_5_centos <span class="operator">~</span>]# mysqlpump <span class="comment">--single-transaction kevin --set-gtid-purged=OFF -p123456&gt; /tmp/backup.sql</span></span><br><span class="line">Dump completed <span class="keyword">in</span> <span class="number">592</span> milliseconds</span><br><span class="line"> </span><br><span class="line">(root<span class="variable">@localhost</span>) [(<span class="keyword">none</span>)]<span class="operator">&gt;</span> <span class="keyword">select</span> thread_id,<span class="keyword">left</span>(argument, <span class="number">64</span>) <span class="keyword">from</span> mysql.general_log <span class="keyword">order</span> <span class="keyword">by</span> event_time;</span><br><span class="line">................</span><br><span class="line">................</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">7</span> <span class="operator">|</span> root<span class="variable">@localhost</span> <span class="keyword">on</span>  <span class="keyword">using</span> Socket                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">7</span> <span class="operator">|</span> FLUSH TABLES <span class="keyword">WITH</span> READ LOCK                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">7</span> <span class="operator">|</span> <span class="keyword">SHOW</span> WARNINGS                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">7</span> <span class="operator">|</span> <span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">7</span> <span class="operator">|</span> <span class="keyword">SHOW</span> WARNINGS                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">7</span> <span class="operator">|</span> <span class="keyword">START</span> TRANSACTION <span class="keyword">WITH</span> CONSISTENT SNAPSHOT                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">7</span> <span class="operator">|</span> <span class="keyword">SHOW</span> WARNINGS                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">8</span> <span class="operator">|</span> root<span class="variable">@localhost</span> <span class="keyword">on</span>  <span class="keyword">using</span> Socket                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">8</span> <span class="operator">|</span> <span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">8</span> <span class="operator">|</span> <span class="keyword">SHOW</span> WARNINGS                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">8</span> <span class="operator">|</span> <span class="keyword">START</span> TRANSACTION <span class="keyword">WITH</span> CONSISTENT SNAPSHOT                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">8</span> <span class="operator">|</span> <span class="keyword">SHOW</span> WARNINGS                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">9</span> <span class="operator">|</span> root<span class="variable">@localhost</span> <span class="keyword">on</span>  <span class="keyword">using</span> Socket                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">9</span> <span class="operator">|</span> <span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">9</span> <span class="operator">|</span> <span class="keyword">SHOW</span> WARNINGS                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">9</span> <span class="operator">|</span> <span class="keyword">START</span> TRANSACTION <span class="keyword">WITH</span> CONSISTENT SNAPSHOT                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">9</span> <span class="operator">|</span> <span class="keyword">SHOW</span> WARNINGS                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">7</span> <span class="operator">|</span> UNLOCK TABLES                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">7</span> <span class="operator">|</span> <span class="keyword">SHOW</span> WARNINGS                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">9</span> <span class="operator">|</span> <span class="keyword">SET</span> SQL_QUOTE_SHOW_CREATE<span class="operator">=</span> <span class="number">1</span>                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">9</span> <span class="operator">|</span> <span class="keyword">SHOW</span> WARNINGS                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">9</span> <span class="operator">|</span> <span class="keyword">SET</span> TIME_ZONE<span class="operator">=</span><span class="string">&#x27;+00：00&#x27;</span>                                           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">8</span> <span class="operator">|</span> <span class="keyword">SET</span> SQL_QUOTE_SHOW_CREATE<span class="operator">=</span> <span class="number">1</span>                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">8</span> <span class="operator">|</span> <span class="keyword">SHOW</span> WARNINGS                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">8</span> <span class="operator">|</span> <span class="keyword">SET</span> TIME_ZONE<span class="operator">=</span><span class="string">&#x27;+00：00&#x27;</span>                                           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">3</span> <span class="operator">|</span> <span class="keyword">set</span> <span class="keyword">global</span> general_log <span class="operator">=</span> <span class="number">0</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+------------------------------------------------------------------+</span></span><br><span class="line"> </span><br><span class="line">根据上面信息，可以看出：</span><br><span class="line"><span class="operator">-</span>  线程<span class="number">7</span> 进行 FLUSH TABLES <span class="keyword">WITH</span> READ LOCK 。对表加一个读锁</span><br><span class="line"><span class="operator">-</span>  线程<span class="number">7</span>、<span class="number">8</span>、<span class="number">9</span>分别开启一个事务（RR隔离级别）去备份数据,由于之前锁表了,所以这三个线程备份出的数据是具有一致性的</span><br><span class="line"><span class="operator">-</span>  线程<span class="number">7</span> 解锁 UNLOCK <span class="keyword">TABLE</span></span><br><span class="line"><span class="operator">-</span>  整个过程都没有获取二进制位置点</span><br></pre></td></tr></table></figure>

<h3 id="compress-output"><a href="#compress-output" class="headerlink" title="compress-output"></a>compress-output</h3><p>mysqlpump 支持压缩输出, 支持 LZ4 和 ZLIB（ZLIB 压缩比相对较高, 但是速度较慢）</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# mysqlpump --single-transaction --compress-output=lz4 kevin --<span class="keyword">set</span>-gtid-purged=OFF <span class="comment">-p123456 &gt;</span> /tmp/<span class="comment">backup_kevin.sql</span></span><br><span class="line">Dump <span class="comment">completed in 511 milliseconds</span></span><br></pre></td></tr></table></figure>

<h3 id="备份恢复"><a href="#备份恢复" class="headerlink" title="备份恢复"></a>备份恢复</h3><p>未压缩的备份</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&lt;</span> source <span class="operator">/</span>tmp<span class="operator">/</span>backup.sql;</span><br></pre></td></tr></table></figure>

<p>压缩过的备份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">先解压</span><br><span class="line">[root@localhost ~]# lz4_decompress /tmp/backup_kevin.sql /tmp/kevin.sql</span><br><span class="line"></span><br><span class="line">再导入</span><br><span class="line">mysql &lt; source /tmp/kevin.sql;</span><br></pre></td></tr></table></figure>

<p>可以看出来, 这个导入是单线程。<strong>mysqlpump 备份的数据恢复时会先插入数据, 再建索引, 而 mysqldump 备份的数据恢复是在建立表的时候就把索引加上了, 所以前者备份的数据恢复时速度要快一点！</strong></p>
<p>总体来说 mysqlpump 还是很好用的，尤其是多数据库表的备份。不过如果有一张表格外大，那么备份的大部分时间还是要消耗在这张表上，因为 mysqlpump 的备份是基于表并行的，对于每张表的导出只能是单个线程的。另外<strong>注意 mysqlpump 备份时并发线程的数量还是要看自身服务器的 IO 负载能力，并不是说一味的增加并发线程数量就可以加快速度。</strong>mysqldump 和 mysqlpump 的使用方法绝大部分一致，mysqlpump 新的参数文章上已经标明，到底用那种工具备份数据库这个要在具体的环境下才能做出选择，有些时候可能用物理备份更好（xtrabackup），总之根据需要进行测试，最后再决定使用哪种备份工具进行备份。</p>
<blockquote>
<p>原文地址 <a href="https://www.cnblogs.com/kevingrace/p/9760185.html">https://www.cnblogs.com/kevingrace/p/9760185.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>备份</tag>
      </tags>
  </entry>
</search>
