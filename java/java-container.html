<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiaojianzheng.cn","root":"/","images":"/images","scheme":"Gemini","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}};
  </script>
<meta name="description" content="一、概览容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 Collection 1. Set TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet">
<meta property="og:type" content="website">
<meta property="og:title" content="JIAHE">
<meta property="og:url" content="https://xiaojianzheng.cn/java/java-container.html">
<meta property="og:site_name" content="JIAHE">
<meta property="og:description" content="一、概览容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 Collection 1. Set TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208220948084.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201101234335837.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208225301973.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208232221265.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208233940066.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208234948205.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208235258643.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191209001038024.png">
<meta property="article:published_time" content="2021-04-20T12:36:11.341Z">
<meta property="article:modified_time" content="2021-04-20T12:36:11.341Z">
<meta property="article:author" content="JIAHE">
<meta property="article:tag" content="JIAHE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208220948084.png">


<link rel="canonical" href="https://xiaojianzheng.cn/java/java-container">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title> | JIAHE
</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">JIAHE</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-navigation"><a href="/navigation/" rel="section"><i class="fa fa-location-arrow fa-fw"></i>导航</a></li>
        <li class="menu-item menu-item-巨人的肩膀"><a href="/experience/" rel="section"><i class="fa fa-lightbulb fa-fw"></i>巨人的肩膀</a></li>
        
            
  <li class="menu-item menu-item-java"><a href="/java/" rel="section"><i class="fa fa-code fa-fw"></i>Java</a></li>


      
        <li class="menu-item menu-item-代码可读性"><a href="/code-easy-read/" rel="section"><i class="far fa-file-code fa-fw"></i>代码可读性</a></li>
        
            
  <li class="menu-item menu-item-数据库"><a href="/database/" rel="section"><i class="fas fa-database fa-fw"></i>数据库</a></li>


      
        
            
  <li class="menu-item menu-item-计算机网络"><a href="/network/" rel="section"><i class="fas fa-network-wired fa-fw"></i>计算机网络</a></li>


      
        
            
  <li class="menu-item menu-item-操作系统基础"><a href="/os/" rel="section"><i class="fas fa-laptop fa-fw"></i>操作系统基础</a></li>


      
        
            
  <li class="menu-item menu-item-基础概念"><a href="/basic-concepts/" rel="section"><i class="fas fa-star fa-fw"></i>基础概念</a></li>


      
        <li class="menu-item menu-item-git基础"><a href="/git-basics/" rel="section"><i class="fab fa-git-alt fa-fw"></i>Git基础</a></li>
        <li class="menu-item menu-item-vim-cheat-sheet"><a href="/vim-cheat-sheet/" rel="section"><i class="fab fa-vimeo-square fa-fw"></i>Vim Cheat Sheet</a></li>
        <li class="menu-item menu-item-常用软件"><a href="/windows-software-cheat-sheet/" rel="section"><i class="fab fa-windows fa-fw"></i>常用软件</a></li>
        <li class="menu-item menu-item-html元素参考"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element" rel="noopener" target="_blank"><i class="fab fa-html5 fa-fw"></i>HTML元素参考</a></li>
        <li class="menu-item menu-item-css-参考"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference" rel="noopener" target="_blank"><i class="fab fa-css3-alt fa-fw"></i>CSS 参考</a></li>
        <li class="menu-item menu-item-javascript-参考"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference" rel="noopener" target="_blank"><i class="fab fa-js-square fa-fw"></i>JavaScript 参考</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%A7%88"><span class="nav-number">1.</span> <span class="nav-text">一、概览</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection"><span class="nav-number">1.1.</span> <span class="nav-text">Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Set"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-List"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Queue"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. Queue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">1.2.</span> <span class="nav-text">Map</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">二、容器中的设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">迭代器模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">适配器模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">三、源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList"><span class="nav-number">3.1.</span> <span class="nav-text">ArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A6%82%E8%A7%88"><span class="nav-number">3.1.1.</span> <span class="nav-text">1. 概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%89%A9%E5%AE%B9"><span class="nav-number">3.1.2.</span> <span class="nav-text">2. 扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">3.1.3.</span> <span class="nav-text">3. 删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">3.1.4.</span> <span class="nav-text">4. 序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Fail-Fast"><span class="nav-number">3.1.5.</span> <span class="nav-text">5. Fail-Fast</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vector"><span class="nav-number">3.2.</span> <span class="nav-text">Vector</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%90%8C%E6%AD%A5"><span class="nav-number">3.2.1.</span> <span class="nav-text">1. 同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%89%A9%E5%AE%B9-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">2. 扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%B8%8E-ArrayList-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">3.2.3.</span> <span class="nav-text">3. 与 ArrayList 的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="nav-number">3.2.4.</span> <span class="nav-text">4. 替代方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">3.3.</span> <span class="nav-text">CopyOnWriteArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-number">3.3.1.</span> <span class="nav-text">1. 读写分离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.3.2.</span> <span class="nav-text">2. 适用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedList"><span class="nav-number">3.4.</span> <span class="nav-text">LinkedList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A6%82%E8%A7%88-1"><span class="nav-number">3.4.1.</span> <span class="nav-text">1. 概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%8E-ArrayList-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">3.4.2.</span> <span class="nav-text">2. 与 ArrayList 的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">3.5.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.5.1.</span> <span class="nav-text">1. 存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8B%89%E9%93%BE%E6%B3%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">3.5.2.</span> <span class="nav-text">2. 拉链法的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-put-%E6%93%8D%E4%BD%9C"><span class="nav-number">3.5.3.</span> <span class="nav-text">3. put 操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%A1%AE%E5%AE%9A%E6%A1%B6%E4%B8%8B%E6%A0%87"><span class="nav-number">3.5.4.</span> <span class="nav-text">4. 确定桶下标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%89%A9%E5%AE%B9-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">3.5.5.</span> <span class="nav-text">5. 扩容-基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%89%A9%E5%AE%B9-%E9%87%8D%E6%96%B0%E8%AE%A1%E7%AE%97%E6%A1%B6%E4%B8%8B%E6%A0%87"><span class="nav-number">3.5.6.</span> <span class="nav-text">6. 扩容-重新计算桶下标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E8%AE%A1%E7%AE%97%E6%95%B0%E7%BB%84%E5%AE%B9%E9%87%8F"><span class="nav-number">3.5.7.</span> <span class="nav-text">7. 计算数组容量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">3.5.8.</span> <span class="nav-text">8. 链表转红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E4%B8%8E-Hashtable-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">3.5.9.</span> <span class="nav-text">9. 与 Hashtable 的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">3.6.</span> <span class="nav-text">ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-1"><span class="nav-number">3.6.1.</span> <span class="nav-text">1. 存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-size-%E6%93%8D%E4%BD%9C"><span class="nav-number">3.6.2.</span> <span class="nav-text">2. size 操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-JDK-1-8-%E7%9A%84%E6%94%B9%E5%8A%A8"><span class="nav-number">3.6.3.</span> <span class="nav-text">3. JDK 1.8 的改动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">3.7.</span> <span class="nav-text">LinkedHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.7.1.</span> <span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#afterNodeAccess"><span class="nav-number">3.7.2.</span> <span class="nav-text">afterNodeAccess()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#afterNodeInsertion"><span class="nav-number">3.7.3.</span> <span class="nav-text">afterNodeInsertion()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LRU-%E7%BC%93%E5%AD%98"><span class="nav-number">3.7.4.</span> <span class="nav-text">LRU 缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WeakHashMap"><span class="nav-number">3.8.</span> <span class="nav-text">WeakHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-1"><span class="nav-number">3.8.1.</span> <span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentCache"><span class="nav-number">3.8.2.</span> <span class="nav-text">ConcurrentCache</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">4.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">JIAHE</p>
  <div class="site-description" itemprop="description">Collection & Reuse</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner page posts-expand">
  

      

        
        <ul class="sub-menu menu">
          
            
          
          
              
  <li class="menu-item menu-item-java基础"><a href="/java/index.html" rel="section">Java基础</a></li>


          
          
              
  <li class="menu-item menu-item-java容器"><a href="/java/java-container.html" rel="section">Java容器</a></li>


          
          
              
  <li class="menu-item menu-item-java并发"><a href="/java/java-concurrent.html" rel="section">Java并发</a></li>


          
          
              
  <li class="menu-item menu-item-java虚拟机"><a href="/java/java-jvm.html" rel="section">Java虚拟机</a></li>


          
          
              
  <li class="menu-item menu-item-java-i/o"><a href="/java/java-io.html" rel="section">Java I/O</a></li>


          
        </ul>
        

        
        
      

      
      

      
      

      
      

      
      
  


    
    
    
    <div class="post-block" lang="zh-CN"><header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta-container">
</div>

</header>

      
      
      <div class="post-body">
          <h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208220948084.png" alt="img"></p>
<h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h3><ul>
<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</li>
</ul>
<h3 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h3><ul>
<li>ArrayList：基于动态数组实现，支持随机访问。</li>
<li>Vector：和 ArrayList 类似，但它是线程安全的。</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<h3 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a>3. Queue</h3><ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201101234335837.png" alt="img"></p>
<ul>
<li>TreeMap：基于红黑树实现。</li>
<li>HashMap：基于哈希表实现。</li>
<li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>
</ul>
<h1 id="二、容器中的设计模式"><a href="#二、容器中的设计模式" class="headerlink" title="二、容器中的设计模式"></a>二、容器中的设计模式</h1><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208225301973.png" alt="img"></p>
<p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();
list.add(&quot;a&quot;);
list.add(&quot;b&quot;);
for (String item : list) &#123;
    System.out.println(item);
&#125;</code></pre>

<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@SafeVarargs
public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code></pre>

<p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Integer[] arr &#x3D; &#123;1, 2, 3&#125;;
List list &#x3D; Arrays.asList(arr);</code></pre>

<p>也可以使用以下方式调用 asList()：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">List list &#x3D; Arrays.asList(1, 2, 3);</code></pre>

<h1 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h1><p>如果没有特别说明，以下源码分析基于 JDK 1.8。</p>
<p>在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h3><p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code></pre>

<p>数组的默认大小为 10。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private static final int DEFAULT_CAPACITY &#x3D; 10;</code></pre>

<p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208232221265.png" alt="img"></p>
<h3 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2. 扩容"></a>2. 扩容</h3><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，即 oldCapacity+oldCapacity/2。其中 oldCapacity &gt;&gt; 1 需要取整，所以新容量大约是旧容量的 1.5 倍左右。（oldCapacity 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5）</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean add(E e) &#123;
    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!
    elementData[size++] &#x3D; e;
    return true;
&#125;

private void ensureCapacityInternal(int minCapacity) &#123;
    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;
        minCapacity &#x3D; Math.max(DEFAULT_CAPACITY, minCapacity);
    &#125;
    ensureExplicitCapacity(minCapacity);
&#125;

private void ensureExplicitCapacity(int minCapacity) &#123;
    modCount++;
    &#x2F;&#x2F; overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
&#125;

private void grow(int minCapacity) &#123;
    &#x2F;&#x2F; overflow-conscious code
    int oldCapacity &#x3D; elementData.length;
    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity &#x3D; minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity &#x3D; hugeCapacity(minCapacity);
    &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:
    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);
&#125;</code></pre>

<h3 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3. 删除元素"></a>3. 删除元素</h3><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public E remove(int index) &#123;
    rangeCheck(index);
    modCount++;
    E oldValue &#x3D; elementData(index);
    int numMoved &#x3D; size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work
    return oldValue;
&#125;</code></pre>

<h3 id="4-序列化"><a href="#4-序列化" class="headerlink" title="4. 序列化"></a>4. 序列化</h3><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>
<p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">transient Object[] elementData; &#x2F;&#x2F; non-private to simplify nested class access</code></pre>

<p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException &#123;
    elementData &#x3D; EMPTY_ELEMENTDATA;

    &#x2F;&#x2F; Read in size, and any hidden stuff
    s.defaultReadObject();

    &#x2F;&#x2F; Read in capacity
    s.readInt(); &#x2F;&#x2F; ignored

    if (size &gt; 0) &#123;
        &#x2F;&#x2F; be like clone(), allocate array based upon size not capacity
        ensureCapacityInternal(size);

        Object[] a &#x3D; elementData;
        &#x2F;&#x2F; Read in all elements in the proper order.
        for (int i&#x3D;0; i&lt;size; i++) &#123;
            a[i] &#x3D; s.readObject();
        &#125;
    &#125;
&#125;
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException&#123;
    &#x2F;&#x2F; Write out element count, and any hidden stuff
    int expectedModCount &#x3D; modCount;
    s.defaultWriteObject();

    &#x2F;&#x2F; Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    &#x2F;&#x2F; Write out all elements in the proper order.
    for (int i&#x3D;0; i&lt;size; i++) &#123;
        s.writeObject(elementData[i]);
    &#125;

    if (modCount !&#x3D; expectedModCount) &#123;
        throw new ConcurrentModificationException();
    &#125;
&#125;</code></pre>

<p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">ArrayList list &#x3D; new ArrayList();
ObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(file));
oos.writeObject(list);</code></pre>

<h3 id="5-Fail-Fast"><a href="#5-Fail-Fast" class="headerlink" title="5. Fail-Fast"></a>5. Fail-Fast</h3><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><h3 id="1-同步"><a href="#1-同步" class="headerlink" title="1. 同步"></a>1. 同步</h3><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public synchronized boolean add(E e) &#123;
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] &#x3D; e;
    return true;
&#125;

public synchronized E get(int index) &#123;
    if (index &gt;&#x3D; elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
&#125;</code></pre>

<h3 id="2-扩容-1"><a href="#2-扩容-1" class="headerlink" title="2. 扩容"></a>2. 扩容</h3><p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public Vector(int initialCapacity, int capacityIncrement) &#123;
    super();
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    this.elementData &#x3D; new Object[initialCapacity];
    this.capacityIncrement &#x3D; capacityIncrement;
&#125;
private void grow(int minCapacity) &#123;
    &#x2F;&#x2F; overflow-conscious code
    int oldCapacity &#x3D; elementData.length;
    int newCapacity &#x3D; oldCapacity + ((capacityIncrement &gt; 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity &#x3D; minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity &#x3D; hugeCapacity(minCapacity);
    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);
&#125;</code></pre>

<p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public Vector(int initialCapacity) &#123;
    this(initialCapacity, 0);
&#125;

public Vector() &#123;
    this(10);
&#125;</code></pre>

<h3 id="3-与-ArrayList-的比较"><a href="#3-与-ArrayList-的比较" class="headerlink" title="3. 与 ArrayList 的比较"></a>3. 与 ArrayList 的比较</h3><ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li>
</ul>
<h3 id="4-替代方案"><a href="#4-替代方案" class="headerlink" title="4. 替代方案"></a>4. 替代方案</h3><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();
List&lt;String&gt; synList &#x3D; Collections.synchronizedList(list);</code></pre>

<p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;String&gt; list &#x3D; new CopyOnWriteArrayList&lt;&gt;();</code></pre>

<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h3 id="1-读写分离"><a href="#1-读写分离" class="headerlink" title="1. 读写分离"></a>1. 读写分离</h3><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean add(E e) &#123;
    final ReentrantLock lock &#x3D; this.lock;
    lock.lock();
    try &#123;
        Object[] elements &#x3D; getArray();
        int len &#x3D; elements.length;
        Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);
        newElements[len] &#x3D; e;
        setArray(newElements);
        return true;
    &#125; finally &#123;
        lock.unlock();
    &#125;
&#125;

final void setArray(Object[] a) &#123;
    array &#x3D; a;
&#125;
@SuppressWarnings(&quot;unchecked&quot;)
private E get(Object[] a, int index) &#123;
    return (E) a[index];
&#125;</code></pre>

<h3 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h3><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="1-概览-1"><a href="#1-概览-1" class="headerlink" title="1. 概览"></a>1. 概览</h3><p>基于双向链表实现，使用 Node 存储链表节点信息。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private static class Node&lt;E&gt; &#123;
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;
&#125;</code></pre>

<p>每个链表存储了 first 和 last 指针：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">transient Node&lt;E&gt; first;
transient Node&lt;E&gt; last;</code></pre>

<p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208233940066.png" alt="img"></p>
<h3 id="2-与-ArrayList-的比较"><a href="#2-与-ArrayList-的比较" class="headerlink" title="2. 与 ArrayList 的比较"></a>2. 与 ArrayList 的比较</h3><p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：</p>
<ul>
<li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li>
<li>链表不支持随机访问，但插入删除只需要改变指针。</li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>为了便于理解，以下源码分析以 JDK 1.7 为主。</p>
<h3 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p>内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p>
<p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208234948205.png" alt="img"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">transient Entry[] table;
static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
    final K key;
    V value;
    Entry&lt;K,V&gt; next;
    int hash;

    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;
        value &#x3D; v;
        next &#x3D; n;
        key &#x3D; k;
        hash &#x3D; h;
    &#125;

    public final K getKey() &#123;
        return key;
    &#125;

    public final V getValue() &#123;
        return value;
    &#125;

    public final V setValue(V newValue) &#123;
        V oldValue &#x3D; value;
        value &#x3D; newValue;
        return oldValue;
    &#125;

    public final boolean equals(Object o) &#123;
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry e &#x3D; (Map.Entry)o;
        Object k1 &#x3D; getKey();
        Object k2 &#x3D; e.getKey();
        if (k1 &#x3D;&#x3D; k2 || (k1 !&#x3D; null &amp;&amp; k1.equals(k2))) &#123;
            Object v1 &#x3D; getValue();
            Object v2 &#x3D; e.getValue();
            if (v1 &#x3D;&#x3D; v2 || (v1 !&#x3D; null &amp;&amp; v1.equals(v2)))
                return true;
        &#125;
        return false;
    &#125;

    public final int hashCode() &#123;
        return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());
    &#125;

    public final String toString() &#123;
        return getKey() + &quot;&#x3D;&quot; + getValue();
    &#125;
&#125;</code></pre>

<h3 id="2-拉链法的工作原理"><a href="#2-拉链法的工作原理" class="headerlink" title="2. 拉链法的工作原理"></a>2. 拉链法的工作原理</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();
map.put(&quot;K1&quot;, &quot;V1&quot;);
map.put(&quot;K2&quot;, &quot;V2&quot;);
map.put(&quot;K3&quot;, &quot;V3&quot;);</code></pre>

<ul>
<li>新建一个 HashMap，默认大小为 16；</li>
<li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</li>
<li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</li>
<li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</li>
</ul>
<p>应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p>
<p>查找需要分成两步进行：</p>
<ul>
<li>计算键值对所在的桶；</li>
<li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li>
</ul>
<p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208235258643.png" alt="img"></p>
<h3 id="3-put-操作"><a href="#3-put-操作" class="headerlink" title="3. put 操作"></a>3. put 操作</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public V put(K key, V value) &#123;
    if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;
        inflateTable(threshold);
    &#125;
    &#x2F;&#x2F; 键为 null 单独处理
    if (key &#x3D;&#x3D; null)
        return putForNullKey(value);
    int hash &#x3D; hash(key);
    &#x2F;&#x2F; 确定桶下标
    int i &#x3D; indexFor(hash, table.length);
    &#x2F;&#x2F; 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value
    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;
        Object k;
        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;
            V oldValue &#x3D; e.value;
            e.value &#x3D; value;
            e.recordAccess(this);
            return oldValue;
        &#125;
    &#125;

    modCount++;
    &#x2F;&#x2F; 插入新键值对
    addEntry(hash, key, value, i);
    return null;
&#125;</code></pre>

<p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private V putForNullKey(V value) &#123;
    for (Entry&lt;K,V&gt; e &#x3D; table[0]; e !&#x3D; null; e &#x3D; e.next) &#123;
        if (e.key &#x3D;&#x3D; null) &#123;
            V oldValue &#x3D; e.value;
            e.value &#x3D; value;
            e.recordAccess(this);
            return oldValue;
        &#125;
    &#125;
    modCount++;
    addEntry(0, null, value, 0);
    return null;
&#125;</code></pre>

<p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) &#123;
    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;
        resize(2 * table.length);
        hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;
        bucketIndex &#x3D; indexFor(hash, table.length);
    &#125;

    createEntry(hash, key, value, bucketIndex);
&#125;

void createEntry(int hash, K key, V value, int bucketIndex) &#123;
    Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];
    &#x2F;&#x2F; 头插法，链表头部指向新的键值对
    table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);
    size++;
&#125;
Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;
    value &#x3D; v;
    next &#x3D; n;
    key &#x3D; k;
    hash &#x3D; h;
&#125;</code></pre>

<h3 id="4-确定桶下标"><a href="#4-确定桶下标" class="headerlink" title="4. 确定桶下标"></a>4. 确定桶下标</h3><p>很多操作都需要先确定一个键值对所在的桶下标。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int hash &#x3D; hash(key);
int i &#x3D; indexFor(hash, table.length);</code></pre>

<p><strong>4.1 计算 hash 值</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">final int hash(Object k) &#123;
    int h &#x3D; hashSeed;
    if (0 !&#x3D; h &amp;&amp; k instanceof String) &#123;
        return sun.misc.Hashing.stringHash32((String) k);
    &#125;

    h ^&#x3D; k.hashCode();

    &#x2F;&#x2F; This function ensures that hashCodes that differ only by
    &#x2F;&#x2F; constant multiples at each bit position have a bounded
    &#x2F;&#x2F; number of collisions (approximately 8 at default load factor).
    h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
&#125;
public final int hashCode() &#123;
    return Objects.hashCode(key) ^ Objects.hashCode(value);
&#125;</code></pre>

<p><strong>4.2 取模</strong></p>
<p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">x   : 00010000
x-1 : 00001111</code></pre>

<p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">y       : 10110010
x-1     : 00001111
y&amp;(x-1) : 00000010</code></pre>

<p>这个性质和 y 对 x 取模效果是一样的：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">y   : 10110010
x   : 00010000
y%x : 00000010</code></pre>

<p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">static int indexFor(int h, int length) &#123;
    return h &amp; (length-1);
&#125;</code></pre>

<h3 id="5-扩容-基本原理"><a href="#5-扩容-基本原理" class="headerlink" title="5. 扩容-基本原理"></a>5. 扩容-基本原理</h3><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">capacity</td>
<td align="left">table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td align="center">size</td>
<td align="left">键值对数量。</td>
</tr>
<tr>
<td align="center">threshold</td>
<td align="left">size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td>
</tr>
<tr>
<td align="center">loadFactor</td>
<td align="left">装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 16;

static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;

static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;

transient Entry[] table;

transient int size;

int threshold;

final float loadFactor;

transient int modCount;</code></pre>

<p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) &#123;
    Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];
    table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);
    if (size++ &gt;&#x3D; threshold)
        resize(2 * table.length);
&#125;</code></pre>

<p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">void resize(int newCapacity) &#123;
    Entry[] oldTable &#x3D; table;
    int oldCapacity &#x3D; oldTable.length;
    if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;
        threshold &#x3D; Integer.MAX_VALUE;
        return;
    &#125;
    Entry[] newTable &#x3D; new Entry[newCapacity];
    transfer(newTable);
    table &#x3D; newTable;
    threshold &#x3D; (int)(newCapacity * loadFactor);
&#125;

void transfer(Entry[] newTable) &#123;
    Entry[] src &#x3D; table;
    int newCapacity &#x3D; newTable.length;
    for (int j &#x3D; 0; j &lt; src.length; j++) &#123;
        Entry&lt;K,V&gt; e &#x3D; src[j];
        if (e !&#x3D; null) &#123;
            src[j] &#x3D; null;
            do &#123;
                Entry&lt;K,V&gt; next &#x3D; e.next;
                int i &#x3D; indexFor(e.hash, newCapacity);
                e.next &#x3D; newTable[i];
                newTable[i] &#x3D; e;
                e &#x3D; next;
            &#125; while (e !&#x3D; null);
        &#125;
    &#125;
&#125;</code></pre>

<h3 id="6-扩容-重新计算桶下标"><a href="#6-扩容-重新计算桶下标" class="headerlink" title="6. 扩容-重新计算桶下标"></a>6. 扩容-重新计算桶下标</h3><p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。</p>
<p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">capacity     : 00010000
new capacity : 00100000</code></pre>

<p>对于一个 Key，它的哈希值 hash 在第 5 位：</p>
<ul>
<li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；</li>
<li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。</li>
</ul>
<h3 id="7-计算数组容量"><a href="#7-计算数组容量" class="headerlink" title="7. 计算数组容量"></a>7. 计算数组容量</h3><p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p>
<p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">mask |&#x3D; mask &gt;&gt; 1    11011000
mask |&#x3D; mask &gt;&gt; 2    11111110
mask |&#x3D; mask &gt;&gt; 4    11111111</code></pre>

<p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">num     10010000
mask+1 100000000</code></pre>

<p>以下是 HashMap 中计算数组容量的代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">static final int tableSizeFor(int cap) &#123;
    int n &#x3D; cap - 1;
    n |&#x3D; n &gt;&gt;&gt; 1;
    n |&#x3D; n &gt;&gt;&gt; 2;
    n |&#x3D; n &gt;&gt;&gt; 4;
    n |&#x3D; n &gt;&gt;&gt; 8;
    n |&#x3D; n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
&#125;</code></pre>

<h3 id="8-链表转红黑树"><a href="#8-链表转红黑树" class="headerlink" title="8. 链表转红黑树"></a>8. 链表转红黑树</h3><p>从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。</p>
<h3 id="9-与-Hashtable-的比较"><a href="#9-与-Hashtable-的比较" class="headerlink" title="9. 与 Hashtable 的比较"></a>9. 与 Hashtable 的比较</h3><ul>
<li>Hashtable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="1-存储结构-1"><a href="#1-存储结构-1" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191209001038024.png" alt="img"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">static final class HashEntry&lt;K,V&gt; &#123;
    final int hash;
    final K key;
    volatile V value;
    volatile HashEntry&lt;K,V&gt; next;
&#125;</code></pre>

<p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p>
<p>Segment 继承自 ReentrantLock。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;

    private static final long serialVersionUID &#x3D; 2249069246763182397L;

    static final int MAX_SCAN_RETRIES &#x3D;
        Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;

    transient volatile HashEntry&lt;K,V&gt;[] table;

    transient int count;

    transient int modCount;

    transient int threshold;

    final float loadFactor;
&#125;
final Segment&lt;K,V&gt;[] segments;</code></pre>

<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;</code></pre>

<h3 id="2-size-操作"><a href="#2-size-操作" class="headerlink" title="2. size 操作"></a>2. size 操作</h3><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * The number of elements. Accessed only either within locks
 * or among other volatile reads that maintain visibility.
 *&#x2F;
transient int count;</code></pre>

<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Number of unsynchronized retries in size and containsValue
 * methods before resorting to locking. This is used to avoid
 * unbounded retries if tables undergo continuous modification
 * which would make it impossible to obtain an accurate result.
 *&#x2F;
static final int RETRIES_BEFORE_LOCK &#x3D; 2;

public int size() &#123;
    &#x2F;&#x2F; Try a few times to get accurate count. On failure due to
    &#x2F;&#x2F; continuous async changes in table, resort to locking.
    final Segment&lt;K,V&gt;[] segments &#x3D; this.segments;
    int size;
    boolean overflow; &#x2F;&#x2F; true if size overflows 32 bits
    long sum;         &#x2F;&#x2F; sum of modCounts
    long last &#x3D; 0L;   &#x2F;&#x2F; previous sum
    int retries &#x3D; -1; &#x2F;&#x2F; first iteration isn&#39;t retry
    try &#123;
        for (;;) &#123;
            &#x2F;&#x2F; 超过尝试次数，则对每个 Segment 加锁
            if (retries++ &#x3D;&#x3D; RETRIES_BEFORE_LOCK) &#123;
                for (int j &#x3D; 0; j &lt; segments.length; ++j)
                    ensureSegment(j).lock(); &#x2F;&#x2F; force creation
            &#125;
            sum &#x3D; 0L;
            size &#x3D; 0;
            overflow &#x3D; false;
            for (int j &#x3D; 0; j &lt; segments.length; ++j) &#123;
                Segment&lt;K,V&gt; seg &#x3D; segmentAt(segments, j);
                if (seg !&#x3D; null) &#123;
                    sum +&#x3D; seg.modCount;
                    int c &#x3D; seg.count;
                    if (c &lt; 0 || (size +&#x3D; c) &lt; 0)
                        overflow &#x3D; true;
                &#125;
            &#125;
            &#x2F;&#x2F; 连续两次得到的结果一致，则认为这个结果是正确的
            if (sum &#x3D;&#x3D; last)
                break;
            last &#x3D; sum;
        &#125;
    &#125; finally &#123;
        if (retries &gt; RETRIES_BEFORE_LOCK) &#123;
            for (int j &#x3D; 0; j &lt; segments.length; ++j)
                segmentAt(segments, j).unlock();
        &#125;
    &#125;
    return overflow ? Integer.MAX_VALUE : size;
&#125;</code></pre>

<h3 id="3-JDK-1-8-的改动"><a href="#3-JDK-1-8-的改动" class="headerlink" title="3. JDK 1.8 的改动"></a>3. JDK 1.8 的改动</h3><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p>
<p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p>
<p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;</code></pre>

<p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * The head (eldest) of the doubly linked list.
 *&#x2F;
transient LinkedHashMap.Entry&lt;K,V&gt; head;

&#x2F;**
 * The tail (youngest) of the doubly linked list.
 *&#x2F;
transient LinkedHashMap.Entry&lt;K,V&gt; tail;</code></pre>

<p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">final boolean accessOrder;</code></pre>

<p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;
void afterNodeInsertion(boolean evict) &#123; &#125;</code></pre>

<h3 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h3><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last
    LinkedHashMap.Entry&lt;K,V&gt; last;
    if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;
        LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;
        p.after &#x3D; null;
        if (b &#x3D;&#x3D; null)
            head &#x3D; a;
        else
            b.after &#x3D; a;
        if (a !&#x3D; null)
            a.before &#x3D; b;
        else
            last &#x3D; b;
        if (last &#x3D;&#x3D; null)
            head &#x3D; p;
        else &#123;
            p.before &#x3D; last;
            last.after &#x3D; p;
        &#125;
        tail &#x3D; p;
        ++modCount;
    &#125;
&#125;</code></pre>

<h3 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h3><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p>
<p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">void afterNodeInsertion(boolean evict) &#123; &#x2F;&#x2F; possibly remove eldest
    LinkedHashMap.Entry&lt;K,V&gt; first;
    if (evict &amp;&amp; (first &#x3D; head) !&#x3D; null &amp;&amp; removeEldestEntry(first)) &#123;
        K key &#x3D; first.key;
        removeNode(hash(key), key, null, false, true);
    &#125;
&#125;</code></pre>

<p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;
    return false;
&#125;</code></pre>

<h3 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h3><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES 为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;
    private static final int MAX_ENTRIES &#x3D; 3;

    protected boolean removeEldestEntry(Map.Entry eldest) &#123;
        return size() &gt; MAX_ENTRIES;
    &#125;

    LRUCache() &#123;
        super(MAX_ENTRIES, 0.75f, true);
    &#125;
&#125;
public static void main(String[] args) &#123;
    LRUCache&lt;Integer, String&gt; cache &#x3D; new LRUCache&lt;&gt;();
    cache.put(1, &quot;a&quot;);
    cache.put(2, &quot;b&quot;);
    cache.put(3, &quot;c&quot;);
    cache.get(1);
    cache.put(4, &quot;d&quot;);
    System.out.println(cache.keySet());
&#125;
[3, 1, 4]</code></pre>

<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p>
<p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt;</code></pre>

<h3 id="ConcurrentCache"><a href="#ConcurrentCache" class="headerlink" title="ConcurrentCache"></a>ConcurrentCache</h3><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p>
<p>ConcurrentCache 采取的是分代缓存：</p>
<ul>
<li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li>
<li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li>
<li>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li>
<li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class ConcurrentCache&lt;K, V&gt; &#123;

    private final int size;

    private final Map&lt;K, V&gt; eden;

    private final Map&lt;K, V&gt; longterm;

    public ConcurrentCache(int size) &#123;
        this.size &#x3D; size;
        this.eden &#x3D; new ConcurrentHashMap&lt;&gt;(size);
        this.longterm &#x3D; new WeakHashMap&lt;&gt;(size);
    &#125;

    public V get(K k) &#123;
        V v &#x3D; this.eden.get(k);
        if (v &#x3D;&#x3D; null) &#123;
            v &#x3D; this.longterm.get(k);
            if (v !&#x3D; null)
                this.eden.put(k, v);
        &#125;
        return v;
    &#125;

    public void put(K k, V v) &#123;
        if (this.eden.size() &gt;&#x3D; size) &#123;
            this.longterm.putAll(this.eden);
            this.eden.clear();
        &#125;
        this.eden.put(k, v);
    &#125;
&#125;</code></pre>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>Eckel B. Java 编程思想 [M]. 机械工业出版社, 2002.</li>
<li><a target="_blank" rel="noopener" href="https://www.w3resource.com/java-tutorial/java-collections.php">Java Collection Framework(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://openhome.cc/Gossip/DesignPattern/IteratorPattern.htm">Iterator 模式(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/java_hashmap.html">Java 8 系列之重新认识 HashMap(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="http://javarevisited.blogspot.hk/2010/10/difference-between-hashmap-and.html">What is difference between HashMap and Hashtable in Java?(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="http://www.zhangchangle.com/2018/02/07/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap/">Java 集合之 HashMap(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="http://www.programering.com/a/MDO3QDNwATM.html">The principle of ConcurrentHashMap analysis(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/">探索 ConcurrentHashMap 高并发性的实现机制(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/75adf47958a7">HashMap 相关面试题及其解答(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtysix.html">Java 集合细节（二）：asList 的缺陷(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="http://javaconceptoftheday.com/java-collection-framework-linkedlist-class/">Java Collection Framework – The LinkedList Class</a></li>
</ul>

      </div>
      
      
      
    </div>

    
    



<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JIAHE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/local-search.js"></script>



<script>
if (document.querySelectorAll('.pdf-container').length) {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/pdfobject@2.2.4/pdfobject.min.js', () => {
    document.querySelectorAll('.pdf-container').forEach(element => {
      PDFObject.embed(element.dataset.target, element, {
        pdfOpenParams: {
          navpanes : 0,
          toolbar  : 0,
          statusbar: 0,
          pagemode : 'thumbs',
          view     : 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height   : element.dataset.height
      });
    });
  }, window.PDFObject);
}
</script>



  




  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.1.0/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink.listen({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://xiaojianzheng.cn/java/java-container.html',]
      });
      });
  </script>

</body>
</html>
