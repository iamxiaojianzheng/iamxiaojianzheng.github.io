<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"blog.xiaojianzheng.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><meta name="description" content="原文地址 https:&#x2F;&#x2F;mybatis.org&#x2F;mybatis-3&#x2F;zh&#x2F;java-api.html  既然你已经知道如何配置 MyBatis 以及如何创建映射，是时候来尝点甜头了。MyBatis 的 Java API 就是这个甜头。稍后你将看到，和 JDBC 相比，MyBatis 大幅简化你的代码并力图保持其简洁、容易理解和维护。为了使得 SQL 映射更加优秀，MyBatis 3 引入了许多"><meta property="og:type" content="website"><meta property="og:title" content="Java API"><meta property="og:url" content="https://blog.xiaojianzheng.cn/docs/mybatis/java-api.html"><meta property="og:site_name" content="JIAHE"><meta property="og:description" content="原文地址 https:&#x2F;&#x2F;mybatis.org&#x2F;mybatis-3&#x2F;zh&#x2F;java-api.html  既然你已经知道如何配置 MyBatis 以及如何创建映射，是时候来尝点甜头了。MyBatis 的 Java API 就是这个甜头。稍后你将看到，和 JDBC 相比，MyBatis 大幅简化你的代码并力图保持其简洁、容易理解和维护。为了使得 SQL 映射更加优秀，MyBatis 3 引入了许多"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-09-25T09:21:14.791Z"><meta property="article:modified_time" content="2021-09-25T09:21:14.791Z"><meta property="article:author" content="JIAHE"><meta property="article:tag" content="JIAHE"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://blog.xiaojianzheng.cn/docs/mybatis/java-api"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":false,"lang":"zh-CN","comments":true,"permalink":"https://blog.xiaojianzheng.cn/docs/mybatis/java-api.html","path":"docs/mybatis/java-api.html","title":"Java API"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java API | JIAHE</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">JIAHE</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-导航"><a href="/navigation/" rel="section"><i class="fa fa-location-arrow fa-fw"></i>导航</a></li><li class="menu-item menu-item-文档"><a href="/docs/" rel="section"><i class="fa fa-book fa-fw fa-fw"></i>文档</a></li><li class="menu-item menu-item-cheat-sheet"><a href="/cheat-sheet/" rel="section"><i class="fas fa-pen fa-fw"></i>Cheat Sheet</a></li><li class="menu-item menu-item-软件安装部署"><a href="/software-install-and-deploy/" rel="section"><i class="fab fa-windows fa-fw"></i>软件安装部署</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">目录结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SqlSession"><span class="nav-number">2.</span> <span class="nav-text">SqlSession</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SqlSessionFactoryBuilder"><span class="nav-number">2.1.</span> <span class="nav-text">SqlSessionFactoryBuilder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SqlSessionFactory"><span class="nav-number">2.2.</span> <span class="nav-text">SqlSessionFactory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SqlSession-1"><span class="nav-number">2.3.</span> <span class="nav-text">SqlSession</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.1.</span> <span class="nav-text">语句执行方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%8B%E5%8D%B3%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.2.</span> <span class="nav-text">立即批量更新方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.3.</span> <span class="nav-text">事务控制方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="nav-number">2.3.4.</span> <span class="nav-text">本地缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E4%BF%9D-SqlSession-%E8%A2%AB%E5%85%B3%E9%97%AD"><span class="nav-number">2.3.5.</span> <span class="nav-text">确保 SqlSession 被关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%98%A0%E5%B0%84%E5%99%A8"><span class="nav-number">2.3.6.</span> <span class="nav-text">使用映射器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E5%99%A8%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.3.7.</span> <span class="nav-text">映射器注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E6%B3%A8%E8%A7%A3%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.3.8.</span> <span class="nav-text">映射注解示例</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="JIAHE" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">JIAHE</p><div class="site-description" itemprop="description">Collection & Reuse</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">63</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">71</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com&#x2F;" rel="noopener" target="_blank">Baidu</a></li><li class="links-of-blogroll-item"> <a href="https://cn.bing.com/" title="https:&#x2F;&#x2F;cn.bing.com&#x2F;" rel="noopener" target="_blank">Bing</a></li><li class="links-of-blogroll-item"> <a href="https://www.google.com/%20||%20fab%20fa-google" title="https:&#x2F;&#x2F;www.google.com&#x2F; || fab fa-google" rel="noopener" target="_blank">Google</a></li></ul></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner page posts-expand"><ul class="sub-menu menu"><li class="menu-item menu-item-基础概念"><a href="/docs/basic-concepts/" rel="section"><i class="fas fa-star fa-fw"></i>基础概念</a></li><li class="menu-item menu-item-java"><a href="/docs/java/" rel="section"><i class="fa fa-code fa-fw"></i>Java</a></li><li class="menu-item menu-item-spring"><a href="/docs/spring-framework/" rel="section"><i class="fa fa-code fa-fw"></i>Spring</a></li><li class="menu-item menu-item-mybatis3"><a href="/docs/mybatis/" rel="section"><i class="fa fa-code fa-fw"></i>Mybatis3</a></li><li class="menu-item menu-item-数据库"><a href="/docs/database/" rel="section"><i class="fas fa-database fa-fw"></i>数据库</a></li><li class="menu-item menu-item-计算机网络"><a href="/docs/network/" rel="section"><i class="fas fa-network-wired fa-fw"></i>计算机网络</a></li><li class="menu-item menu-item-操作系统基础"><a href="/docs/os/" rel="section"><i class="fas fa-laptop fa-fw"></i>操作系统基础</a></li><li class="menu-item menu-item-数据结构与算法"><a href="/docs/data-structure/" rel="section"><i class="fas fa-poll fa-fw"></i>数据结构与算法</a></li><li class="menu-item menu-item-设计模式"><a href="/docs/design-pattern/" rel="section"><i class="far fa-object-group fa-fw"></i>设计模式</a></li></ul><ul class="sub-menu menu"><li class="menu-item menu-item-入门"><a href="/docs/mybatis/index.html" rel="section">入门</a></li><li class="menu-item menu-item-xml配置"><a href="/docs/mybatis/configuration.html" rel="section">XML配置</a></li><li class="menu-item menu-item-xml映射文件"><a href="/docs/mybatis/mapping.html" rel="section">XML映射文件</a></li><li class="menu-item menu-item-动态sql"><a href="/docs/mybatis/dynamic-sql.html" rel="section">动态SQL</a></li><li class="menu-item menu-item-java-api"><a href="/docs/mybatis/java-api.html" rel="section">Java API</a></li><li class="menu-item menu-item-日志"><a href="/docs/mybatis/logging.html" rel="section">日志</a></li></ul><div class="post-block" lang="zh-CN"><header class="post-header"><h1 class="post-title" itemprop="name headline">Java API</h1><div class="post-meta-container"><ul class="breadcrumb"><li><a href="/docs/">DOCS</a></li><li><a href="/docs/mybatis/">MYBATIS</a></li><li>JAVA-API</li></ul></div></header><div class="post-body"><blockquote><p>原文地址 <a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/java-api.html">https://mybatis.org/mybatis-3/zh/java-api.html</a></p></blockquote><p>既然你已经知道如何配置 MyBatis 以及如何创建映射，是时候来尝点甜头了。MyBatis 的 Java API 就是这个甜头。稍后你将看到，和 JDBC 相比，MyBatis 大幅简化你的代码并力图保持其简洁、容易理解和维护。为了使得 SQL 映射更加优秀，MyBatis 3 引入了许多重要的改进。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>在我们深入 Java API 之前，理解关于目录结构的最佳实践是很重要的。MyBatis 非常灵活，你可以随意安排你的文件。但和其它框架一样，目录结构有一种最佳实践。</p><p>让我们看一下典型的应用目录结构：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;my_application</span><br><span class="line">  &#x2F;bin</span><br><span class="line">  &#x2F;devlib</span><br><span class="line">  &#x2F;lib                &lt;-- MyBatis *.jar 文件在这里。</span><br><span class="line">  &#x2F;src</span><br><span class="line">    &#x2F;org&#x2F;myapp&#x2F;</span><br><span class="line">      &#x2F;action</span><br><span class="line">      &#x2F;data           &lt;-- MyBatis 配置文件在这里，包括映射器类、XML 配置、XML 映射文件。</span><br><span class="line">        &#x2F;mybatis-config.xml</span><br><span class="line">        &#x2F;BlogMapper.java</span><br><span class="line">        &#x2F;BlogMapper.xml</span><br><span class="line">      &#x2F;model</span><br><span class="line">      &#x2F;service</span><br><span class="line">      &#x2F;view</span><br><span class="line">    &#x2F;properties       &lt;-- 在 XML 配置中出现的属性值在这里。</span><br><span class="line">  &#x2F;test</span><br><span class="line">    &#x2F;org&#x2F;myapp&#x2F;</span><br><span class="line">      &#x2F;action</span><br><span class="line">      &#x2F;data</span><br><span class="line">      &#x2F;model</span><br><span class="line">      &#x2F;service</span><br><span class="line">      &#x2F;view</span><br><span class="line">    &#x2F;properties</span><br><span class="line">  &#x2F;web</span><br><span class="line">    &#x2F;WEB-INF</span><br><span class="line">      &#x2F;web.xml</span><br></pre></td></tr></table></figure><p>当然，这是推荐的目录结构，并非强制要求，但使用一个通用的目录结构将更有利于大家沟通。</p><p>本章接下来的示例将假定你遵循这种目录结构。</p><h1 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h1><p>使用 MyBatis 的主要 Java 接口就是 SqlSession。你可以通过这个接口来执行命令，获取映射器实例和管理事务。在介绍 SqlSession 接口之前，我们先来了解如何获取一个 SqlSession 实例。SqlSessions 是由 SqlSessionFactory 实例创建的。SqlSessionFactory 对象包含创建 SqlSession 实例的各种方法。而 SqlSessionFactory 本身是由 SqlSessionFactoryBuilder 创建的，它可以从 XML、注解或 Java 配置代码来创建 SqlSessionFactory。</p><p><strong>提示</strong> 当 Mybatis 与一些依赖注入框架（如 Spring 或者 Guice）搭配使用时，SqlSession 将被依赖注入框架创建并注入，所以你不需要使用 SqlSessionFactoryBuilder 或者 SqlSessionFactory，可以直接阅读 SqlSession 这一节。请参考 Mybatis-Spring 或者 Mybatis-Guice 手册以了解更多信息。</p><h2 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h2><p>SqlSessionFactoryBuilder 有五个 build() 方法，每一种都允许你从不同的资源中创建一个 SqlSessionFactory 实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream)</span></span></span><br><span class="line"><span class="function">SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment)</span></span></span><br><span class="line"><span class="function">SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, Properties properties)</span></span></span><br><span class="line"><span class="function">SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String env, Properties props)</span></span></span><br><span class="line"><span class="function">SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span></span></span><br></pre></td></tr></table></figure><p>第一种方法是最常用的，它接受一个指向 XML 文件（也就是之前讨论的 mybatis-config.xml 文件）的 InputStream 实例。可选的参数是 environment 和 properties。environment 决定加载哪种环境，包括数据源和事务管理器。比如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;production&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;MANAGED&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;JNDI&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你调用了带 environment 参数的 build 方法，那么 MyBatis 将使用该环境对应的配置。当然，如果你指定了一个无效的环境，会收到错误。如果你调用了不带 environment 参数的 build 方法，那么就会使用默认的环境配置（在上面的示例中，通过 default=&quot;development&quot; 指定了默认环境）。</p><p>如果你调用了接受 properties 实例的方法，那么 MyBatis 就会加载这些属性，并在配置中提供使用。绝大多数场合下，可以用 ${propName} 形式引用这些配置值。</p><p>回想一下，在 mybatis-config.xml 中，可以引用属性值，也可以直接指定属性值。因此，理解属性的优先级是很重要的。在之前的文档中，我们已经介绍过了相关内容，但为了方便查阅，这里再重新介绍一下：</p><hr><p>如果一个属性存在于下面的多个位置，那么 MyBatis 将按照以下顺序来加载它们：</p><ul><li>首先，读取在 properties 元素体中指定的属性；</li><li>其次，读取在 properties 元素的类路径 resource 或 url 指定的属性，且会覆盖已经指定了的重复属性；</li><li>最后，读取作为方法参数传递的属性，且会覆盖已经从 properties 元素体和 resource 或 url 属性中加载了的重复属性。</li></ul><p>因此，通过方法参数传递的属性的优先级最高，resource 或 url 指定的属性优先级中等，在 properties 元素体中指定的属性优先级最低。</p><hr><p>总结一下，前四个方法很大程度上是相同的，但提供了不同的覆盖选项，允许你可选地指定 environment 和/或 properties。以下给出一个从 mybatis-config.xml 文件创建 SqlSessionFactory 的示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String resource = <span class="string">&quot;org/mybatis/builder/mybatis-config.xml&quot;</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">SqlSessionFactory factory = builder.build(inputStream);</span><br></pre></td></tr></table></figure><p>注意，这里我们使用了 Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类正如其名，会帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。在略读该类的源代码或用 IDE 查看该类信息后，你会发现一整套相当实用的方法。这里给出一个简表：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">URL <span class="title">getResourceURL</span><span class="params">(String resource)</span></span></span><br><span class="line"><span class="function">URL <span class="title">getResourceURL</span><span class="params">(ClassLoader loader, String resource)</span></span></span><br><span class="line"><span class="function">InputStream <span class="title">getResourceAsStream</span><span class="params">(String resource)</span></span></span><br><span class="line"><span class="function">InputStream <span class="title">getResourceAsStream</span><span class="params">(ClassLoader loader, String resource)</span></span></span><br><span class="line"><span class="function">Properties <span class="title">getResourceAsProperties</span><span class="params">(String resource)</span></span></span><br><span class="line"><span class="function">Properties <span class="title">getResourceAsProperties</span><span class="params">(ClassLoader loader, String resource)</span></span></span><br><span class="line"><span class="function">Reader <span class="title">getResourceAsReader</span><span class="params">(String resource)</span></span></span><br><span class="line"><span class="function">Reader <span class="title">getResourceAsReader</span><span class="params">(ClassLoader loader, String resource)</span></span></span><br><span class="line"><span class="function">File <span class="title">getResourceAsFile</span><span class="params">(String resource)</span></span></span><br><span class="line"><span class="function">File <span class="title">getResourceAsFile</span><span class="params">(ClassLoader loader, String resource)</span></span></span><br><span class="line"><span class="function">InputStream <span class="title">getUrlAsStream</span><span class="params">(String urlString)</span></span></span><br><span class="line"><span class="function">Reader <span class="title">getUrlAsReader</span><span class="params">(String urlString)</span></span></span><br><span class="line"><span class="function">Properties <span class="title">getUrlAsProperties</span><span class="params">(String urlString)</span></span></span><br><span class="line"><span class="function">Class <span class="title">classForName</span><span class="params">(String className)</span></span></span><br></pre></td></tr></table></figure><p>最后一个 build 方法接受一个 Configuration 实例。Configuration 类包含了对一个 SqlSessionFactory 实例你可能关心的所有内容。在检查配置时，Configuration 类很有用，它允许你查找和操纵 SQL 映射（但当应用开始接收请求时不推荐使用）。你之前学习过的所有配置开关都存在于 Configuration 类，只不过它们是以 Java API 形式暴露的。以下是一个简单的示例，演示如何手动配置 Configuration 实例，然后将它传递给 build() 方法来创建 SqlSessionFactory。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataSource dataSource = BaseDataTest.createBlogDataSource();</span><br><span class="line">TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</span><br><span class="line"></span><br><span class="line">Environment environment = <span class="keyword">new</span> Environment(<span class="string">&quot;development&quot;</span>, transactionFactory, dataSource);</span><br><span class="line"></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(environment);</span><br><span class="line">configuration.setLazyLoadingEnabled(<span class="keyword">true</span>);</span><br><span class="line">configuration.setEnhancementEnabled(<span class="keyword">true</span>);</span><br><span class="line">configuration.getTypeAliasRegistry().registerAlias(Blog.class);</span><br><span class="line">configuration.getTypeAliasRegistry().registerAlias(Post.class);</span><br><span class="line">configuration.getTypeAliasRegistry().registerAlias(Author.class);</span><br><span class="line">configuration.addMapper(BoundBlogMapper.class);</span><br><span class="line">configuration.addMapper(BoundAuthorMapper.class);</span><br><span class="line"></span><br><span class="line">SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">SqlSessionFactory factory = builder.build(configuration);</span><br></pre></td></tr></table></figure><p>现在你就获得一个可以用来创建 SqlSession 实例的 SqlSessionFactory 了。</p><h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><p>SqlSessionFactory 有六个方法创建 SqlSession 实例。通常来说，当你选择其中一个方法时，你需要考虑以下几点：</p><ul><li><strong>事务处理</strong>：你希望在 session 作用域中使用事务作用域，还是使用自动提交（auto-commit）？（对很多数据库和/或 JDBC 驱动来说，等同于关闭事务支持）</li><li><strong>数据库连接</strong>：你希望 MyBatis 帮你从已配置的数据源获取连接，还是使用自己提供的连接？</li><li><strong>语句执行</strong>：你希望 MyBatis 复用 PreparedStatement 和/或批量更新语句（包括插入语句和删除语句）吗？</li></ul><p>基于以上需求，有下列已重载的多个 openSession() 方法供使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">()</span></span></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(<span class="keyword">boolean</span> autoCommit)</span></span></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(Connection connection)</span></span></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(TransactionIsolationLevel level)</span></span></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level)</span></span></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType)</span></span></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType, <span class="keyword">boolean</span> autoCommit)</span></span></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType, Connection connection)</span></span></span><br><span class="line"><span class="function">Configuration <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>默认的 openSession() 方法没有参数，它会创建具备如下特性的 SqlSession：</p><ul><li>事务作用域将会开启（也就是不自动提交）。</li><li>将由当前环境配置的 DataSource 实例中获取 Connection 对象。</li><li>事务隔离级别将会使用驱动或数据源的默认设置。</li><li>预处理语句不会被复用，也不会批量处理更新。</li></ul><p>相信你已经能从方法签名中知道这些方法的区别。向 <code>autoCommit</code> 可选参数传递 <code>true</code> 值即可开启自动提交功能。若要使用自己的 <code>Connection</code> 实例，传递一个 <code>Connection</code> 实例给 <code>connection</code> 参数即可。注意，我们没有提供同时设置 <code>Connection</code> 和 <code>autoCommit</code> 的方法，这是因为 MyBatis 会依据传入的 Connection 来决定是否启用 autoCommit。对于事务隔离级别，MyBatis 使用了一个 Java 枚举包装器来表示，称为 <code>TransactionIsolationLevel</code>，事务隔离级别支持 JDBC 的五个隔离级别（<code>NONE</code>、<code>READ_UNCOMMITTED</code>、<code>READ_COMMITTED</code>、<code>REPEATABLE_READ</code> 和 <code>SERIALIZABLE</code>），并且与预期的行为一致。</p><p>你可能对 <code>ExecutorType</code> 参数感到陌生。这个枚举类型定义了三个值:</p><ul><li><code>ExecutorType.SIMPLE</code>：该类型的执行器没有特别的行为。它为每个语句的执行创建一个新的预处理语句。</li><li><code>ExecutorType.REUSE</code>：该类型的执行器会复用预处理语句。</li><li><code>ExecutorType.BATCH</code>：该类型的执行器会批量执行所有更新语句，如果 SELECT 在多个更新中间执行，将在必要时将多条更新语句分隔开来，以方便理解。</li></ul><p><strong>提示</strong> 在 SqlSessionFactory 中还有一个方法我们没有提及，就是 getConfiguration()。这个方法会返回一个 Configuration 实例，你可以在运行时使用它来检查 MyBatis 的配置。</p><p><strong>提示</strong> 如果你使用过 MyBatis 的旧版本，可能还记得 session、事务和批量操作是相互独立的。在新版本中则不是这样。上述三者都包含在 session 作用域内。你不必分别处理事务或批量操作就能得到想要的全部效果。</p><h2 id="SqlSession-1"><a href="#SqlSession-1" class="headerlink" title="SqlSession"></a>SqlSession</h2><p>正如之前所提到的，SqlSession 在 MyBatis 中是非常强大的一个类。它包含了所有执行语句、提交或回滚事务以及获取映射器实例的方法。</p><p>SqlSession 类的方法超过了 20 个，为了方便理解，我们将它们分成几种组别。</p><h3 id="语句执行方法"><a href="#语句执行方法" class="headerlink" title="语句执行方法"></a>语句执行方法</h3><p>这些方法被用来执行定义在 SQL 映射 XML 文件中的 SELECT、INSERT、UPDATE 和 DELETE 语句。你可以通过名字快速了解它们的作用，每一方法都接受语句的 ID 以及参数对象，参数可以是原始类型（支持自动装箱或包装类）、JavaBean、POJO 或 Map。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span></span></span><br><span class="line"><span class="function">&lt;E&gt; List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Cursor&lt;T&gt; <span class="title">selectCursor</span><span class="params">(String statement, Object parameter)</span></span></span><br><span class="line"><span class="function">&lt;K,V&gt; Map&lt;K,V&gt; <span class="title">selectMap</span><span class="params">(String statement, Object parameter, String mapKey)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statement, Object parameter)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement, Object parameter)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statement, Object parameter)</span></span></span><br></pre></td></tr></table></figure><p>selectOne 和 selectList 的不同仅仅是 selectOne 必须返回一个对象或 null 值。如果返回值多于一个，就会抛出异常。如果你不知道返回对象会有多少，请使用 selectList。如果需要查看某个对象是否存在，最好的办法是查询一个 count 值（0 或 1）。selectMap 稍微特殊一点，它会将返回对象的其中一个属性作为 key 值，将对象作为 value 值，从而将多个结果集转为 Map 类型值。由于并不是所有语句都需要参数，所以这些方法都具有一个不需要参数的重载形式。</p><p>游标（Cursor）与列表（List）返回的结果相同，不同的是，游标借助迭代器实现了数据的惰性加载。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Cursor&lt;MyEntity&gt; entities = session.selectCursor(statement, param)) &#123;</span><br><span class="line">   <span class="keyword">for</span> (MyEntity entity:entities) &#123;</span><br><span class="line">       <span class="comment">// 处理单个实体</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insert、update 以及 delete 方法返回的值表示受该语句影响的行数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement)</span></span></span><br><span class="line"><span class="function">&lt;E&gt; List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Cursor&lt;T&gt; <span class="title">selectCursor</span><span class="params">(String statement)</span></span></span><br><span class="line"><span class="function">&lt;K,V&gt; Map&lt;K,V&gt; <span class="title">selectMap</span><span class="params">(String statement, String mapKey)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statement)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statement)</span></span></span><br></pre></td></tr></table></figure><p>最后，还有 select 方法的三个高级版本，它们允许你限制返回行数的范围，或是提供自定义结果处理逻辑，通常在数据集非常庞大的情形下使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span> <span class="params">(String statement, Object parameter, RowBounds rowBounds)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Cursor&lt;T&gt; <span class="title">selectCursor</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span></span></span><br><span class="line"><span class="function">&lt;K,V&gt; Map&lt;K,V&gt; <span class="title">selectMap</span><span class="params">(String statement, Object parameter, String mapKey, RowBounds rowbounds)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span> <span class="params">(String statement, Object parameter, ResultHandler&lt;T&gt; handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span> <span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler&lt;T&gt; handler)</span></span></span><br></pre></td></tr></table></figure><p>RowBounds 参数会告诉 MyBatis 略过指定数量的记录，并限制返回结果的数量。RowBounds 类的 offset 和 limit 值只有在构造函数时才能传入，其它时候是不能修改的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> offset = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> limit = <span class="number">25</span>;</span><br><span class="line">RowBounds rowBounds = <span class="keyword">new</span> RowBounds(offset, limit);</span><br></pre></td></tr></table></figure><p>数据库驱动决定了略过记录时的查询效率。为了获得最佳的性能，建议将 ResultSet 类型设置为 SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE（换句话说：不要使用 FORWARD_ONLY）。</p><p>ResultHandler 参数允许自定义每行结果的处理过程。你可以将它添加到 List 中、创建 Map 和 Set，甚至丢弃每个返回值，只保留计算后的统计结果。你可以使用 ResultHandler 做很多事，这其实就是 MyBatis 构建 结果列表的内部实现办法。</p><p>从版本 3.4.6 开始，<code>ResultHandler</code> 会在存储过程的 REFCURSOR 输出参数中传递使用的 <code>CALLABLE</code> 语句。</p><p>它的接口很简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(ResultContext&lt;? extends T&gt; context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ResultContext 参数允许你访问结果对象和当前已被创建的对象数目，另外还提供了一个返回值为 Boolean 的 stop 方法，你可以使用此 stop 方法来停止 MyBatis 加载更多的结果。</p><p>使用 ResultHandler 的时候需要注意以下两个限制：</p><ul><li>使用带 ResultHandler 参数的方法时，收到的数据不会被缓存。</li><li>当使用高级的结果映射集（resultMap）时，MyBatis 很可能需要数行结果来构造一个对象。如果你使用了 ResultHandler，你可能会接收到关联（association）或者集合（collection）中尚未被完整填充的对象。</li></ul><h3 id="立即批量更新方法"><a href="#立即批量更新方法" class="headerlink" title="立即批量更新方法"></a>立即批量更新方法</h3><p>当你将 <code>ExecutorType</code> 设置为 <code>ExecutorType.BATCH</code> 时，可以使用这个方法清除（执行）缓存在 JDBC 驱动类中的批量更新语句。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="事务控制方法"><a href="#事务控制方法" class="headerlink" title="事务控制方法"></a>事务控制方法</h3><p>有四个方法用来控制事务作用域。当然，如果你已经设置了自动提交或你使用了外部事务管理器，这些方法就没什么作用了。然而，如果你正在使用由 Connection 实例控制的 JDBC 事务管理器，那么这四个方法就会派上用场：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> force)</span></span></span><br></pre></td></tr></table></figure><p>默认情况下 MyBatis 不会自动提交事务，除非它侦测到调用了插入、更新或删除方法改变了数据库。如果你没有使用这些方法提交修改，那么你可以在 commit 和 rollback 方法参数中传入 true 值，来保证事务被正常提交（注意，在自动提交模式或者使用了外部事务管理器的情况下，设置 force 值对 session 无效）。大部分情况下你无需调用 rollback()，因为 MyBatis 会在你没有调用 commit 时替你完成回滚操作。不过，当你要在一个可能多次提交或回滚的 session 中详细控制事务，回滚操作就派上用场了。</p><p><strong>提示</strong> MyBatis-Spring 和 MyBatis-Guice 提供了声明式事务处理，所以如果你在使用 Mybatis 的同时使用了 Spring 或者 Guice，请参考它们的手册以获取更多的内容。</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>Mybatis 使用到了两种缓存：本地缓存（local cache）和二级缓存（second level cache）。</p><p>每当一个新 session 被创建，MyBatis 就会创建一个与之相关联的本地缓存。任何在 session 执行过的查询结果都会被保存在本地缓存中，所以，当再次执行参数相同的相同查询时，就不需要实际查询数据库了。本地缓存将会在做出修改、事务提交或回滚，以及关闭 session 时清空。</p><p>默认情况下，本地缓存数据的生命周期等同于整个 session 的周期。由于缓存会被用来解决循环引用问题和加快重复嵌套查询的速度，所以无法将其完全禁用。但是你可以通过设置 localCacheScope=STATEMENT 来只在语句执行时使用缓存。</p><p>注意，如果 localCacheScope 被设置为 SESSION，对于某个对象，MyBatis 将返回在本地缓存中唯一对象的引用。对返回的对象（例如 list）做出的任何修改将会影响本地缓存的内容，进而将会影响到在本次 session 中从缓存返回的值。因此，不要对 MyBatis 所返回的对象作出更改，以防后患。</p><p>你可以随时调用以下方法来清空本地缓存：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="确保-SqlSession-被关闭"><a href="#确保-SqlSession-被关闭" class="headerlink" title="确保 SqlSession 被关闭"></a>确保 SqlSession 被关闭</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>对于你打开的任何 session，你都要保证它们被妥善关闭，这很重要。保证妥善关闭的最佳代码模式是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="comment">// 假设下面三行代码是你的业务逻辑</span></span><br><span class="line">    session.insert(...);</span><br><span class="line">    session.update(...);</span><br><span class="line">    session.delete(...);</span><br><span class="line">    session.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提示</strong> 和 SqlSessionFactory 一样，你可以调用当前使用的 SqlSession 的 getConfiguration 方法来获得 Configuration 实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Configuration <span class="title">getConfiguration</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="使用映射器"><a href="#使用映射器" class="headerlink" title="使用映射器"></a>使用映射器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span></span></span><br></pre></td></tr></table></figure><p>上述的各个 insert、update、delete 和 select 方法都很强大，但也有些繁琐，它们并不符合类型安全，对你的 IDE 和单元测试也不是那么友好。因此，使用映射器类来执行映射语句是更常见的做法。</p><p>我们已经在之前的入门章节中见到过一个使用映射器的示例。一个映射器类就是一个仅需声明与 SqlSession 方法相匹配方法的接口。下面的示例展示了一些方法签名以及它们是如何映射到 SqlSession 上的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthorMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// (Author) selectOne(&quot;selectAuthor&quot;,5);</span></span><br><span class="line">    <span class="function">Author <span class="title">selectAuthor</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">// (List&lt;Author&gt;) selectList(“selectAuthors”)</span></span><br><span class="line">    <span class="function">List&lt;Author&gt; <span class="title">selectAuthors</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// (Map&lt;Integer,Author&gt;) selectMap(&quot;selectAuthors&quot;, &quot;id&quot;)</span></span><br><span class="line">    <span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">    <span class="function">Map&lt;Integer, Author&gt; <span class="title">selectAuthors</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// insert(&quot;insertAuthor&quot;, author)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertAuthor</span><span class="params">(Author author)</span></span>;</span><br><span class="line">    <span class="comment">// updateAuthor(&quot;updateAuthor&quot;, author)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateAuthor</span><span class="params">(Author author)</span></span>;</span><br><span class="line">    <span class="comment">// delete(&quot;deleteAuthor&quot;,5)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAuthor</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，每个映射器方法签名应该匹配相关联的 SqlSession 方法，字符串参数 ID 无需匹配。而是由方法名匹配映射语句的 ID。</p><p>此外，返回类型必须匹配期望的结果类型，返回单个值时，返回类型应该是返回值的类，返回多个值时，则为数组或集合类，另外也可以是游标（Cursor）。所有常用的类型都是支持的，包括：原始类型、Map、POJO 和 JavaBean。</p><p><strong>提示</strong> 映射器接口不需要去实现任何接口或继承自任何类。只要方法签名可以被用来唯一识别对应的映射语句就可以了。</p><p><strong>提示</strong> 映射器接口可以继承自其他接口。在使用 XML 来绑定映射器接口时，保证语句处于合适的命名空间中即可。唯一的限制是，不能在两个具有继承关系的接口中拥有相同的方法签名（这是潜在的危险做法，不可取）。</p><p>你可以传递多个参数给一个映射器方法。在多个参数的情况下，默认它们将会以 param 加上它们在参数列表中的位置来命名，比如：#{param1}、#{param2}等。如果你想（在有多个参数时）自定义参数的名称，那么你可以在参数上使用 @Param(&quot;paramName&quot;) 注解。</p><p>你也可以给方法传递一个 RowBounds 实例来限制查询结果。</p><h3 id="映射器注解"><a href="#映射器注解" class="headerlink" title="映射器注解"></a>映射器注解</h3><p>设计初期的 MyBatis 是一个 XML 驱动的框架。配置信息是基于 XML 的，映射语句也是定义在 XML 中的。而在 MyBatis 3 中，我们提供了其它的配置方式。MyBatis 3 构建在全面且强大的基于 Java 语言的配置 API 之上。它是 XML 和注解配置的基础。注解提供了一种简单且低成本的方式来实现简单的映射语句。</p><p><strong>提示</strong> 不幸的是，Java 注解的表达能力和灵活性十分有限。尽管我们花了很多时间在调查、设计和试验上，但最强大的 MyBatis 映射并不能用注解来构建——我们真没开玩笑。而 C# 属性就没有这些限制，因此 MyBatis.NET 的配置会比 XML 有更大的选择余地。虽说如此，基于 Java 注解的配置还是有它的好处的。</p><p><strong>注解如下表所示：</strong></p><table><thead><tr><th align="left">注解</th><th align="left">使用对象</th><th align="left">XML 等价形式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>@CacheNamespace</code></td><td align="left"><code>类</code></td><td align="left"><code>&lt;cache&gt;</code></td><td align="left">为给定的命名空间（比如类）配置缓存。属性：<code>implemetation</code>、<code>eviction</code>、<code>flushInterval</code>、<code>size</code>、<code>readWrite</code>、<code>blocking</code>、<code>properties</code>。</td></tr><tr><td align="left"><code>@Property</code></td><td align="left">N/A</td><td align="left"><code>&lt;property&gt;</code></td><td align="left">指定参数值或占位符（placeholder）（该占位符能被 <code>mybatis-config.xml</code> 内的配置属性替换）。属性：<code>name</code>、<code>value</code>。（仅在 MyBatis 3.4.2 以上可用）</td></tr><tr><td align="left"><code>@CacheNamespaceRef</code></td><td align="left"><code>类</code></td><td align="left"><code>&lt;cacheRef&gt;</code></td><td align="left">引用另外一个命名空间的缓存以供使用。注意，即使共享相同的全限定类名，在 XML 映射文件中声明的缓存仍被识别为一个独立的命名空间。属性：<code>value</code>、<code>name</code>。如果你使用了这个注解，你应设置 <code>value</code> 或者 <code>name</code> 属性的其中一个。<code>value</code> 属性用于指定能够表示该命名空间的 Java 类型（命名空间名就是该 Java 类型的全限定类名），<code>name</code> 属性（这个属性仅在 MyBatis 3.4.2 以上可用）则直接指定了命名空间的名字。</td></tr><tr><td align="left"><code>@ConstructorArgs</code></td><td align="left"><code>方法</code></td><td align="left"><code>&lt;constructor&gt;</code></td><td align="left">收集一组结果以传递给一个结果对象的构造方法。属性：<code>value</code>，它是一个 <code>Arg</code> 数组。</td></tr><tr><td align="left"><code>@Arg</code></td><td align="left">N/A</td><td align="left"><code>&lt;arg&gt;``&lt;idArg&gt;</code></td><td align="left">ConstructorArgs 集合的一部分，代表一个构造方法参数。属性：<code>id</code>、<code>column</code>、<code>javaType</code>、<code>jdbcType</code>、<code>typeHandler</code>、<code>select</code>、<code>resultMap</code>。id 属性和 XML 元素 <code>&lt;idArg&gt;</code> 相似，它是一个布尔值，表示该属性是否用于唯一标识和比较对象。从版本 3.5.4 开始，该注解变为可重复注解。</td></tr><tr><td align="left"><code>@TypeDiscriminator</code></td><td align="left"><code>方法</code></td><td align="left"><code>&lt;discriminator&gt;</code></td><td align="left">决定使用何种结果映射的一组取值（case）。属性：<code>column</code>、<code>javaType</code>、<code>jdbcType</code>、<code>typeHandler</code>、<code>cases</code>。cases 属性是一个 <code>Case</code> 的数组。</td></tr><tr><td align="left"><code>@Case</code></td><td align="left">N/A</td><td align="left"><code>&lt;case&gt;</code></td><td align="left">表示某个值的一个取值以及该取值对应的映射。属性：<code>value</code>、<code>type</code>、<code>results</code>。results 属性是一个 <code>Results</code> 的数组，因此这个注解实际上和 <code>ResultMap</code> 很相似，由下面的 <code>Results</code> 注解指定。</td></tr><tr><td align="left"><code>@Results</code></td><td align="left"><code>方法</code></td><td align="left"><code>&lt;resultMap&gt;</code></td><td align="left">一组结果映射，指定了对某个特定结果列，映射到某个属性或字段的方式。属性：<code>value</code>、<code>id</code>。value 属性是一个 <code>Result</code> 注解的数组。而 id 属性则是结果映射的名称。从版本 3.5.4 开始，该注解变为可重复注解。</td></tr><tr><td align="left"><code>@Result</code></td><td align="left">N/A</td><td align="left"><code>&lt;result&gt;``&lt;id&gt;</code></td><td align="left">在列和属性或字段之间的单个结果映射。属性：<code>id</code>、<code>column</code>、<code>javaType</code>、<code>jdbcType</code>、<code>typeHandler</code>、<code>one</code>、<code>many</code>。id 属性和 XML 元素 <code>&lt;id&gt;</code> 相似，它是一个布尔值，表示该属性是否用于唯一标识和比较对象。one 属性是一个关联，和 <code>&lt;association&gt;</code> 类似，而 many 属性则是集合关联，和 <code>&lt;collection&gt;</code> 类似。这样命名是为了避免产生名称冲突。</td></tr><tr><td align="left"><code>@One</code></td><td align="left">N/A</td><td align="left"><code>&lt;association&gt;</code></td><td align="left">复杂类型的单个属性映射。属性： <code>select</code>，指定可加载合适类型实例的映射语句（也就是映射器方法）全限定名； <code>fetchType</code>，指定在该映射中覆盖全局配置参数 <code>lazyLoadingEnabled</code>； <code>resultMap</code>(available since 3.5.5), which is the fully qualified name of a result map that map to a single container object from select result； <code>columnPrefix</code>(available since 3.5.5), which is column prefix for grouping select columns at nested result map. <strong>提示</strong> 注解 API 不支持联合映射。这是由于 Java 注解不允许产生循环引用。</td></tr><tr><td align="left"><code>@Many</code></td><td align="left">N/A</td><td align="left"><code>&lt;collection&gt;</code></td><td align="left">复杂类型的集合属性映射。属性： <code>select</code>，指定可加载合适类型实例集合的映射语句（也就是映射器方法）全限定名； <code>fetchType</code>，指定在该映射中覆盖全局配置参数 <code>lazyLoadingEnabled</code> <code>resultMap</code>(available since 3.5.5), which is the fully qualified name of a result map that map to collection object from select result； <code>columnPrefix</code>(available since 3.5.5), which is column prefix for grouping select columns at nested result map. <strong>提示</strong> 注解 API 不支持联合映射。这是由于 Java 注解不允许产生循环引用。</td></tr><tr><td align="left"><code>@MapKey</code></td><td align="left"><code>方法</code></td><td align="left"></td><td align="left">供返回值为 Map 的方法使用的注解。它使用对象的某个属性作为 key，将对象 List 转化为 Map。属性：<code>value</code>，指定作为 Map 的 key 值的对象属性名。</td></tr><tr><td align="left"><code>@Options</code></td><td align="left"><code>方法</code></td><td align="left">映射语句的属性</td><td align="left">该注解允许你指定大部分开关和配置选项，它们通常在映射语句上作为属性出现。与在注解上提供大量的属性相比，<code>Options</code> 注解提供了一致、清晰的方式来指定选项。属性：<code>useCache=true</code>、<code>flushCache=FlushCachePolicy.DEFAULT</code>、<code>resultSetType=DEFAULT</code>、<code>statementType=PREPARED</code>、<code>fetchSize=-1</code>、<code>timeout=-1</code>、<code>useGeneratedKeys=false</code>、<code>keyProperty=&quot;&quot;</code>、<code>keyColumn=&quot;&quot;</code>、<code>resultSets=&quot;&quot;</code>, <code>databaseId=&quot;&quot;</code>。注意，Java 注解无法指定 <code>null</code> 值。因此，一旦你使用了 <code>Options</code> 注解，你的语句就会被上述属性的默认值所影响。要注意避免默认值带来的非预期行为。 The <code>databaseId</code>(Available since 3.5.5), in case there is a configured <code>DatabaseIdProvider</code>, the MyBatis use the <code>Options</code> with no <code>databaseId</code> attribute or with a <code>databaseId</code> that matches the current one. If found with and without the <code>databaseId</code> the latter will be discarded. 注意：<code>keyColumn</code> 属性只在某些数据库中有效（如 Oracle、PostgreSQL 等）。要了解更多关于 <code>keyColumn</code> 和 <code>keyProperty</code> 可选值信息，请查看“insert, update 和 delete”一节。</td></tr><tr><td align="left"><code>@Insert</code><br><code>@Update</code><br><code>@Delete</code><br><code>@Select</code></td><td align="left"><code>方法</code></td><td align="left"><code>&lt;insert&gt;``&lt;update&gt;``&lt;delete&gt;``&lt;select&gt;</code></td><td align="left">每个注解分别代表将会被执行的 SQL 语句。它们用字符串数组（或单个字符串）作为参数。如果传递的是字符串数组，字符串数组会被连接成单个完整的字符串，每个字符串之间加入一个空格。这有效地避免了用 Java 代码构建 SQL 语句时产生的“丢失空格”问题。当然，你也可以提前手动连接好字符串。属性：<code>value</code>，指定用来组成单个 SQL 语句的字符串数组。 The <code>databaseId</code>(Available since 3.5.5), in case there is a configured <code>DatabaseIdProvider</code>, the MyBatis use a statement with no <code>databaseId</code> attribute or with a <code>databaseId</code> that matches the current one. If found with and without the <code>databaseId</code> the latter will be discarded.</td></tr><tr><td align="left"><code>@InsertProvider</code><br><code>@UpdateProvider</code><br><code>@DeleteProvider</code><br><code>@SelectProvider</code></td><td align="left"><code>方法</code></td><td align="left"><code>&lt;insert&gt;``&lt;update&gt;``&lt;delete&gt;``&lt;select&gt;</code></td><td align="left">允许构建动态 SQL。这些备选的 SQL 注解允许你指定返回 SQL 语句的类和方法，以供运行时执行。（从 MyBatis 3.4.6 开始，可以使用 <code>CharSequence</code> 代替 <code>String</code> 来作为返回类型）。当执行映射语句时，MyBatis 会实例化注解指定的类，并调用注解指定的方法。你可以通过 <code>ProviderContext</code> 传递映射方法接收到的参数、&quot;Mapper interface type&quot; 和 &quot;Mapper method&quot;（仅在 MyBatis 3.4.5 以上支持）作为参数。（MyBatis 3.4 以上支持传入多个参数） 属性：<code>value</code>、<code>type</code>、<code>method</code>、<code>databaseId</code>。 <code>value</code> and <code>type</code> 属性用于指定类名 (The <code>type</code> attribute is alias for <code>value</code>, you must be specify either one. But both attributes can be omit when specify the <code>defaultSqlProviderType</code> as global configuration)。 <code>method</code> 用于指定该类的方法名（从版本 3.5.1 开始，可以省略 <code>method</code> 属性，MyBatis 将会使用 <code>ProviderMethodResolver</code> 接口解析方法的具体实现。如果解析失败，MyBatis 将会使用名为 <code>provideSql</code> 的降级实现）。<strong>提示</strong> 接下来的“SQL 语句构建器”一章将会讨论该话题，以帮助你以更清晰、更便于阅读的方式构建动态 SQL。 The <code>databaseId</code>(Available since 3.5.5), in case there is a configured <code>DatabaseIdProvider</code>, the MyBatis will use a provider method with no <code>databaseId</code> attribute or with a <code>databaseId</code> that matches the current one. If found with and without the <code>databaseId</code> the latter will be discarded.</td></tr><tr><td align="left"><code>@Param</code></td><td align="left"><code>参数</code></td><td align="left">N/A</td><td align="left">如果你的映射方法接受多个参数，就可以使用这个注解自定义每个参数的名字。否则在默认情况下，除 <code>RowBounds</code> 以外的参数会以 &quot;param&quot; 加参数位置被命名。例如 <code>#&#123;param1&#125;</code>, <code>#&#123;param2&#125;</code>。如果使用了 <code>@Param(&quot;person&quot;)</code>，参数就会被命名为 <code>#&#123;person&#125;</code>。</td></tr><tr><td align="left"><code>@SelectKey</code></td><td align="left"><code>方法</code></td><td align="left"><code>&lt;selectKey&gt;</code></td><td align="left">这个注解的功能与 <code>&lt;selectKey&gt;</code> 标签完全一致。该注解只能在 <code>@Insert</code> 或 <code>@InsertProvider</code> 或 <code>@Update</code> 或 <code>@UpdateProvider</code> 标注的方法上使用，否则将会被忽略。如果标注了 <code>@SelectKey</code> 注解，MyBatis 将会忽略掉由 <code>@Options</code> 注解所设置的生成主键或设置（configuration）属性。属性：<code>statement</code> 以字符串数组形式指定将会被执行的 SQL 语句，<code>keyProperty</code> 指定作为参数传入的对象对应属性的名称，该属性将会更新成新的值，<code>before</code> 可以指定为 <code>true</code> 或 <code>false</code> 以指明 SQL 语句应被在插入语句的之前还是之后执行。<code>resultType</code> 则指定 <code>keyProperty</code> 的 Java 类型。<code>statementType</code> 则用于选择语句类型，可以选择 <code>STATEMENT</code>、<code>PREPARED</code> 或 <code>CALLABLE</code> 之一，它们分别对应于 <code>Statement</code>、<code>PreparedStatement</code> 和 <code>CallableStatement</code>。默认值是 <code>PREPARED</code>。 The <code>databaseId</code>(Available since 3.5.5), in case there is a configured <code>DatabaseIdProvider</code>, the MyBatis will use a statement with no <code>databaseId</code> attribute or with a <code>databaseId</code> that matches the current one. If found with and without the <code>databaseId</code> the latter will be discarded.</td></tr><tr><td align="left"><code>@ResultMap</code></td><td align="left"><code>方法</code></td><td align="left">N/A</td><td align="left">这个注解为 <code>@Select</code> 或者 <code>@SelectProvider</code> 注解指定 XML 映射中 <code>&lt;resultMap&gt;</code> 元素的 id。这使得注解的 select 可以复用已在 XML 中定义的 ResultMap。如果标注的 select 注解中存在 <code>@Results</code> 或者 <code>@ConstructorArgs</code> 注解，这两个注解将被此注解覆盖。</td></tr><tr><td align="left"><code>@ResultType</code></td><td align="left"><code>方法</code></td><td align="left">N/A</td><td align="left">在使用了结果处理器的情况下，需要使用此注解。由于此时的返回类型为 void，所以 Mybatis 需要有一种方法来判断每一行返回的对象类型。如果在 XML 有对应的结果映射，请使用 <code>@ResultMap</code> 注解。如果结果类型在 XML 的 <code>&lt;select&gt;</code> 元素中指定了，就不需要使用其它注解了。否则就需要使用此注解。比如，如果一个标注了 @Select 的方法想要使用结果处理器，那么它的返回类型必须是 void，并且必须使用这个注解（或者 @ResultMap）。这个注解仅在方法返回类型是 void 的情况下生效。</td></tr><tr><td align="left"><code>@Flush</code></td><td align="left"><code>方法</code></td><td align="left">N/A</td><td align="left">如果使用了这个注解，定义在 Mapper 接口中的方法就能够调用 <code>SqlSession#flushStatements()</code> 方法。（Mybatis 3.3 以上可用）</td></tr></tbody></table><h3 id="映射注解示例"><a href="#映射注解示例" class="headerlink" title="映射注解示例"></a>映射注解示例</h3><p>这个例子展示了如何使用 @SelectKey 注解来在插入前读取数据库序列的值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;insert into table3 (id, name) values(#&#123;nameId&#125;, #&#123;name&#125;)&quot;)</span></span><br><span class="line"><span class="meta">@SelectKey(statement=&quot;call next value for TestSequence&quot;, keyProperty=&quot;nameId&quot;, before=true, resultType=int.class)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertTable3</span><span class="params">(Name name)</span></span>;</span><br></pre></td></tr></table></figure><p>这个例子展示了如何使用 @SelectKey 注解来在插入后读取数据库自增列的值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Insert(&quot;insert into table2 (name) values(#&#123;name&#125;)&quot;)</span><br><span class="line">@SelectKey(statement&#x3D;&quot;call identity()&quot;, keyProperty&#x3D;&quot;nameId&quot;, before&#x3D;false, resultType&#x3D;int.class)</span><br><span class="line">int insertTable2(Name name);</span><br></pre></td></tr></table></figure><p>这个例子展示了如何使用 <code>@Flush</code> 注解来调用 <code>SqlSession#flushStatements()</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Flush</span></span><br><span class="line"><span class="function">List&lt;BatchResult&gt; <span class="title">flush</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这些例子展示了如何通过指定 @Result 的 id 属性来命名结果集：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Results(id = &quot;userResult&quot;, value = &#123;</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;id&quot;, column = &quot;uid&quot;, id = true),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;firstName&quot;, column = &quot;first_name&quot;),</span></span><br><span class="line"><span class="meta">    @Result(property = &quot;lastName&quot;, column = &quot;last_name&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from users where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function">User <span class="title">getUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Results(id = &quot;companyResults&quot;)</span></span><br><span class="line"><span class="meta">@ConstructorArgs(&#123;</span></span><br><span class="line"><span class="meta">    @Arg(column = &quot;cid&quot;, javaType = Integer.class, id = true),</span></span><br><span class="line"><span class="meta">    @Arg(column = &quot;name&quot;, javaType = String.class)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from company where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function">Company <span class="title">getCompanyById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>这个例子展示了如何使用单个参数的 @SqlProvider 注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SelectProvider(type = UserSqlBuilder.class, method = &quot;buildGetUsersByName&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUsersByName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSqlBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildGetUsersByName</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()&#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;name like #&#123;value&#125; || &#x27;%&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ORDER_BY(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子展示了如何使用多个参数的 @SqlProvider 注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SelectProvider(type = UserSqlBuilder.class, method = &quot;buildGetUsersByName&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUsersByName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;orderByColumn&quot;)</span> String orderByColumn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSqlBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不使用 @Param，就应该定义与 mapper 方法相同的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildGetUsersByName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String name, <span class="keyword">final</span> String orderByColumn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()&#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">            WHERE(<span class="string">&quot;name like #&#123;name&#125; || &#x27;%&#x27;&quot;</span>);</span><br><span class="line">            ORDER_BY(orderByColumn);</span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果使用 @Param，就可以只定义需要使用的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildGetUsersByName</span><span class="params">(<span class="meta">@Param(&quot;orderByColumn&quot;)</span> <span class="keyword">final</span> String orderByColumn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()&#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">            WHERE(<span class="string">&quot;name like #&#123;name&#125; || &#x27;%&#x27;&quot;</span>);</span><br><span class="line">            ORDER_BY(orderByColumn);</span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This example shows usage that share an sql provider class to all mapper methods using global configuration(Available since 3.5.6):</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">configuration.setDefaultSqlProviderType(TemplateFilePathProvider.class); <span class="comment">// Specify an sql provider class for sharing on all mapper methods</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Can omit the type/value attribute on sql provider annotation</span></span><br><span class="line"><span class="comment">// If omit it, the MyBatis apply the class that specified on defaultSqlProviderType.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SelectProvider</span> <span class="comment">// Same with @SelectProvider(TemplateFilePathProvider.class)</span></span><br><span class="line">    <span class="function">User <span class="title">findUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InsertProvider</span> <span class="comment">// Same with @InsertProvider(TemplateFilePathProvider.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UpdateProvider</span> <span class="comment">// Same with @UpdateProvider(TemplateFilePathProvider.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteProvider</span> <span class="comment">// Same with @DeleteProvider(TemplateFilePathProvider.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下例子展示了 <code>ProviderMethodResolver</code>（3.5.1 后可用）的默认实现使用方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SelectProvider(UserSqlProvider.class)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUsersByName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在你的 provider 类中实现 ProviderMethodResolver 接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSqlProvider</span> <span class="keyword">implements</span> <span class="title">ProviderMethodResolver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认实现中，会将映射器方法的调用解析到实现的同名方法上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUsersByName</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()&#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;name like #&#123;value&#125; || &#x27;%&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ORDER_BY(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This example shows usage the <code>databaseId</code> attribute on the statement annotation(Available since 3.5.5):</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(value = &quot;SELECT SYS_GUID() FROM dual&quot;, databaseId = &quot;oracle&quot;)</span> <span class="comment">// Use this statement if DatabaseIdProvider provide &quot;oracle&quot;</span></span><br><span class="line"><span class="meta">@Select(value = &quot;SELECT uuid_generate_v4()&quot;, databaseId = &quot;postgres&quot;)</span> <span class="comment">// Use this statement if DatabaseIdProvider provide &quot;postgres&quot;</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT RANDOM_UUID()&quot;)</span> <span class="comment">// Use this statement if the DatabaseIdProvider not configured or not matches databaseId</span></span><br><span class="line"><span class="function">String <span class="title">generateId</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></div></div><ul class="breadcrumb"><li><a href="/docs/">DOCS</a></li><li><a href="/docs/mybatis/">MYBATIS</a></li><li>JAVA-API</li></ul></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">湘ICP备19011756号-1</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">JIAHE</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.6/pdfobject.min.js","integrity":"sha256-77geM50MfxCD17eqyJR+Dag1svjJOLN+BJ2F/DMqMEY="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"ignores":null,"url":"https://blog.xiaojianzheng.cn/docs/mybatis/java-api.html"}</script><script src="/js/third-party/quicklink.js"></script></body></html>