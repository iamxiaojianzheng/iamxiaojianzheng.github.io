<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"xiaojianzheng.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><meta name="description" content="Collection &amp; Reuse"><meta property="og:type" content="website"><meta property="og:title" content="JIAHE"><meta property="og:url" content="http://xiaojianzheng.cn/index.html"><meta property="og:site_name" content="JIAHE"><meta property="og:description" content="Collection &amp; Reuse"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="JIAHE"><meta property="article:tag" content="JIAHE"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://xiaojianzheng.cn/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>JIAHE</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">JIAHE</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-导航"><a href="/navigation/" rel="section"><i class="fa fa-location-arrow fa-fw"></i>导航</a></li><li class="menu-item menu-item-文档"><a href="/docs/" rel="section"><i class="fa fa-book fa-fw fa-fw"></i>文档</a></li><li class="menu-item menu-item-cheat-sheet"><a href="/cheat-sheet/" rel="section"><i class="fas fa-pen fa-fw"></i>Cheat Sheet</a></li><li class="menu-item menu-item-软件安装部署"><a href="/software-install-and-deploy/" rel="section"><i class="fab fa-windows fa-fw"></i>软件安装部署</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="JIAHE" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">JIAHE</p><div class="site-description" itemprop="description">Collection & Reuse</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">85</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">88</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com&#x2F;" rel="noopener" target="_blank">Baidu</a></li><li class="links-of-blogroll-item"> <a href="https://cn.bing.com/" title="https:&#x2F;&#x2F;cn.bing.com&#x2F;" rel="noopener" target="_blank">Bing</a></li><li class="links-of-blogroll-item"> <a href="https://www.google.com/" title="https:&#x2F;&#x2F;www.google.com&#x2F;" rel="noopener" target="_blank">Google</a></li><li class="links-of-blogroll-item"> <a href="https://zh.wikipedia.org/wiki/Wikipedia:%E9%A6%96%E9%A1%B5" title="https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Wikipedia:%E9%A6%96%E9%A1%B5" rel="noopener" target="_blank">Wiki</a></li><li class="links-of-blogroll-item"> <a href="https://projectlombok.org/" title="https:&#x2F;&#x2F;projectlombok.org&#x2F;" rel="noopener" target="_blank">lombok</a></li><li class="links-of-blogroll-item"> <a href="https://logging.apache.org/log4j/2.x/" title="https:&#x2F;&#x2F;logging.apache.org&#x2F;log4j&#x2F;2.x&#x2F;" rel="noopener" target="_blank">log4j</a></li><li class="links-of-blogroll-item"> <a href="http://logback.qos.ch/" title="http:&#x2F;&#x2F;logback.qos.ch&#x2F;" rel="noopener" target="_blank">logback</a></li><li class="links-of-blogroll-item"> <a href="https://junit.org/junit5/" title="https:&#x2F;&#x2F;junit.org&#x2F;junit5&#x2F;" rel="noopener" target="_blank">junit</a></li><li class="links-of-blogroll-item"> <a href="https://element.eleme.cn/#/zh-CN" title="https:&#x2F;&#x2F;element.eleme.cn&#x2F;#&#x2F;zh-CN" rel="noopener" target="_blank">ElementUI</a></li><li class="links-of-blogroll-item"> <a href="https://zipkin.io/" title="https:&#x2F;&#x2F;zipkin.io&#x2F;" rel="noopener" target="_blank">Zipkin</a></li><li class="links-of-blogroll-item"> <a href="https://www.selenium.dev/zh-cn/" title="https:&#x2F;&#x2F;www.selenium.dev&#x2F;zh-cn&#x2F;" rel="noopener" target="_blank">Selenium</a></li><li class="links-of-blogroll-item"> <a href="https://nacos.io/zh-cn/docs/what-is-nacos.html" title="https:&#x2F;&#x2F;nacos.io&#x2F;zh-cn&#x2F;docs&#x2F;what-is-nacos.html" rel="noopener" target="_blank">Nacos</a></li><li class="links-of-blogroll-item"> <a href="https://dev.mysql.com/downloads/" title="https:&#x2F;&#x2F;dev.mysql.com&#x2F;downloads&#x2F;" rel="noopener" target="_blank">MySQL-Download</a></li><li class="links-of-blogroll-item"> <a href="https://redis.io/" title="https:&#x2F;&#x2F;redis.io&#x2F;" rel="noopener" target="_blank">Redis</a></li><li class="links-of-blogroll-item"> <a href="https://www.jetbrains.com/help/idea/discover-intellij-idea.html" title="https:&#x2F;&#x2F;www.jetbrains.com&#x2F;help&#x2F;idea&#x2F;discover-intellij-idea.html" rel="noopener" target="_blank">IDEA-Document</a></li><li class="links-of-blogroll-item"> <a href="https://jdk.java.net/" title="https:&#x2F;&#x2F;jdk.java.net&#x2F;" rel="noopener" target="_blank">JDK</a></li><li class="links-of-blogroll-item"> <a href="https://www.oracle.com/java/technologies/downloads/archive/" title="https:&#x2F;&#x2F;www.oracle.com&#x2F;java&#x2F;technologies&#x2F;downloads&#x2F;archive&#x2F;" rel="noopener" target="_blank">JDK-Oracle</a></li><li class="links-of-blogroll-item"> <a href="https://poi.apache.org/components/index.html" title="https:&#x2F;&#x2F;poi.apache.org&#x2F;components&#x2F;index.html" rel="noopener" target="_blank">POI</a></li><li class="links-of-blogroll-item"> <a href="https://assertj.github.io/doc/" title="https:&#x2F;&#x2F;assertj.github.io&#x2F;doc&#x2F;" rel="noopener" target="_blank">AssertJ</a></li><li class="links-of-blogroll-item"> <a href="https://docshome.gitbook.io/nginx-docs/" title="https:&#x2F;&#x2F;docshome.gitbook.io&#x2F;nginx-docs&#x2F;" rel="noopener" target="_blank">Nginx-CN</a></li><li class="links-of-blogroll-item"> <a href="https://github.com/cglib/cglib" title="https:&#x2F;&#x2F;github.com&#x2F;cglib&#x2F;cglib" rel="noopener" target="_blank">cglib</a></li></ul></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang=""><link itemprop="mainEntityOfPage" href="http://xiaojianzheng.cn/2021/11/06/%E6%A1%86%E6%9E%B6%E9%9B%86%E5%90%88/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="JIAHE"><meta itemprop="description" content="Collection & Reuse"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="JIAHE"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/11/06/%E6%A1%86%E6%9E%B6%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">框架集合</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 23:03:31" itemprop="dateCreated datePublished" datetime="2021-11-06T23:03:31+08:00">2021-11-06</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="☕Java"><a href="#☕Java" class="headerlink" title="☕Java"></a>☕Java</h1><hr><p><a target="_blank" rel="noopener" href="https://github.com/EsotericSoftware/kryo">https://github.com/EsotericSoftware/kryo</a><br><strong>Kryo</strong> 是一个快速高效的 Java 二进制对象图序列化框架。该项目的目标是高速、小尺寸和易于使用的 API。该项目在任何需要持久化对象的时候都很有用，无论是保存到文件、数据库还是通过网络。</p><hr><p><a target="_blank" rel="noopener" href="https://poi.apache.org/components/index.html">https://poi.apache.org/components/index.html</a><br><strong>Apache POI</strong> 项目是开发基于 Microsoft 的 OLE 2 复合文档格式的文件格式的纯 Java 端口的主项目。 Microsoft Office Documents 以及使用 MFC 属性集序列化其文档对象的程序都使用 OLE 2 复合文档格式。<br>Apache POI 也是开发基于Office Open XML (ooxml) 的文件格式的纯Java 端口的主项目。 OOXML 是 <code>ECMA/ISO</code> 标准化工作的一部分。该文档相当大，但您通常可以毫不费力地找到所需的内容！ ECMA-376 标准在这里，并且也在 Microsoft OSP 之下。</p><hr><p><a target="_blank" rel="noopener" href="https://site.mockito.org/#intro">https://site.mockito.org/#intro</a><br><a target="_blank" rel="noopener" href="https://github.com/mockito/mockito">https://github.com/mockito/mockito</a><br><strong>Mockito</strong> 是一个用于 Java 单元测试的模拟框架。它被设计为在测试需要模拟时使用直观。</p><hr><p><a target="_blank" rel="noopener" href="http://sikulix.com/">http://sikulix.com/</a><br><a target="_blank" rel="noopener" href="https://raiman.github.io/SikuliX1/downloads.html">https://raiman.github.io/SikuliX1/downloads.html</a><br><a target="_blank" rel="noopener" href="https://github.com/RaiMan/SikuliX1">https://github.com/RaiMan/SikuliX1</a><br><strong>SikuliX</strong> 可以自动化您在运行 Windows、Mac 或某些 Linux/Unix 的台式计算机屏幕上看到的任何内容。它使用由 OpenCV 提供支持的图像识别来识别 GUI 组件。如果无法轻松访问 GUI 的内部结构或要操作的应用程序或网页的源代码，这将非常方便。</p><hr><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98</a><br><a target="_blank" rel="noopener" href="https://github.com/drtrang/druid-spring-boot/blob/master/druid-spring-boot-example/druid-spring-boot-mybatis-example/src/main/resources/application.yml">https://github.com/drtrang/druid-spring-boot/blob/master/druid-spring-boot-example/druid-spring-boot-mybatis-example/src/main/resources/application.yml</a><br><a target="_blank" rel="noopener" href="https://github.com/drtrang/druid-spring-boot/blob/master/druid-spring-boot-example/druid-spring-boot-mybatis-example/src/main/resources/druid.yml">https://github.com/drtrang/druid-spring-boot/blob/master/druid-spring-boot-example/druid-spring-boot-mybatis-example/src/main/resources/druid.yml</a><br><strong>Druid</strong>是Java语言中最好的数据库连接池。Druid能够提供强大的监控和扩展功能。</p><hr><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E9%A1%B5">https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E9%A1%B5</a><br><a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel">https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel</a><br><strong>Sentinel</strong> 是面向分布式服务架构的流量控制组件，主要以流量为切入点，从限流、流量整形、熔断降级、系统负载保护、热点防护等多个维度来帮助开发者保障微服务的稳定性。</p><h1 id="⚡Javascript"><a href="#⚡Javascript" class="headerlink" title="⚡Javascript"></a>⚡Javascript</h1><hr><p><a target="_blank" rel="noopener" href="http://momentjs.cn/docs/#/parsing/">http://momentjs.cn/docs/#/parsing/</a><br><strong>Moment</strong> JavaScript日期处理类库</p><p><a target="_blank" rel="noopener" href="https://echarts.apache.org/zh/option.html#title">https://echarts.apache.org/zh/option.html#title</a><br><strong>Echarts</strong> 一个基于 JavaScript 的开源可视化图表库</p><p><a target="_blank" rel="noopener" href="http://mikemcl.github.io/big.js/">http://mikemcl.github.io/big.js/</a><br><strong>Big.js</strong> 用于任意精度十进制算术的小型、快速、易于使用的库。</p><p><a target="_blank" rel="noopener" href="https://mikemcl.github.io/decimal.js/">https://mikemcl.github.io/decimal.js/</a><br><strong>decimal.js</strong> 功能同上</p><p><a target="_blank" rel="noopener" href="https://socket.io/">https://socket.io/</a><br><strong>Socket.IO</strong> 是一个库，可以在浏览器和服务器之间实现实时、双向和基于事件的通信。</p><p><a target="_blank" rel="noopener" href="https://shepherdjs.dev/">https://shepherdjs.dev/</a><br><strong>shepherdjs</strong> 引导您的用户浏览您的应用</p><p><a target="_blank" rel="noopener" href="http://llever.com/vue-scrollto-zh/">http://llever.com/vue-scrollto-zh/</a><br><strong>vue-scrollto</strong> 滚动元素从未如此简单!</p><p><a target="_blank" rel="noopener" href="https://api.onlyoffice.com/">https://api.onlyoffice.com/</a><br><strong>OnlyOffice</strong> 文档编辑器</p><p><a target="_blank" rel="noopener" href="http://tinymce.ax-z.cn/general/basic-setup.php">http://tinymce.ax-z.cn/general/basic-setup.php</a><br><strong>TinyMCE</strong> 功能强大、所见即所得的富文本编辑器</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang=""><link itemprop="mainEntityOfPage" href="http://xiaojianzheng.cn/2021/11/06/%E5%87%A0%E7%A7%8D%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9A%84%20Java%20%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E6%AF%94%E8%BE%83/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="JIAHE"><meta itemprop="description" content="Collection & Reuse"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="JIAHE"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/11/06/%E5%87%A0%E7%A7%8D%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9A%84%20Java%20%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E6%AF%94%E8%BE%83/" class="post-title-link" itemprop="url">未命名</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 23:03:31" itemprop="dateCreated datePublished" datetime="2021-11-06T23:03:31+08:00">2021-11-06</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>任务调度是指基于给定时间点，给定时间间隔或者给定执行次数自动执行任务。本文由浅入深介绍四种任务调度的 Java 实现：</p><ul><li>Timer</li><li>ScheduledExecutor</li><li>开源工具包 Quartz</li><li>开源工具包 JCronTab</li></ul><p>此外，为结合实现复杂的任务调度，本文还将介绍 Calendar 的一些使用方法。</p><h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>相信大家都已经非常熟悉 java.util.Timer 了，它是最简单的一种实现任务调度的方法，下面给出一个具体的例子：</p><h2 id="清单-1-使用-Timer-进行任务调度"><a href="#清单-1-使用-Timer-进行任务调度" class="headerlink" title="清单 1. 使用 Timer 进行任务调度"></a>清单 1. 使用 Timer 进行任务调度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ibm.scheduler;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTest</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String jobName = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimerTest</span><span class="params">(String jobName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.jobName = jobName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;execute &quot;</span> + jobName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="keyword">long</span> delay1 = <span class="number">1</span> * <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">long</span> period1 = <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 从现在开始 1 秒钟之后，每隔 1 秒钟执行一次 job1</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> TimerTest(<span class="string">&quot;job1&quot;</span>), delay1, period1);</span><br><span class="line">        <span class="keyword">long</span> delay2 = <span class="number">2</span> * <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">long</span> period2 = <span class="number">2000</span>;</span><br><span class="line">        <span class="comment">// 从现在开始 2 秒钟之后，每隔 2 秒钟执行一次 job2</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> TimerTest(<span class="string">&quot;job2&quot;</span>), delay2, period2);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> Output:</span><br><span class="line"> execute job1</span><br><span class="line"> execute job1</span><br><span class="line"> execute job2</span><br><span class="line"> execute job1</span><br><span class="line"> execute job1</span><br><span class="line"> execute job2</span><br></pre></td></tr></table></figure><p>使用 Timer 实现任务调度的核心类是 Timer 和 TimerTask。其中 Timer 负责设定 TimerTask 的起始与间隔执行时间。使用者只需要创建一个 TimerTask 的继承类，实现自己的 run 方法，然后将其丢给 Timer 去执行即可。</p><p>Timer 的设计核心是一个 TaskList 和一个 TaskThread。Timer 将接收到的任务丢到自己的 TaskList 中，TaskList 按照 Task 的最初执行时间进行排序。TimerThread 在创建 Timer 时会启动成为一个守护线程。</p><p>这个线程会轮询所有任务，找到一个最近要执行的任务，然后休眠，当到达最近要执行任务的开始时间点，TimerThread 被唤醒并执行该任务。之后 TimerThread 更新最近一个要执行的任务，继续休眠。</p><p>Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。</p><h1 id="ScheduledExecutor"><a href="#ScheduledExecutor" class="headerlink" title="ScheduledExecutor"></a>ScheduledExecutor</h1><p>鉴于 Timer 的上述缺陷，Java 5 推出了基于线程池设计的 ScheduledExecutor。其设计思想是，每一个被调度的任务都会由线程池中一个线程去执行，因此任务是并发执行的，相互之间不会受到干扰。需要注意的是，只有当任务的执行时间到来时，ScheduedExecutor 才会真正启动一个线程，其余时间 ScheduledExecutor 都是在轮询任务的状态。</p><h2 id="清单-2-使用-ScheduledExecutor-进行任务调度"><a href="#清单-2-使用-ScheduledExecutor-进行任务调度" class="headerlink" title="清单 2. 使用 ScheduledExecutor 进行任务调度"></a>清单 2. 使用 ScheduledExecutor 进行任务调度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ibm.scheduler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutorTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String jobName = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledExecutorTest</span><span class="params">(String jobName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.jobName = jobName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;execute &quot;</span> + jobName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> initialDelay1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> period1 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从现在开始1秒钟之后，每隔1秒钟执行一次job1</span></span><br><span class="line">        service.scheduleAtFixedRate(</span><br><span class="line">                <span class="keyword">new</span> ScheduledExecutorTest(<span class="string">&quot;job1&quot;</span>), initialDelay1,</span><br><span class="line">                period1, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> initialDelay2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> delay2 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从现在开始2秒钟之后，每隔2秒钟执行一次job2</span></span><br><span class="line">        service.scheduleWithFixedDelay(</span><br><span class="line">                <span class="keyword">new</span> ScheduledExecutorTest(<span class="string">&quot;job2&quot;</span>), initialDelay2,</span><br><span class="line">                delay2, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Output:</span><br><span class="line">execute job1</span><br><span class="line">execute job1</span><br><span class="line">execute job2</span><br><span class="line">execute job1</span><br><span class="line">execute job1</span><br><span class="line">execute job2</span><br></pre></td></tr></table></figure><p>清单 2 展示了 ScheduledExecutorService 中两种最常用的调度方法 ScheduleAtFixedRate 和 ScheduleWithFixedDelay。ScheduleAtFixedRate 每次执行时间为上一次任务开始起向后推一个时间间隔，即每次执行时间为 :initialDelay, initialDelay+period, initialDelay+2<em>period,…；ScheduleWithFixedDelay 每次执行时间为上一次任务结束起向后推一个时间间隔，即每次执行时间为：initialDelay, initialDelay+executeTime+delay, initialDelay+2</em>executeTime+2*delay。</p><p>由此可见，ScheduleAtFixedRate 是基于固定时间间隔进行任务调度，ScheduleWithFixedDelay 取决于每次任务执行的时间长短，是基于不固定时间间隔进行任务调度。</p><h2 id="用-ScheduledExecutor-和-Calendar-实现复杂任务调度"><a href="#用-ScheduledExecutor-和-Calendar-实现复杂任务调度" class="headerlink" title="用 ScheduledExecutor 和 Calendar 实现复杂任务调度"></a>用 ScheduledExecutor 和 Calendar 实现复杂任务调度</h2><p>Timer 和 ScheduledExecutor 都仅能提供基于开始时间与重复间隔的任务调度，不能胜任更加复杂的调度需求。比如，设置每星期二的 16:38:10 执行任务。该功能使用 Timer 和 ScheduledExecutor 都不能直接实现，但我们可以借助 Calendar 间接实现该功能。</p><h2 id="清单-3-使用-ScheduledExcetuor-和-Calendar-进行任务调度"><a href="#清单-3-使用-ScheduledExcetuor-和-Calendar-进行任务调度" class="headerlink" title="清单 3. 使用 ScheduledExcetuor 和 Calendar 进行任务调度"></a>清单 3. 使用 ScheduledExcetuor 和 Calendar 进行任务调度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ibm.scheduler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExceutorTest2</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String jobName = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledExceutorTest2</span><span class="params">(String jobName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.jobName = jobName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Date = &quot;</span>+<span class="keyword">new</span> Date()+<span class="string">&quot;, execute &quot;</span> + jobName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算从当前时间currentDate开始，满足条件dayOfWeek, hourOfDay,</span></span><br><span class="line"><span class="comment">     * minuteOfHour, secondOfMinite的最近时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Calendar <span class="title">getEarliestDate</span><span class="params">(Calendar currentDate, <span class="keyword">int</span> dayOfWeek,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> hourOfDay, <span class="keyword">int</span> minuteOfHour, <span class="keyword">int</span> secondOfMinite)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算当前时间的WEEK_OF_YEAR,DAY_OF_WEEK, HOUR_OF_DAY, MINUTE,SECOND等各个字段值</span></span><br><span class="line">        <span class="keyword">int</span> currentWeekOfYear = currentDate.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">        <span class="keyword">int</span> currentDayOfWeek = currentDate.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        <span class="keyword">int</span> currentHour = currentDate.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">        <span class="keyword">int</span> currentMinute = currentDate.get(Calendar.MINUTE);</span><br><span class="line">        <span class="keyword">int</span> currentSecond = currentDate.get(Calendar.SECOND);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果输入条件中的dayOfWeek小于当前日期的dayOfWeek,则WEEK_OF_YEAR需要推迟一周</span></span><br><span class="line">        <span class="keyword">boolean</span> weekLater = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (dayOfWeek &lt; currentDayOfWeek) &#123;</span><br><span class="line">            weekLater = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dayOfWeek == currentDayOfWeek) &#123;</span><br><span class="line">            <span class="comment">//当输入条件与当前日期的dayOfWeek相等时，如果输入条件中的</span></span><br><span class="line">            <span class="comment">//hourOfDay小于当前日期的</span></span><br><span class="line">            <span class="comment">//currentHour，则WEEK_OF_YEAR需要推迟一周</span></span><br><span class="line">            <span class="keyword">if</span> (hourOfDay &lt; currentHour) &#123;</span><br><span class="line">                weekLater = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hourOfDay == currentHour) &#123;</span><br><span class="line">                 <span class="comment">//当输入条件与当前日期的dayOfWeek, hourOfDay相等时，</span></span><br><span class="line">                 <span class="comment">//如果输入条件中的minuteOfHour小于当前日期的</span></span><br><span class="line">                <span class="comment">//currentMinute，则WEEK_OF_YEAR需要推迟一周</span></span><br><span class="line">                <span class="keyword">if</span> (minuteOfHour &lt; currentMinute) &#123;</span><br><span class="line">                    weekLater = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minuteOfHour == currentSecond) &#123;</span><br><span class="line">                     <span class="comment">//当输入条件与当前日期的dayOfWeek, hourOfDay，</span></span><br><span class="line">                     <span class="comment">//minuteOfHour相等时，如果输入条件中的</span></span><br><span class="line">                    <span class="comment">//secondOfMinite小于当前日期的currentSecond，</span></span><br><span class="line">                    <span class="comment">//则WEEK_OF_YEAR需要推迟一周</span></span><br><span class="line">                    <span class="keyword">if</span> (secondOfMinite &lt; currentSecond) &#123;</span><br><span class="line">                        weekLater = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (weekLater) &#123;</span><br><span class="line">            <span class="comment">//设置当前日期中的WEEK_OF_YEAR为当前周推迟一周</span></span><br><span class="line">            currentDate.set(Calendar.WEEK_OF_YEAR, currentWeekOfYear + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置当前日期中的DAY_OF_WEEK,HOUR_OF_DAY,MINUTE,SECOND为输入条件中的值。</span></span><br><span class="line">        currentDate.set(Calendar.DAY_OF_WEEK, dayOfWeek);</span><br><span class="line">        currentDate.set(Calendar.HOUR_OF_DAY, hourOfDay);</span><br><span class="line">        currentDate.set(Calendar.MINUTE, minuteOfHour);</span><br><span class="line">        currentDate.set(Calendar.SECOND, secondOfMinite);</span><br><span class="line">        <span class="keyword">return</span> currentDate;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ScheduledExceutorTest2 test = <span class="keyword">new</span> ScheduledExceutorTest2(<span class="string">&quot;job1&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前时间</span></span><br><span class="line">        Calendar currentDate = Calendar.getInstance();</span><br><span class="line">        <span class="keyword">long</span> currentDateLong = currentDate.getTime().getTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;Current Date = &quot;</span> + currentDate.getTime().toString());</span><br><span class="line">        <span class="comment">//计算满足条件的最近一次执行时间</span></span><br><span class="line">        Calendar earliestDate = test</span><br><span class="line">                .getEarliestDate(currentDate, <span class="number">3</span>, <span class="number">16</span>, <span class="number">38</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">long</span> earliestDateLong = earliestDate.getTime().getTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;Earliest Date = &quot;</span></span><br><span class="line">                + earliestDate.getTime().toString());</span><br><span class="line">        <span class="comment">//计算从当前时间到最近一次执行时间的时间间隔</span></span><br><span class="line">        <span class="keyword">long</span> delay = earliestDateLong - currentDateLong;</span><br><span class="line">        <span class="comment">//计算执行周期为一星期</span></span><br><span class="line">        <span class="keyword">long</span> period = <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//从现在开始delay毫秒之后，每隔一星期执行一次job1</span></span><br><span class="line">        service.scheduleAtFixedRate(test, delay, period,</span><br><span class="line">                TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Output:</span><br><span class="line">Current Date = Wed Feb <span class="number">02</span> <span class="number">17</span>:<span class="number">32</span>:<span class="number">01</span> CST <span class="number">2011</span></span><br><span class="line">Earliest Date = Tue Feb <span class="number">8</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">10</span> CST <span class="number">2011</span></span><br><span class="line">Date = Tue Feb <span class="number">8</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">10</span> CST <span class="number">2011</span>, execute job1</span><br><span class="line">Date = Tue Feb <span class="number">15</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">10</span> CST <span class="number">2011</span>, execute job1</span><br></pre></td></tr></table></figure><p>清单 3 实现了每星期二 16:38:10 调度任务的功能。其核心在于根据当前时间推算出最近一个星期二 16:38:10 的绝对时间，然后计算与当前时间的时间差，作为调用 ScheduledExceutor 函数的参数。</p><p>计算最近时间要用到 java.util.calendar 的功能。首先需要解释 calendar 的一些设计思想。Calendar 有以下几种唯一标识一个日期的组合方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">YEAR + MONTH + DAY_OF_MONTH</span><br><span class="line">YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK</span><br><span class="line">YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK</span><br><span class="line">YEAR + DAY_OF_YEAR</span><br><span class="line">YEAR + DAY_OF_WEEK + WEEK_OF_YEAR</span><br></pre></td></tr></table></figure><p>上述组合分别加上 HOUR_OF_DAY + MINUTE + SECOND 即为一个完整的时间标识。本例采用了最后一种组合方式。输入为 DAY_OF_WEEK, HOUR_OF_DAY, MINUTE, SECOND 以及当前日期 , 输出为一个满足 DAY_OF_WEEK, HOUR_OF_DAY, MINUTE, SECOND 并且距离当前日期最近的未来日期。计算的原则是从输入的 DAY_OF_WEEK 开始比较，如果小于当前日期的 DAY_OF_WEEK，则需要向 WEEK_OF_YEAR 进一， 即将当前日期中的 WEEK_OF_YEAR 加一并覆盖旧值；如果等于当前的 DAY_OF_WEEK, 则继续比较 HOUR_OF_DAY；如果大于当前的 DAY_OF_WEEK，则直接调用 java.util.calenda 的 calendar.set(field, value) 函数将当前日期的 DAY_OF_WEEK, HOUR_OF_DAY, MINUTE, SECOND 赋值为输入值，依次类推，直到比较至 SECOND。读者可以根据输入需求选择不同的组合方式来计算最近执行时间。</p><p>可以看出，用上述方法实现该任务调度比较麻烦，这就需要一个更加完善的任务调度框架来解决这些复杂的调度问题。幸运的是，开源工具包 Quartz 与 JCronTab 提供了这方面强大的支持。</p><h1 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h1><p>Quartz 可以满足更多更复杂的调度需求，首先让我们看看如何用 Quartz 实现每星期二 16:38 的调度安排：</p><h2 id="清单-4-使用-Quartz-进行任务调度"><a href="#清单-4-使用-Quartz-进行任务调度" class="headerlink" title="清单 4. 使用 Quartz 进行任务调度"></a>清单 4. 使用 Quartz 进行任务调度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ibm.scheduler;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobDetail;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Scheduler;</span><br><span class="line"><span class="keyword">import</span> org.quartz.SchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Trigger;</span><br><span class="line"><span class="keyword">import</span> org.quartz.helpers.TriggerUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzTest</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//该方法实现需要执行的任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext arg0)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Generating report - &quot;</span></span><br><span class="line">                + arg0.getJobDetail().getFullName() + <span class="string">&quot;, type =&quot;</span></span><br><span class="line">                + arg0.getJobDetail().getJobDataMap().get(<span class="string">&quot;type&quot;</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date().toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个Scheduler</span></span><br><span class="line">            SchedulerFactory schedFact =</span><br><span class="line">            <span class="keyword">new</span> org.quartz.impl.StdSchedulerFactory();</span><br><span class="line">            Scheduler sched = schedFact.getScheduler();</span><br><span class="line">            sched.start();</span><br><span class="line">            <span class="comment">// 创建一个JobDetail，指明name，groupname，以及具体的Job类名，</span></span><br><span class="line">            <span class="comment">//该Job负责定义需要执行任务</span></span><br><span class="line">            JobDetail jobDetail = <span class="keyword">new</span> JobDetail(<span class="string">&quot;myJob&quot;</span>, <span class="string">&quot;myJobGroup&quot;</span>,</span><br><span class="line">                    QuartzTest.class);</span><br><span class="line">            jobDetail.getJobDataMap().put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;FULL&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建一个每周触发的Trigger，指明星期几几点几分执行</span></span><br><span class="line">            Trigger trigger = TriggerUtils.makeWeeklyTrigger(<span class="number">3</span>, <span class="number">16</span>, <span class="number">38</span>);</span><br><span class="line">            trigger.setGroup(<span class="string">&quot;myTriggerGroup&quot;</span>);</span><br><span class="line">            <span class="comment">// 从当前时间的下一秒开始执行</span></span><br><span class="line">            trigger.setStartTime(TriggerUtils.getEvenSecondDate(<span class="keyword">new</span> Date()));</span><br><span class="line">            <span class="comment">// 指明trigger的name</span></span><br><span class="line">            trigger.setName(<span class="string">&quot;myTrigger&quot;</span>);</span><br><span class="line">            <span class="comment">// 用scheduler将JobDetail与Trigger关联在一起，开始调度任务</span></span><br><span class="line">            sched.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Output:</span><br><span class="line">Generating report - myJobGroup.myJob, type =FULL</span><br><span class="line">Tue Feb <span class="number">8</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">00</span> CST <span class="number">2011</span></span><br><span class="line">Generating report - myJobGroup.myJob, type =FULL</span><br><span class="line">Tue Feb <span class="number">15</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">00</span> CST <span class="number">2011</span></span><br></pre></td></tr></table></figure><p>清单 4 非常简洁地实现了一个上述复杂的任务调度。Quartz 设计的核心类包括 Scheduler, Job 以及 Trigger。其中，Job 负责定义需要执行的任务，Trigger 负责设置调度策略，Scheduler 将二者组装在一起，并触发任务开始执行。</p><h1 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h1><p>使用者只需要创建一个 Job 的继承类，实现 execute 方法。JobDetail 负责封装 Job 以及 Job 的属性，并将其提供给 Scheduler 作为参数。每次 Scheduler 执行任务时，首先会创建一个 Job 的实例，然后再调用 execute 方法执行。Quartz 没有为 Job 设计带参数的构造函数，因此需要通过额外的 JobDataMap 来存储 Job 的属性。JobDataMap 可以存储任意数量的 Key，Value 对，例如：</p><h2 id="清单-5-为-JobDataMap-赋值"><a href="#清单-5-为-JobDataMap-赋值" class="headerlink" title="清单 5. 为 JobDataMap 赋值"></a>清单 5. 为 JobDataMap 赋值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jobDetail.getJobDataMap().put(<span class="string">&quot;myDescription&quot;</span>, <span class="string">&quot;my job description&quot;</span>);</span><br><span class="line"> jobDetail.getJobDataMap().put(<span class="string">&quot;myValue&quot;</span>, <span class="number">1998</span>);</span><br><span class="line"> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"> list.add(<span class="string">&quot;item1&quot;</span>);</span><br><span class="line"> jobDetail.getJobDataMap().put(<span class="string">&quot;myArray&quot;</span>, list);</span><br></pre></td></tr></table></figure><p>JobDataMap 中的数据可以通过下面的方式获取：</p><h2 id="清单-6-获取-JobDataMap-的值"><a href="#清单-6-获取-JobDataMap-的值" class="headerlink" title="清单 6. 获取 JobDataMap 的值"></a>清单 6. 获取 JobDataMap 的值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobDataMapTest</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">//从context中获取instName，groupName以及dataMap</span></span><br><span class="line">        String instName = context.getJobDetail().getName();</span><br><span class="line">        String groupName = context.getJobDetail().getGroup();</span><br><span class="line">        JobDataMap dataMap = context.getJobDetail().getJobDataMap();</span><br><span class="line">        <span class="comment">//从dataMap中获取myDescription，myValue以及myArray</span></span><br><span class="line">        String myDescription = dataMap.getString(<span class="string">&quot;myDescription&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> myValue = dataMap.getInt(<span class="string">&quot;myValue&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; myArray = (ArrayListlt;Strin&gt;) dataMap.get(<span class="string">&quot;myArray&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;</span></span><br><span class="line"><span class="string">                Instance =&quot;</span> + instName + <span class="string">&quot;, group = &quot;</span> + groupName</span><br><span class="line">                + <span class="string">&quot;, description = &quot;</span> + myDescription + <span class="string">&quot;, value =&quot;</span> + myValue</span><br><span class="line">                + <span class="string">&quot;, array item0 = &quot;</span> + myArray.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Output：</span><br><span class="line">Instance = myJob, group = myJobGroup,</span><br><span class="line">description = my job description,</span><br><span class="line">value =<span class="number">1998</span>, array item0 = item1</span><br></pre></td></tr></table></figure><h1 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h1><p>Trigger 的作用是设置调度策略。Quartz 设计了多种类型的 Trigger，其中最常用的是 SimpleTrigger 和 CronTrigger。</p><p>SimpleTrigger 适用于在某一特定的时间执行一次，或者在某一特定的时间以某一特定时间间隔执行多次。</p><p>上述功能决定了 SimpleTrigger 的参数包括 start-time, end-time, repeat count, 以及 repeat interval。</p><p>Repeat count 取值为大于或等于零的整数，或者常量 SimpleTrigger.REPEAT_INDEFINITELY。</p><p>Repeat interval 取值为大于或等于零的长整型。当 Repeat interval 取值为零并且 Repeat count 取值大于零时，将会触发任务的并发执行。</p><p>Start-time 与 dnd-time 取值为 java.util.Date。当同时指定 end-time 与 repeat count 时，优先考虑 end-time。一般地，可以指定 end-time，并设定 repeat count 为 REPEAT_INDEFINITELY。</p><p>以下是 SimpleTrigger 的构造方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleTrigger</span><span class="params">(String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                     String group,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Date startTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Date endTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> repeatCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">long</span> repeatInterval)</span></span></span><br></pre></td></tr></table></figure><p>举例如下：创建一个立即执行且仅执行一次的 SimpleTrigger：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleTrigger trigger = <span class="keyword">new</span> SimpleTrigger(<span class="string">&quot;myTrigger&quot;</span>, <span class="string">&quot;myGroup&quot;</span>, <span class="keyword">new</span> Date(), <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0L</span>);</span><br></pre></td></tr></table></figure><p>创建一个半分钟后开始执行，且每隔一分钟重复执行一次的 SimpleTrigger：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleTrigger trigger = <span class="keyword">new</span> SimpleTrigger(<span class="string">&quot;myTrigger&quot;</span>, <span class="string">&quot;myGroup&quot;</span>, </span><br><span class="line">                                          <span class="keyword">new</span> Date(System.currentTimeMillis()+<span class="number">30</span>*<span class="number">1000</span>), <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">60</span>*<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>创建一个 2011 年 6 月 1 日 8:30 开始执行，每隔一小时执行一次，一共执行一百次，一天之后截止的 SimpleTrigger：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">calendar.set(Calendar.YEAR, <span class="number">2011</span>);</span><br><span class="line">calendar.set(Calendar.MONTH, Calendar.JUNE);</span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">calendar.set(Calendar.HOUR, <span class="number">8</span>);</span><br><span class="line">calendar.set(Calendar.MINUTE, <span class="number">30</span>);</span><br><span class="line">calendar.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">calendar.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br><span class="line">Date startTime = calendar.getTime();</span><br><span class="line">Date endTime = <span class="keyword">new</span> Date(calendar.getTimeInMillis() + <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">SimpleTrigger trigger=<span class="keyword">new</span> SimpleTrigger(<span class="string">&quot;myTrigger&quot;</span>, <span class="string">&quot;myGroup&quot;</span>, startTime, endTime, <span class="number">100</span>, <span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上述最后一个例子中，同时设置了 end-time 与 repeat count，则优先考虑 end-time，总共可以执行二十四次。</p><p>CronTrigger 的用途更广，相比基于特定时间间隔进行调度安排的 SimpleTrigger，CronTrigger 主要适用于基于日历的调度安排。例如：每星期二的 16:38:10 执行，每月一号执行，以及更复杂的调度安排等。</p><p>CronTrigger 同样需要指定 start-time 和 end-time，其核心在于 Cron 表达式，由七个字段组成：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Seconds</span><br><span class="line">Minutes</span><br><span class="line">Hours</span><br><span class="line">Day-of-Month</span><br><span class="line">Month</span><br><span class="line">Day-of-Week</span><br><span class="line">Year (Optional field)</span><br></pre></td></tr></table></figure><p>举例如下：</p><p>创建一个每三小时执行的 CronTrigger，且从每小时的整点开始执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0&#x2F;3  * * ?</span><br></pre></td></tr></table></figure><p>创建一个每十分钟执行的 CronTrigger，且从每小时的第三分钟开始执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 3&#x2F;10 * * * ?</span><br></pre></td></tr></table></figure><p>创建一个每周一，周二，周三，周六的晚上 20:00 到 23:00，每半小时执行一次的 CronTrigger：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0&#x2F;30 20-23 ? * MON-WED,SAT</span><br></pre></td></tr></table></figure><p>创建一个每月最后一个周四，中午 11:30-14:30，每小时执行一次的 trigger：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 30 11-14&#x2F;1 ? * 5L</span><br></pre></td></tr></table></figure><p>解释一下上述例子中各符号的含义：</p><p>首先所有字段都有自己特定的取值</p><p>Seconds 和 Minutes 取值为 0 到 59</p><p>Hours 取值为 0 到 23</p><p>Day-of-Month 取值为 0-31</p><p>Month 取值为 0-11，或者 JAN，FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC</p><p>Days-of-Week 取值为 1-7 或者 SUN, MON, TUE, WED, THU, FRI, SAT</p><p>每个字段可以取单个值，多个值，或一个范围，例如 Day-of-Week 可取值为”MON，TUE，SAT”,”MON-FRI”或者”TUE-THU，SUN”。</p><p>通配符 <em>表示该字段可接受任何可能取值。例如 Month 字段赋值</em> 表示每个月，Day-of-Week 字段赋值 * 表示一周的每天。</p><p><strong>/</strong> 表示开始时刻与间隔时段。例如 Minutes 字段赋值 2/10 表示在一个小时内每 20 分钟执行一次，从第 2 分钟开始。</p><p><strong>?</strong> 仅适用于 Day-of-Month 和 Day-of-Week。? 表示对该字段不指定特定值。适用于需要对这两个字段中的其中一个指定值，而对另一个不指定值的情况。一般情况下，这两个字段只需对一个赋值。</p><p><strong>L</strong> 仅适用于 Day-of-Month 和 Day-of-Week。L 用于 Day-of-Month 表示该月最后一天。L 单独用于 Day-of-Week 表示周六，否则表示一个月最后一个星期几，例如 5L 或者 THUL 表示该月最后一个星期四。</p><p><strong>W</strong> 仅适用于 Day-of-Month，表示离指定日期最近的一个工作日，例如 Day-of-Month 赋值为 10W 表示该月离 10 号最近的一个工作日。</p><p>仅适用于 Day-of-Week，表示该月第 XXX 个星期几。例如 Day-of-Week 赋值为 5#2 或者 THU#2，表示该月第二个星期四。</p><p>CronTrigger 的使用如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CronTrigger cronTrigger = <span class="keyword">new</span> CronTrigger(<span class="string">&quot;myTrigger&quot;</span>, <span class="string">&quot;myGroup&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    cronTrigger.setCronExpression(<span class="string">&quot;0 0/30 20-13 ? * MON-WED,SAT&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Job 与 Trigger 的松耦合设计是 Quartz 的一大特点，其优点在于同一个 Job 可以绑定多个不同的 Trigger，同一个 Trigger 也可以调度多个 Job，灵活性很强。</p><h1 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h1><p>除了上述基本的调度功能，Quartz 还提供了 listener 的功能。主要包含三种 listener：JobListener，TriggerListener 以及 SchedulerListener。当系统发生故障，相关人员需要被通知时，Listener 便能发挥它的作用。最常见的情况是，当任务被执行时，系统发生故障，Listener 监听到错误，立即发送邮件给管理员。下面给出 JobListener 的实例：</p><h2 id="清单-7-JobListener-的实现"><a href="#清单-7-JobListener-的实现" class="headerlink" title="清单 7. JobListener 的实现"></a>清单 7. JobListener 的实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobListener;</span><br><span class="line"><span class="keyword">import</span> org.quartz.SchedulerException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">JobListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;My Listener&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jobWasExecuted</span><span class="params">(JobExecutionContext context, JobExecutionException jobException)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(jobException != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 停止Scheduler</span></span><br><span class="line">                context.getScheduler().shutdown();</span><br><span class="line">                System.out.println(<span class="string">&quot;Error occurs when executing jobs, shut down the scheduler &quot;</span>);</span><br><span class="line">                <span class="comment">// 给管理员发送邮件...</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从清单 7 可以看出，使用者只需要创建一个 JobListener 的继承类，重载需要触发的方法即可。当然，需要将 listener 的实现类注册到 Scheduler 和 JobDetail 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sched.addJobListener(<span class="keyword">new</span> MyListener());</span><br><span class="line">jobDetail.addJobListener(<span class="string">&quot;My Listener&quot;</span>); <span class="comment">// listener 的名字</span></span><br></pre></td></tr></table></figure><p>使用者也可以将 listener 注册为全局 listener，这样便可以监听 scheduler 中注册的所有任务 :</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sched.addGlobalJobListener(<span class="keyword">new</span> MyListener());</span><br></pre></td></tr></table></figure><p>为了测试 listener 的功能，可以在 job 的 execute 方法中强制抛出异常。清单 7 中，listener 接收到异常，将 job 所在的 scheduler 停掉，阻止后续的 job 继续执行。scheduler、jobDetail 等信息都可以从 listener 的参数 context 中检索到。</p><p>清单 7 的输出结果为：</p><blockquote><p>“` Generating report – myJob.myJob, type =FULL Tue Feb 15 18:</p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang=""><link itemprop="mainEntityOfPage" href="http://xiaojianzheng.cn/2021/11/05/2021-11-06-List-All-Classes-Loaded-in-a-Specific-Class-Loader/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="JIAHE"><meta itemprop="description" content="Collection & Reuse"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="JIAHE"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/11/05/2021-11-06-List-All-Classes-Loaded-in-a-Specific-Class-Loader/" class="post-title-link" itemprop="url">List All Classes Loaded in a Specific Class Loader</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-06T00:00:00+08:00">2021-11-06</time></span></div></div></header><div class="post-body" itemprop="articleBody"><div class="note info"><p>原文地址：<a target="_blank" rel="noopener" href="https://www.baeldung.com/java-list-classes-class-loader">https://www.baeldung.com/java-list-classes-class-loader</a></p></div><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><p>In this tutorial, we&#39;ll analyze the technique <strong>to list all the classes loaded by a specific class loader</strong> in Java, using the <a target="_blank" rel="noopener" href="https://www.baeldung.com/java-instrumentation">Java <em>Instrumentation</em> API</a>. We&#39;ll also see how to create and load a Java agent to acquire an <em>Instrumentation</em> instance and invoke the required methods to accomplish our task.</p><h2 id="2-Class-Loaders-in-Java"><a href="#2-Class-Loaders-in-Java" class="headerlink" title="2. Class Loaders in Java"></a>2. Class Loaders in Java</h2><p>The class loaders are an integral part of the JRE (Java Runtime Environment). Their job is to <strong>dynamically load classes into the Java Virtual Machine</strong>. In other words, they load classes into memory on-demand when required by the application. The article on <a target="_blank" rel="noopener" href="https://www.baeldung.com/java-classloaders">Java class loaders</a> talks about their different types and provides a detailed understanding of how they work.</p><h2 id="3-Using-the-Instrumentation-API"><a href="#3-Using-the-Instrumentation-API" class="headerlink" title="3. Using the Instrumentation API"></a>3. Using the <em>Instrumentation API</em></h2><p>The <em>Instrumentation</em> interface provides the <em><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/14/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#getInitiatedClasses(java.lang.ClassLoader)">getInitiatedClasses(Classloader loader)</a></em> method that can be <strong>invoked to</strong> <strong>return an array comprising all the classes loaded by the particular loader</strong>. Let&#39;s see how this works.</p><p>First, we need to create and load an agent to acquire an instance of the <em>Instrumentation</em> interface. A Java agent is a tool to instrument programs running on the JVM (Java Virtual Machine).</p><p>In other words, it can add or modify the bytecode of methods for the purpose of gathering data. We&#39;ll require an <em>agent</em> to get a handle on the <em>Instrumentation</em> instance and invoke the required method.</p><p>There are multiple ways to <a target="_blank" rel="noopener" href="https://www.baeldung.com/java-instrumentation">create and load an agent</a>. In this tutorial, we&#39;ll use the static loading approach using the <em>premain</em> method and the <em>-javaagent</em> option.</p><h3 id="3-1-Creating-a-Java-Agent"><a href="#3-1-Creating-a-Java-Agent" class="headerlink" title="3.1. Creating a Java Agent"></a>3.1. Creating a Java Agent</h3><p>To create a Java agent, we need to <strong>define the premain method to which the Instrumentation instance will be passed on agent load</strong>. Let&#39;s now create the <em>ListLoadedClassesAgent</em> class:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListLoadedClassesAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instrumentation instrumentation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        ListLoadedClassesAgent.instrumentation = instrumentation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Defining-the-listLoadedClasses-Methods"><a href="#3-2-Defining-the-listLoadedClasses-Methods" class="headerlink" title="3.2. Defining the listLoadedClasses Methods"></a>3.2. Defining the <em>listLoadedClasses</em> Methods</h3><p>In addition to defining the agent, we&#39;ll define and expose a static method to return an array of loaded classes for a given class loader.</p><p>Note that <strong>if we pass a class loader with a null value to the getInitiatedClasses method, it returns the classes loaded by the bootstrap class loader</strong>.</p><p>Let&#39;s see the code in action:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt;[] listLoadedClasses(String classLoaderType) &#123;</span><br><span class="line">    <span class="keyword">return</span> instrumentation.getInitiatedClasses(</span><br><span class="line">      getClassLoader(classLoaderType));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader <span class="title">getClassLoader</span><span class="params">(String classLoaderType)</span> </span>&#123;</span><br><span class="line">    ClassLoader classLoader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (classLoaderType) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;SYSTEM&quot;</span>:</span><br><span class="line">            classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;EXTENSION&quot;</span>:</span><br><span class="line">            classLoader = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;BOOTSTRAP&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that if we&#39;re using Java 9 or above, we can use the <em>getPlatformClassLoader</em> method. This will list the classes loaded by the Platform class loader. In that case, the switch case will also contain:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;PLATFORM&quot;</span>:</span><br><span class="line">    classLoader = ClassLoader.getPlatformClassLoader();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-Creating-the-Agent-Manifest-File"><a href="#3-3-Creating-the-Agent-Manifest-File" class="headerlink" title="3.3. Creating the Agent Manifest File"></a>3.3. Creating the Agent Manifest File</h3><p>Now, let&#39;s create a manifest file, <em>MANIFEST.MF</em>, with appropriate attributes for our agent to run, including:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Premain-Class: com.baeldung.loadedclasslisting.ListLoadedClassesAgent</span><br></pre></td></tr></table></figure><p>The complete list of manifest attributes for an agent JAR file is available on the official documentation of the <em><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/14/docs/api/java.instrument/java/lang/instrument/package-summary.html">java.lang.instrument</a></em> package.</p><h3 id="3-4-Loading-the-Agent-and-Running-the-Application"><a href="#3-4-Loading-the-Agent-and-Running-the-Application" class="headerlink" title="3.4. Loading the Agent and Running the Application"></a>3.4. Loading the Agent and Running the Application</h3><p>Let&#39;s now load the agent and run the application. First, we need the agent JAR file with a manifest file containing the <em>Premain-Class</em> information. Additionally, we need the application JAR file with a manifest file containing the <em>Main-Class</em> information. The <em>Launcher class</em> containing the <em>main</em> method will start our application. Then we&#39;ll be able to print the classes loaded by different types of class loaders:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printClassesLoadedBy(<span class="string">&quot;BOOTSTRAP&quot;</span>);</span><br><span class="line">        printClassesLoadedBy(<span class="string">&quot;SYSTEM&quot;</span>);</span><br><span class="line">        printClassesLoadedBy(<span class="string">&quot;EXTENSION&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassesLoadedBy</span><span class="params">(String classLoaderType)</span> </span>&#123;</span><br><span class="line">        System.out.println(classLoaderType + <span class="string">&quot; ClassLoader : &quot;</span>);</span><br><span class="line">        Class&lt;?&gt;[] classes = ListLoadedClassesAgent.listLoadedClasses(classLoaderType);</span><br><span class="line">        Arrays.asList(classes)</span><br><span class="line">            .forEach(clazz -&gt; System.out.println(clazz.getCanonicalName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Next, let&#39;s statically <a target="_blank" rel="noopener" href="https://www.baeldung.com/java-instrumentation#loading-a-java-agent">load the Java agent</a> and start our application:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -javaagent:agent.jar -jar app.jar</span><br></pre></td></tr></table></figure><p>After running the above command, we&#39;ll see the output:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BOOTSTRAP ClassLoader :</span><br><span class="line">java.lang.ClassValue.Entry[]</span><br><span class="line">java.util.concurrent.ConcurrentHashMap.Segment</span><br><span class="line">java.util.concurrent.ConcurrentHashMap.Segment[]</span><br><span class="line">java.util.StringTokenizer</span><br><span class="line">..............</span><br><span class="line">SYSTEM ClassLoader : </span><br><span class="line">java.lang.Object[]</span><br><span class="line">java.lang.Object[][]</span><br><span class="line">java.lang.Class</span><br><span class="line">java.lang.Class[]</span><br><span class="line">..............</span><br><span class="line">EXTENSION ClassLoader :</span><br><span class="line"><span class="keyword">byte</span>[]</span><br><span class="line"><span class="keyword">char</span>[]</span><br><span class="line"><span class="keyword">int</span>[]</span><br><span class="line"><span class="keyword">int</span>[][]</span><br><span class="line"><span class="keyword">short</span>[]</span><br></pre></td></tr></table></figure><h2 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4. Conclusion"></a>4. Conclusion</h2><p>In this tutorial, we learned about the technique to list all the classes loaded in a specific class loader.</p><p>First, we created the Java Agent. After that, we defined the method to list the loaded classes using the Java <em>Instrumentation</em> API. Finally, we created the agent manifest files, loaded the agent, and ran our application.</p><p>As always, the complete source code of the example can be found <a target="_blank" rel="noopener" href="https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-jvm-2">over on GitHub</a>.</p><p>Reference:</p><ul><li><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/14/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#getInitiatedClasses(java.lang.ClassLoader)">https://docs.oracle.com/en/java/javase/14/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#getInitiatedClasses(java.lang.ClassLoader)</a></li><li><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/14/docs/api/java.instrument/java/lang/instrument/package-summary.html">https://docs.oracle.com/en/java/javase/14/docs/api/java.instrument/java/lang/instrument/package-summary.html</a></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang=""><link itemprop="mainEntityOfPage" href="http://xiaojianzheng.cn/2021/10/29/2021-10-30-Life-Cycle-of-a-Thread-in-Java/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="JIAHE"><meta itemprop="description" content="Collection & Reuse"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="JIAHE"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/10/29/2021-10-30-Life-Cycle-of-a-Thread-in-Java/" class="post-title-link" itemprop="url">Life Cycle of a Thread in Java</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-10-30 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-30T00:00:00+08:00">2021-10-30</time></span></div></div></header><div class="post-body" itemprop="articleBody"><div class="note info"><p>原文地址：<a target="_blank" rel="noopener" href="https://www.baeldung.com/java-thread-lifecycle">https://www.baeldung.com/java-thread-lifecycle</a></p></div><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a><strong>1. Introduction</strong></h2><p>In this article, we&#39;ll discuss in detail a core concept in Java – the lifecycle of a thread.</p><p>We&#39;ll use a quick illustrated diagram and, of course, practical code snippets to better understand these states during the thread execution.</p><p>To get started understanding Threads in Java, <a target="_blank" rel="noopener" href="https://www.baeldung.com/java-runnable-vs-extending-thread">this article</a> on creating a thread is a good place to start.</p><h2 id="2-Multithreading-in-Java"><a href="#2-Multithreading-in-Java" class="headerlink" title="2. Multithreading in Java"></a><strong>2. Multithreading in Java</strong></h2><p><strong>In the Java language, multithreading is driven by the core concept of a Thread</strong>. During their lifecycle, threads go through various states:</p><p><img data-src="https://cdn.jsdelivr.net/gh/xiao1272209235/hexo-image@main/16355829100901635582910076.png" alt="img">](<a target="_blank" rel="noopener" href="https://www.baeldung.com/wp-content/uploads/2018/02/Life_cycle_of_a_Thread_in_Java.jpg">https://www.baeldung.com/wp-content/uploads/2018/02/Life_cycle_of_a_Thread_in_Java.jpg</a>)</p><h2 id="3-Life-Cycle-of-a-Thread-in-Java"><a href="#3-Life-Cycle-of-a-Thread-in-Java" class="headerlink" title="3. Life Cycle of a Thread in Java"></a><strong>3. Life Cycle of a Thread in Java</strong></h2><p>The <em>java.lang.Thread</em> class contains a <em>static State enum –</em> which defines its potential states. During any given point of time, the thread can only be in one of these states:</p><ol><li>*<strong>NEW –</strong> a newly created thread that has not yet started the execution</li><li>*<strong>RUNNABLE –</strong> either running or ready for execution but it&#39;s waiting for resource allocation</li><li>*<strong>BLOCKED –</strong> waiting to acquire a monitor lock to enter or re-enter a synchronized block/method</li><li>*<strong>WAITING –</strong> waiting for some other thread to perform a particular action without any time limit</li><li>*<strong>TIMED_WAITING –</strong> waiting for some other thread to perform a specific action for a specified period</li><li>*<strong>TERMINATED –</strong> has completed its execution</li></ol><p>All these states are covered in the diagram above; let&#39;s now discuss each of these in detail.</p><h3 id="3-1-New"><a href="#3-1-New" class="headerlink" title="3.1. New"></a><strong>3.1. New</strong></h3><p><strong>A NEW Thread (or a Born Thread) is a thread that&#39;s been created but not yet started.</strong> It remains in this state until we start it using the <em>start()</em> method.</p><p>The following code snippet shows a newly created thread that&#39;s in the <em>NEW</em> state:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable runnable = <span class="keyword">new</span> NewState();</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">Log.info(t.getState());</span><br></pre></td></tr></table></figure><p>Since we&#39;ve not started the mentioned thread, the method <em>t.getState()</em> prints:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NEW</span><br></pre></td></tr></table></figure><h3 id="3-2-Runnable"><a href="#3-2-Runnable" class="headerlink" title="3.2. Runnable"></a><strong>3.2. Runnable</strong></h3><p>When we&#39;ve created a new thread and called the <em>start()</em> method on that, it&#39;s moved from <em>NEW</em> to <em>RUNNABLE</em> state. <strong>Threads in this state are either running or ready to run, but they&#39;re waiting for resource allocation from the system.</strong></p><p>In a multi-threaded environment, the Thread-Scheduler (which is part of JVM) allocates a fixed amount of time to each thread. So it runs for a particular amount of time, then relinquishes the control to other <em>RUNNABLE</em> threads.</p><p>For example, let&#39;s add <em>t.start()</em> method to our previous code and try to access its current state:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable runnable = <span class="keyword">new</span> NewState();</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">t.start();</span><br><span class="line">Log.info(t.getState());</span><br></pre></td></tr></table></figure><p>This code is <strong>most likely</strong> to return the output as:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUNNABLE</span><br></pre></td></tr></table></figure><p>Note that in this example, it&#39;s not always guaranteed that by the time our control reaches <em>t.getState()</em>, it will be still in the <em>RUNNABLE</em> state.</p><p>It may happen that it was immediately scheduled by the <em>Thread-Scheduler</em> and may finish execution. In such cases, we may get a different output.</p><h3 id="3-3-Blocked"><a href="#3-3-Blocked" class="headerlink" title="3.3. Blocked"></a><strong>3.3. Blocked</strong></h3><p>A thread is in the <em>BLOCKED</em> state when it&#39;s currently not eligible to run. <strong>It enters this state when it is waiting for a monitor lock and is trying to access a section of code that is locked by some other thread.</strong></p><p>Let&#39;s try to reproduce this state:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DemoThreadB());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DemoThreadB());</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        Log.info(t2.getState());</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoThreadB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        commonResource();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">commonResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// Infinite loop to mimic heavy processing</span></span><br><span class="line">            <span class="comment">// &#x27;t1&#x27; won&#x27;t leave this method</span></span><br><span class="line">            <span class="comment">// when &#x27;t2&#x27; try to enter this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this code:</p><ol><li>We&#39;ve created two different threads – <em>t1</em> and <em>t2</em></li><li><em>t1</em> starts and enters the synchronized <em>commonResource()</em> method; this means that only one thread can access it; all other subsequent threads that try to access this method will be blocked from the further execution until the current one will finish the processing</li><li>When <em>t1</em> enters this method, it is kept in an infinite while loop; this is just to imitate heavy processing so that all other threads cannot enter this method</li><li>Now when we start <em>t2</em>, it tries to enter the <em>commonResource()</em> method, which is already being accessed by <em>t1,</em> thus, <em>t2</em> will be kept in the <em>BLOCKED</em> state</li></ol><p>Being in this state, we call <em>t2.getState()</em> and get the output as:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BLOCKED</span><br></pre></td></tr></table></figure><h3 id="3-4-Waiting"><a href="#3-4-Waiting" class="headerlink" title="3.4. Waiting"></a><strong>3.4. Waiting</strong></h3><p><strong>A thread is in WAITING state when it&#39;s waiting for some other thread to perform a particular action.</strong> <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.State.html#WAITING">According to JavaDocs</a>, any thread can enter this state by calling any one of the following three methods:</p><ol><li><em>object.wait()</em></li><li><em>thread.join()</em> or</li><li><em>LockSupport.park()</em></li></ol><p>Note that in <em>wait()</em> and <em>join()</em> – we do not define any timeout period as that scenario is covered in the next section.</p><p>We have <a target="_blank" rel="noopener" href="https://www.baeldung.com/java-wait-notify">a separate tutorial</a> that discusses in detail the use of <em>wait()</em>, <em>notify()</em> and <em>notifyAll()</em>.</p><p>For now, let&#39;s try to reproduce this state:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingState</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Thread t1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> WaitingState());</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DemoThreadWS());</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoThreadWS</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Log.info(WaitingState.t1.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let&#39;s discuss what we&#39;re doing here:</p><ol><li>We&#39;ve created and started the <em>t1</em></li><li><em>t1</em> creates a <em>t2</em> and starts it</li><li>While the processing of <em>t2</em> continues, we call <em>t2.join()</em>, this puts <em>t1</em> in <em>WAITING</em> state until <em>t2</em> has finished execution</li><li>Since <em>t1</em> is waiting for <em>t2</em> to complete, we&#39;re calling <em>t1.getState()</em> from <em>t2</em></li></ol><p>The output here is, as you&#39;d expect:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WAITING</span><br></pre></td></tr></table></figure><h3 id="3-5-Timed-Waiting"><a href="#3-5-Timed-Waiting" class="headerlink" title="3.5. Timed Waiting"></a><strong>3.5. Timed Waiting</strong></h3><p><strong>A thread is in TIMED_WAITING state when it&#39;s waiting for another thread to perform a particular action within a stipulated amount of time.</strong></p><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.State.html#TIMED_WAITING">According to JavaDocs</a>, there are five ways to put a thread on <em>TIMED_WAITING</em> state:</p><ol><li><em>thread.sleep(long millis)</em></li><li><em>wait(int timeout)</em> or <em>wait(int timeout, int nanos)</em></li><li><em>thread.join(long</em> millis*)*</li><li><em>LockSupport.parkNanos</em></li><li><em>LockSupport.parkUntil</em></li></ol><p>To read more about the differences between <em>wait()</em> and <em>sleep()</em> in Java, have a look at <a target="_blank" rel="noopener" href="https://www.baeldung.com/java-wait-and-sleep">this dedicated article here</a>.</p><p>For now, let&#39;s try to quickly reproduce this state:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimedWaitingState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        DemoThread obj1 = <span class="keyword">new</span> DemoThread();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(obj1);</span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// The following sleep will give enough time for ThreadScheduler</span></span><br><span class="line">        <span class="comment">// to start processing of thread t1</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        Log.info(t1.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, we&#39;ve created and started a thread <em>t1</em> which is entered into the sleep state with a timeout period of 5 seconds; the output will be:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TIMED_WAITING</span><br></pre></td></tr></table></figure><h3 id="3-6-Terminated"><a href="#3-6-Terminated" class="headerlink" title="3.6. Terminated"></a><strong>3.6. Terminated</strong></h3><p>This is the state of a dead thread. <strong>It&#39;s in the TERMINATED state when it has either finished execution or was terminated abnormally.</strong></p><p>We have <a target="_blank" rel="noopener" href="https://www.baeldung.com/java-thread-stop">a dedicated article</a> that discusses different ways of stopping the thread.</p><p>Let&#39;s try to achieve this state in the following example:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminatedState</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TerminatedState());</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// The following sleep method will give enough time for </span></span><br><span class="line">        <span class="comment">// thread t1 to complete</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        Log.info(t1.getState());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// No processing in this block</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, while we&#39;ve started thread <em>t1</em>, the very next statement <em>Thread.sleep(1000)</em> gives enough time for <em>t1</em> to complete and so this program gives us the output as:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TERMINATED</span><br></pre></td></tr></table></figure><p>In addition to the thread state, we can check the <em><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#isAlive()">isAlive()</a></em> method to determine if the thread is alive or not. For instance, if we call the <em>isAlive()</em> method on this thread:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Assert.assertFalse(t1.isAlive());</span><br></pre></td></tr></table></figure><p>It returns <em>false.</em> Put simply, <strong>a thread is alive if and only if it has</strong> <strong>been started and has not yet died.</strong></p><h2 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4. Conclusion"></a><strong>4. Conclusion</strong></h2><p>In this tutorial, we learned about the life-cycle of a thread in Java. We looked at all six states defined by <em>Thread.State</em> enum and reproduced them with quick examples.</p><p>Although the code snippets will give the same output in almost every machine, in some exceptional cases, we may get some different outputs as the exact behavior of Thread Scheduler cannot be determined.</p><p>And, as always, the code snippets used here are <a target="_blank" rel="noopener" href="https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-concurrency-basic-2">available on GitHub</a>.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang=""><link itemprop="mainEntityOfPage" href="http://xiaojianzheng.cn/2021/10/29/2021-10-30-Spring-Application-Context-Events/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="JIAHE"><meta itemprop="description" content="Collection & Reuse"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="JIAHE"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/10/29/2021-10-30-Spring-Application-Context-Events/" class="post-title-link" itemprop="url">Spring Application Context Events</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-10-30 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-30T00:00:00+08:00">2021-10-30</time></span></div></div></header><div class="post-body" itemprop="articleBody"><div class="note info"><p>原文地址：<a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-context-events">https://www.baeldung.com/spring-context-events</a></p></div><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a><strong>1. Introduction</strong></h2><p>In this tutorial, we&#39;ll learn about the event support mechanism provided by the Spring framework. We&#39;ll explore the various built-in events provided by the framework and then see how to consume an event.</p><p>To learn about creating and publishing custom events, have a look at <a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-events">our previous tutorial here.</a></p><p>Spring has an eventing mechanism which is built around the <em>ApplicationContext.</em> It can be used to <strong>exchange information between different beans.</strong> We can make use of application events by listening for events and executing custom code.</p><p>For example, a scenario here would be to execute custom logic on the complete startup of the <em>ApplicationContext</em>.</p><h2 id="2-Standard-Context-Events"><a href="#2-Standard-Context-Events" class="headerlink" title="2. Standard Context Events"></a><strong>2. Standard Context Events</strong></h2><p>In fact, there&#39;re a variety of built-in events in Spring, that <strong>lets a developer hook into the lifecycle of an application and the context</strong> and do some custom operation.</p><p>Even though we rarely use these events manually in an application, the framework uses it intensively within itself. Let&#39;s start by exploring various built-in events in Spring.</p><h3 id="2-1-ContextRefreshedEvent"><a href="#2-1-ContextRefreshedEvent" class="headerlink" title="2.1. ContextRefreshedEvent"></a><strong>2.1. ContextRefreshedEvent</strong></h3><p>On either <strong>initializing or refreshing the</strong> <em><strong>ApplicationContext</strong>,</em> Spring raises the <em>ContextRefreshedEvent</em>. Typically a refresh can get triggered multiple times as long as the context has not been closed.</p><p>Notice that, we can also have the event triggered manually by calling the <em>refresh()</em> method on the <em>ConfigurableApplicationContext</em> interface.</p><h3 id="2-2-ContextStartedEvent"><a href="#2-2-ContextStartedEvent" class="headerlink" title="2.2. ContextStartedEvent"></a><strong>2.2. ContextStartedEvent</strong></h3><p><strong>By calling the start() method</strong> on the <em>ConfigurableApplicationContext,</em> we trigger this event and start the <em>ApplicationContext</em>. As a matter of fact, the method is typically used to restart beans after an explicit stop. We can also use the method to deal components with no configuration for autostart.</p><p><strong>Here, it&#39;s important to note that the call to start() is always explicit as opposed to refresh().</strong></p><h3 id="2-3-ContextStoppedEvent"><a href="#2-3-ContextStoppedEvent" class="headerlink" title="2.3. ContextStoppedEvent"></a><strong>2.3. ContextStoppedEvent</strong></h3><p>A <em>ContextStoppedEvent</em> is published <strong>when the ApplicationContext is stopped</strong>, by invoking the <em>stop()</em> method on the <em>ConfigurableApplicationContext.</em> As discussed earlier, we can restart a stopped event by using <em>start()</em> method.</p><h3 id="2-4-ContextClosedEvent"><a href="#2-4-ContextClosedEvent" class="headerlink" title="2.4. ContextClosedEvent"></a><strong>2.4. ContextClosedEvent</strong></h3><p>This event is published <strong>when the ApplicationContext is closed</strong>, using the <em>close()</em> method in <em>ConfigurableApplicationContext</em>.<br>In reality, after closing a context, we cannot restart it.</p><p>A context reaches its end of life on closing it and hence we cannot restart it like in a <em>ContextStoppedEvent.</em></p><h2 id="3-Event-Listener"><a href="#3-Event-Listener" class="headerlink" title="3. @Event Listener"></a><strong>3. @Event Listener</strong></h2><p>Next, let us explore how to consume the published events. Starting from version 4.2, Spring supports an annotation-driven event listener – <em>@Event Listener.</em></p><p>In particular, we can make use of this annotation to <strong>automatically register an Application Listener based on the signature of the method</strong> :</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleContextRefreshEvent</span><span class="params">(ContextStartedEvent ctxStartEvt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Context Start Event received.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Significantly, <strong>@Event Listener is a core annotation and hence doesn&#39;t need any extra configuration</strong>. In fact, the existing <em><a href="context:annotation-driven/">context:annotation-driven/</a></em> element provides full support to it.</p><p>A method annotated with <em>@Event Listener</em> can return a non-void type. If the value returned is non-null, the eventing mechanism will publish a new event for it.</p><h3 id="3-1-Listening-to-Multiple-Events"><a href="#3-1-Listening-to-Multiple-Events" class="headerlink" title="3.1. Listening to Multiple Events"></a><strong>3.1. Listening to Multiple Events</strong></h3><p>Now, there might arise situations where we will need our listener to consume multiple events.</p><p>For such a scenario, we can make use of <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/event/EventListener.html#classes">classes</a> attribute:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EventListener(classes = &#123; ContextStartedEvent.class, ContextStoppedEvent.class &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMultipleEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Multi-event listener invoked&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Application-Event-Listener"><a href="#4-Application-Event-Listener" class="headerlink" title="4. Application Event Listener"></a><strong>4. Application Event Listener</strong></h2><p>If we&#39;re using earlier versions of Spring (&lt;4.2), we&#39;ll have to introduce a <a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-events">custom <em>ApplicationEventListener</em> and override the method <em>onApplicationEvent</em></a> to listen to an event.</p><h2 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5. Conclusion"></a><strong>5. Conclusion</strong></h2><p>In this article, we&#39;ve explored the various built-in events in Spring. In addition, we&#39;ve seen various ways to listen to the published events.</p><p>As always, the code snippets used in the article can be found <a target="_blank" rel="noopener" href="https://github.com/eugenp/tutorials/tree/master/spring-core">over on Github</a>.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"> <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">湘ICP备19011756号-1</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">JIAHE</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.6/pdfobject.min.js","integrity":"sha256-77geM50MfxCD17eqyJR+Dag1svjJOLN+BJ2F/DMqMEY="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"ignores":null,"url":"http://xiaojianzheng.cn/"}</script><script src="/js/third-party/quicklink.js"></script><script>"use strict";"serviceWorker"in navigator&&navigator.serviceWorker.register("service-worker.js").then(function(r){r.onupdatefound=function(){var e=r.installing;e.onstatechange=function(){switch(e.state){case"installed":navigator.serviceWorker.controller?console.log("New or updated content is available."):console.log("Content is now available offline!");break;case"redundant":console.error("The installing service worker became redundant.")}}}}).catch(function(e){console.error("Error during service worker registration:",e)})</script></body></html>