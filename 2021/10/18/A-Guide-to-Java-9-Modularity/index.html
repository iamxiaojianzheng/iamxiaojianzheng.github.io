<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"xiaojianzheng.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><meta name="description" content="原文地址：https:&#x2F;&#x2F;www.baeldung.com&#x2F;java-9-modularity 以下中文翻译为作者根据自己的理解+Google+YouDao作为参考翻译而得，存在偏颇之处请读者查看对应原文，自行理解。   1. OverviewJava 9 introduces a new level of abstraction above packages, formally known as"><meta property="og:type" content="article"><meta property="og:title" content="A Guide to Java 9 Modularity"><meta property="og:url" content="http://xiaojianzheng.cn/2021/10/18/A-Guide-to-Java-9-Modularity/index.html"><meta property="og:site_name" content="JIAHE"><meta property="og:description" content="原文地址：https:&#x2F;&#x2F;www.baeldung.com&#x2F;java-9-modularity 以下中文翻译为作者根据自己的理解+Google+YouDao作为参考翻译而得，存在偏颇之处请读者查看对应原文，自行理解。   1. OverviewJava 9 introduces a new level of abstraction above packages, formally known as"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-10-18T16:00:00.000Z"><meta property="article:modified_time" content="2021-10-18T16:00:00.000Z"><meta property="article:author" content="JIAHE"><meta property="article:tag" content="Java"><meta property="article:tag" content="JDK9"><meta property="article:tag" content="翻译"><meta property="article:tag" content="转载"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://xiaojianzheng.cn/2021/10/18/A-Guide-to-Java-9-Modularity/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://xiaojianzheng.cn/2021/10/18/A-Guide-to-Java-9-Modularity/","path":"2021/10/18/A-Guide-to-Java-9-Modularity/","title":"A Guide to Java 9 Modularity"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>A Guide to Java 9 Modularity | JIAHE</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">JIAHE</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-导航"><a href="/navigation/" rel="section"><i class="fa fa-location-arrow fa-fw"></i>导航</a></li><li class="menu-item menu-item-文档"><a href="/docs/" rel="section"><i class="fa fa-book fa-fw fa-fw"></i>文档</a></li><li class="menu-item menu-item-cheat-sheet"><a href="/cheat-sheet/" rel="section"><i class="fas fa-pen fa-fw"></i>Cheat Sheet</a></li><li class="menu-item menu-item-软件安装部署"><a href="/software-install-and-deploy/" rel="section"><i class="fab fa-windows fa-fw"></i>软件安装部署</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Overview"><span class="nav-number">1.</span> <span class="nav-text">1. Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-What-39-s-a-Module"><span class="nav-number">2.</span> <span class="nav-text">2. What&#39;s a Module?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Packages"><span class="nav-number">2.1.</span> <span class="nav-text">2.1. Packages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Resources"><span class="nav-number">2.2.</span> <span class="nav-text">2.2. Resources</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Module-Descriptor"><span class="nav-number">2.3.</span> <span class="nav-text">2.3. Module Descriptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Module-Types"><span class="nav-number">2.4.</span> <span class="nav-text">2.4. Module Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Distribution"><span class="nav-number">2.5.</span> <span class="nav-text">2.5. Distribution</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Default-Modules"><span class="nav-number">3.</span> <span class="nav-text">3. Default Modules</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Module-Declarations"><span class="nav-number">4.</span> <span class="nav-text">4. Module Declarations</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Requires"><span class="nav-number">4.1.</span> <span class="nav-text">4.1. Requires</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Requires-Static"><span class="nav-number">4.2.</span> <span class="nav-text">4.2. Requires Static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Requires-Transitive"><span class="nav-number">4.3.</span> <span class="nav-text">4.3. Requires Transitive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-Exports"><span class="nav-number">4.4.</span> <span class="nav-text">4.4. Exports</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-Exports-%E2%80%A6-To"><span class="nav-number">4.5.</span> <span class="nav-text">4.5. Exports … To</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-Uses"><span class="nav-number">4.6.</span> <span class="nav-text">4.6. Uses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-Provides-%E2%80%A6-With"><span class="nav-number">4.7.</span> <span class="nav-text">4.7. Provides … With</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-Open"><span class="nav-number">4.8.</span> <span class="nav-text">4.8. Open</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-Opens"><span class="nav-number">4.9.</span> <span class="nav-text">4.9. Opens</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-Opens-%E2%80%A6-To"><span class="nav-number">4.10.</span> <span class="nav-text">4.10. Opens … To</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Command-Line-Options"><span class="nav-number">5.</span> <span class="nav-text">5. Command Line Options</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Visibility"><span class="nav-number">6.</span> <span class="nav-text">6. Visibility</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-Putting-It-All-Together"><span class="nav-number">7.</span> <span class="nav-text">7. Putting It All Together</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-Setting-Up-Our-Project"><span class="nav-number">7.1.</span> <span class="nav-text">7.1. Setting Up Our Project</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-Our-First-Module"><span class="nav-number">7.2.</span> <span class="nav-text">7.2. Our First Module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-Our-Second-Module"><span class="nav-number">7.3.</span> <span class="nav-text">7.3. Our Second Module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-Building-Our-Modules"><span class="nav-number">7.4.</span> <span class="nav-text">7.4. Building Our Modules</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-Running-Our-Code"><span class="nav-number">7.5.</span> <span class="nav-text">7.5. Running Our Code</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-Adding-a-Service"><span class="nav-number">7.6.</span> <span class="nav-text">7.6. Adding a Service</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-Adding-Modules-to-the-Unnamed-Module"><span class="nav-number">8.</span> <span class="nav-text">8. Adding Modules to the Unnamed Module</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-Conclusion"><span class="nav-number">9.</span> <span class="nav-text">9. Conclusion</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="JIAHE" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">JIAHE</p><div class="site-description" itemprop="description">Collection & Reuse</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">85</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">88</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com&#x2F;" rel="noopener" target="_blank">Baidu</a></li><li class="links-of-blogroll-item"> <a href="https://cn.bing.com/" title="https:&#x2F;&#x2F;cn.bing.com&#x2F;" rel="noopener" target="_blank">Bing</a></li><li class="links-of-blogroll-item"> <a href="https://www.google.com/" title="https:&#x2F;&#x2F;www.google.com&#x2F;" rel="noopener" target="_blank">Google</a></li><li class="links-of-blogroll-item"> <a href="https://zh.wikipedia.org/wiki/Wikipedia:%E9%A6%96%E9%A1%B5" title="https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Wikipedia:%E9%A6%96%E9%A1%B5" rel="noopener" target="_blank">Wiki</a></li><li class="links-of-blogroll-item"> <a href="https://projectlombok.org/" title="https:&#x2F;&#x2F;projectlombok.org&#x2F;" rel="noopener" target="_blank">lombok</a></li><li class="links-of-blogroll-item"> <a href="https://logging.apache.org/log4j/2.x/" title="https:&#x2F;&#x2F;logging.apache.org&#x2F;log4j&#x2F;2.x&#x2F;" rel="noopener" target="_blank">log4j</a></li><li class="links-of-blogroll-item"> <a href="http://logback.qos.ch/" title="http:&#x2F;&#x2F;logback.qos.ch&#x2F;" rel="noopener" target="_blank">logback</a></li><li class="links-of-blogroll-item"> <a href="https://junit.org/junit5/" title="https:&#x2F;&#x2F;junit.org&#x2F;junit5&#x2F;" rel="noopener" target="_blank">junit</a></li><li class="links-of-blogroll-item"> <a href="https://element.eleme.cn/#/zh-CN" title="https:&#x2F;&#x2F;element.eleme.cn&#x2F;#&#x2F;zh-CN" rel="noopener" target="_blank">ElementUI</a></li><li class="links-of-blogroll-item"> <a href="https://zipkin.io/" title="https:&#x2F;&#x2F;zipkin.io&#x2F;" rel="noopener" target="_blank">Zipkin</a></li><li class="links-of-blogroll-item"> <a href="https://www.selenium.dev/zh-cn/" title="https:&#x2F;&#x2F;www.selenium.dev&#x2F;zh-cn&#x2F;" rel="noopener" target="_blank">Selenium</a></li><li class="links-of-blogroll-item"> <a href="https://nacos.io/zh-cn/docs/what-is-nacos.html" title="https:&#x2F;&#x2F;nacos.io&#x2F;zh-cn&#x2F;docs&#x2F;what-is-nacos.html" rel="noopener" target="_blank">Nacos</a></li><li class="links-of-blogroll-item"> <a href="https://dev.mysql.com/downloads/" title="https:&#x2F;&#x2F;dev.mysql.com&#x2F;downloads&#x2F;" rel="noopener" target="_blank">MySQL-Download</a></li><li class="links-of-blogroll-item"> <a href="https://redis.io/" title="https:&#x2F;&#x2F;redis.io&#x2F;" rel="noopener" target="_blank">Redis</a></li><li class="links-of-blogroll-item"> <a href="https://www.jetbrains.com/help/idea/discover-intellij-idea.html" title="https:&#x2F;&#x2F;www.jetbrains.com&#x2F;help&#x2F;idea&#x2F;discover-intellij-idea.html" rel="noopener" target="_blank">IDEA-Document</a></li><li class="links-of-blogroll-item"> <a href="https://jdk.java.net/" title="https:&#x2F;&#x2F;jdk.java.net&#x2F;" rel="noopener" target="_blank">JDK</a></li><li class="links-of-blogroll-item"> <a href="https://www.oracle.com/java/technologies/downloads/archive/" title="https:&#x2F;&#x2F;www.oracle.com&#x2F;java&#x2F;technologies&#x2F;downloads&#x2F;archive&#x2F;" rel="noopener" target="_blank">JDK-Oracle</a></li><li class="links-of-blogroll-item"> <a href="https://poi.apache.org/components/index.html" title="https:&#x2F;&#x2F;poi.apache.org&#x2F;components&#x2F;index.html" rel="noopener" target="_blank">POI</a></li><li class="links-of-blogroll-item"> <a href="https://assertj.github.io/doc/" title="https:&#x2F;&#x2F;assertj.github.io&#x2F;doc&#x2F;" rel="noopener" target="_blank">AssertJ</a></li><li class="links-of-blogroll-item"> <a href="https://docshome.gitbook.io/nginx-docs/" title="https:&#x2F;&#x2F;docshome.gitbook.io&#x2F;nginx-docs&#x2F;" rel="noopener" target="_blank">Nginx-CN</a></li><li class="links-of-blogroll-item"> <a href="https://github.com/cglib/cglib" title="https:&#x2F;&#x2F;github.com&#x2F;cglib&#x2F;cglib" rel="noopener" target="_blank">cglib</a></li></ul></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://xiaojianzheng.cn/2021/10/18/A-Guide-to-Java-9-Modularity/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="JIAHE"><meta itemprop="description" content="Collection & Reuse"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="JIAHE"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> A Guide to Java 9 Modularity</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-10-19 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-19T00:00:00+08:00">2021-10-19</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><div class="note info"><p>原文地址：<a target="_blank" rel="noopener" href="https://www.baeldung.com/java-9-modularity">https://www.baeldung.com/java-9-modularity</a></p><p>以下中文翻译为作者根据自己的理解+Google+YouDao作为参考翻译而得，存在偏颇之处请读者查看对应原文，自行理解。</p></div><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a><strong>1. Overview</strong></h2><p>Java 9 introduces a new level of abstraction above packages, formally known as the Java Platform Module System (JPMS), or “Modules” for short.</p><p>Java 9基于package引入了一个新的抽象级别，正式称为Java平台模块系统（JPMS）或“模块”。</p><p>In this tutorial, we&#39;ll go through the new system and discuss its various aspects.</p><p>在本教程中，我们将通过一个新系统来探索其各个方面。</p><p>We&#39;ll also build a simple project to demonstrate all concepts we&#39;ll be learning in this guide.</p><p>我们也将构建一个简单的工程来演示我们在本教程中的学到的所有的概念。</p><span id="more"></span><h2 id="2-What-39-s-a-Module"><a href="#2-What-39-s-a-Module" class="headerlink" title="2. What&#39;s a Module?"></a><strong>2. What&#39;s a Module?</strong></h2><p>First of all, we need to understand what a module is before we can understand how to use them.</p><p>首先，我们需要先理解模块是什么，然后才能理解如何使用它们。</p><p><strong>A Module is a group of closely related packages and resources along with a new module descriptor file.</strong></p><p>模块是一组紧密相关的包和资源以及一个新的模块描述符文件的集合。</p><p>In other words, it&#39;s a “package of Java Packages” abstraction that allows us to make our code even more reusable.</p><p>换句话说，它是一个“Java Packages的Package”抽象，允许我们使代码更加可重用。</p><h3 id="2-1-Packages"><a href="#2-1-Packages" class="headerlink" title="2.1. Packages"></a><strong>2.1. Packages</strong></h3><p>The packages inside a module are identical to the Java packages we&#39;ve been using since the inception of Java.</p><p>模块中的包与我们自Java诞生以来一直使用的Java包完全相同。</p><p>When we create a module, <strong>we organize the code internally in packages just like we previously did with any other project.</strong></p><p>当我们创建一个模块时，<strong>我们在包中内部组织代码，就像我们以前在任何其他项目中所做的那样</strong>。</p><p>Aside from organizing our code, packages are used to determine what code is publicly accessible outside of the module. We&#39;ll spend more time talking about this later in the article.</p><p>除了组织我们的代码，包还用于确定哪些代码可以在模块外部公开被访问。我们将在本文后面花更多时间讨论这个问题。</p><h3 id="2-2-Resources"><a href="#2-2-Resources" class="headerlink" title="2.2. Resources"></a><strong>2.2. Resources</strong></h3><p><strong>Each module is responsible for its resources, like media or configuration files.</strong></p><p><strong>每个模块负责其资源，如媒体或配置文件</strong>。</p><p>Previously we&#39;d put all resources into the root level of our project and manually manage which resources belonged to different parts of the application.</p><p>以前，我们将所有资源放在项目的根目录下，并手动管理这些资源到应用程序的不同位置。</p><p>With modules, we can ship required images and XML files with the module that needs it, making our projects much easier to manage.</p><p>通过模块，我们可以将所需的图像和XML文件与需要它的模块一起发布，从而使我们的项目更容易管理。</p><h3 id="2-3-Module-Descriptor"><a href="#2-3-Module-Descriptor" class="headerlink" title="2.3. Module Descriptor"></a><strong>2.3. Module Descriptor</strong></h3><p>When we create a module, we include a descriptor file that defines several aspects of our new module:</p><p>当我们创建一个模块时，我们需要包含一个描述符文件，用于定义新模块的这几个方面：</p><ul><li><strong>Name</strong> – the name of our module 模块的名称</li><li><strong>Dependencies</strong> – a list of other modules that this module depends on 该模块依赖的其他模块列表</li><li><strong>Public Packages</strong> – a list of all packages we want accessible from outside the module 我们希望从模块外部访问的所有包的列表</li><li><strong>Services Offered</strong> – we can provide service implementations that can be consumed by other modules 我们可以提供服务的具体实现用于其他模块的消费使用</li><li><strong>Services Consumed</strong> – allows the current module to be a consumer of a service 允许当前模块成为服务的消费者</li><li><strong>Reflection Permissions</strong> – explicitly allows other classes to use reflection to access the private members of a package 显式地允许其他类使用反射来访问包的私有成员</li></ul><p>The module naming rules are similar to how we name packages (dots are allowed, dashes are not). It&#39;s very common to do either project-style (my.module) or Reverse-DNS (<em>com.baeldung.mymodule</em>) style names. We&#39;ll use project-style in this guide.</p><p>模块命名规则类似于我们命名包的方式(允许使用点，不允许使用破折号)。使用 <em>project-style</em> (my.module)或Reverse-DNS (<em>com.baeldung.mymodule</em>)风格的名称是很常见的。在本指南中，我们将使用<em>project-style</em>。</p><p><strong>We need to list all packages we want to be public because by default all packages are module private.</strong></p><p><strong>我们需要列出所有想要公开的包，因为默认情况下所有包都是模块私有的。</strong></p><p>The same is true for reflection. By default, we cannot use reflection on classes we import from another module.</p><p>反射也是如此。默认情况下，不能对从其他模块导入的类使用反射。</p><p>Later in the article, we&#39;ll look at examples of how to use the module descriptor file.</p><p>在本文的末尾，我们将学习如何使用模块描述符文件的示例。</p><h3 id="2-4-Module-Types"><a href="#2-4-Module-Types" class="headerlink" title="2.4. Module Types"></a><strong>2.4. Module Types</strong></h3><p>There are four types of modules in the new module system:</p><p>新模块系统中有四种类型的模块：</p><ul><li><strong>System Modules</strong> – These are the modules listed when we run the <em>list-modules</em> command above. They include the Java SE and JDK modules.</li><li><strong>系统模块</strong> – 这些是运行上面的<em>list-modules</em>命令时列出的模块。它们包括Java SE和JDK模块。</li><li><strong>Application Modules</strong> – These modules are what we usually want to build when we decide to use Modules. They are named and defined in the compiled <em>module-info.class</em> file included in the assembled JAR.</li><li><strong>应用模块</strong> – 当我们决定使用模块时，这些模块是我们通常想要构建的。它们是在组装的JAR中包含的编译过的<em>module-info.class</em>文件中命名和定义的。</li><li><strong>Automatic Modules</strong> – We can include unofficial modules by adding existing JAR files to the module path. The name of the module will be derived from the name of the JAR. Automatic modules will have full read access to every other module loaded by the path.</li><li><strong>自动模块</strong> – 我们可以通过将现有JAR文件添加到模块路径中来包含非官方模块。模块的名称将从JAR的名称派生出来。自动模块将对路径加载的所有其他模块具有完全读访问权。</li><li><strong>Unnamed Module</strong> – When a class or JAR is loaded onto the classpath, but not the module path, it&#39;s automatically added to the unnamed module. It&#39;s a catch-all module to maintain backward compatibility with previously-written Java code.</li><li><strong>未命名模块</strong> – 当类或JAR加载到类路径而不是模块路径时，它会自动添加到未命名的模块。它是一个全能模块，用于维护以前编写的Java代码，以保证向后的兼容性。</li></ul><h3 id="2-5-Distribution"><a href="#2-5-Distribution" class="headerlink" title="2.5. Distribution"></a><strong>2.5. Distribution</strong></h3><p>Modules can be distributed one of two ways: as a JAR file or as an “exploded” compiled project. This, of course, is the same as any other Java project so it should come as no surprise.</p><p>模块可以通过以下两种方式分发：作为JAR文件分发，或者作为已编译项目分发。当然，这与任何其他Java项目是一样的，所以应该不会感到惊讶。</p><p>We can create multi-module projects comprised of a “main application” and several library modules.</p><p>我们可以创建由“主应用程序”和多个模块组成的多模块项目。</p><p><strong>We have to be careful though because we can only have one module per JAR file.</strong></p><p><strong>我们必须要注意的是每个jar文件只能有一个模块。</strong></p><p>When we set up our build file, we need to make sure to bundle each module in our project as a separate jar.</p><p>当我们构建项目时，需要确保将项目中的每个模块打包为一个单独的jar。</p><h2 id="3-Default-Modules"><a href="#3-Default-Modules" class="headerlink" title="3. Default Modules"></a><strong>3. Default Modules</strong></h2><p>When we install Java 9, we can see that the JDK now has a new structure.</p><p>当我们安装Java 9时，我们可以看到JDK现在有了一个新的结构。</p><p>They have taken all the original packages and moved them into the new module system.</p><p>他们已经将所有的原始包转移到新的模块系统中。</p><p>We can see what these modules are by typing into the command line:</p><p>我们可以通过输入以下命令来查看这些模块：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java --list-modules</span><br></pre></td></tr></table></figure><p>These modules are split into four major groups: <em>java, javafx, jdk,</em> and <em>Oracle</em>.</p><p>这些模块包含四个主要的分组：<em>java，javafx，jdk，</em>和<em>Oracle</em>。</p><p><em>java</em> modules are the implementation classes for the core SE Language Specification.</p><p><em>java</em>模块是核心SE语言的实现类。</p><p><em>javafx</em> modules are the FX UI libraries.</p><p><em>javafx</em>模块是FX UI的依赖模块。</p><p><strong>Anything needed by the JDK itself is kept in the *jdk* modules.</strong></p><p><strong>JDK自身所需要的都放在<em>jdk</em>模块中。</strong></p><p>And finally, <strong>anything that is Oracle-specific is in the *oracle* modules.</strong></p><p>最后，<strong>任何与Oracle相关的内容放在<em>oracle</em>模块中。</strong></p><h2 id="4-Module-Declarations"><a href="#4-Module-Declarations" class="headerlink" title="4. Module Declarations"></a><strong>4. Module Declarations</strong></h2><p><strong>To set up a module, we need to put a special file at the root of our packages named <em>module-info.java</em>.</strong></p><p><strong>构建一个模块时，需要添加一个<em>module-info.java</em>文件，放在包的根路径下。</strong></p><p>This file is known as the module descriptor and contains all of the data needed to build and use our new module.</p><p>此文件称为模块描述符，并包含构建和使用我们新模块所需的所有数据。</p><p>We construct the module with a declaration whose body is either empty or made up of module directives:</p><p>该文件的主体为空，或者包含读个多个模块指令。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> myModuleName &#123;</span><br><span class="line">    <span class="comment">// all directives are optional</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We start the module declaration with the <em>module</em> keyword, and we follow that with the name of the module.</p><p>通过<em>module</em>关键字作为开头，后面加上模块的名称来作为模块定义的开头。</p><p>The module will work with this declaration, but we&#39;ll commonly need more information.</p><p>一个模块需要如此声明才能正常使用，但通常还会包含其他东西。</p><p>That is where the module directives come in.</p><p>具体描述模块的指令就加入其中。</p><h3 id="4-1-Requires"><a href="#4-1-Requires" class="headerlink" title="4.1. Requires"></a><strong>4.1. Requires</strong></h3><p>Our first directive is <em>requires</em>. This module directive allows us to declare module dependencies:</p><p>首先介绍<em>requires</em>。该模块指令允许我们声明模块的依赖项：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">requires</span> <span class="keyword">module</span>.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now, <em>my.module</em> has <strong>both a runtime and a compile-time dependency</strong> on <em>module.name</em>.</p><p>此时，<em>my.module</em>模块包含<strong>运行时和编译时</strong>所需的<em>module.name</em>模块。</p><p>And all public types exported from a dependency are accessible by our module when we use this directive.</p><p>当我们使用此指令时，我们的模块可以从依赖中访问到所有的公开的内容。</p><h3 id="4-2-Requires-Static"><a href="#4-2-Requires-Static" class="headerlink" title="4.2. Requires Static"></a><strong>4.2. Requires Static</strong></h3><p>Sometimes we write code that references another module, but that users of our library will never want to use.</p><p>有时我们需要引用另一个模块来写代码，但是实际运行项目时并不需要该模块的参与。（例如：lombok）</p><p>For instance, we might write a utility function that pretty-prints our internal state when another logging module is present. But, not every consumer of our library will want this functionality, and they don&#39;t want to include an extra logging library.</p><p>例如，我们可能会编写一个utility函数时需要另一个logging模块来帮助格式化打印内部状态。但是并非每个使用我们模块的都需要这个函数，并且他们并不想引入一个额外的日志依赖，或者他们本身就自带了日志系统。</p><p>In these cases, we want to use an optional dependency. By using the <em>requires static</em> directive, we create a compile-time-only dependency:</p><p>在这些情况下，我们希望使用可选的依赖项。通过使用<em>requires static</em>指令，我们引入了一个仅编译时参与的依赖项：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">requires</span> <span class="keyword">static</span> <span class="keyword">module</span>.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-Requires-Transitive"><a href="#4-3-Requires-Transitive" class="headerlink" title="4.3. Requires Transitive"></a><strong>4.3. Requires Transitive</strong></h3><p>We commonly work with libraries to make our lives easier.</p><p>But, we need to make sure that any module that brings in our code will also bring in these extra ‘transitive&#39; dependencies or they won&#39;t work.</p><p>但是，我们需要确保在我们的代码中添加的任何模块也将引入这些额外的“transitive”依赖项，否则他们无法正常工作。</p><p>Luckily, we can use the <em>requires transitive</em> directive to force any downstream consumers also to read our required dependencies:</p><p>幸运的是，我们可以使用<em>requires transitive</em>指令来强制任何下游消费者也来阅读我们所需的依赖项。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">requires</span> transitive <span class="keyword">module</span>.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now, when a developer <em>requires my.module</em>, they won&#39;t also have also to say <em>requires module.name</em> for our module to still work.</p><p>现在，当开发者引入<em>my.module</em>时，他们不会抱怨说还需要引入<em>module.name</em>模块才能正常使用<em>my.module</em>模块。</p><h3 id="4-4-Exports"><a href="#4-4-Exports" class="headerlink" title="4.4. Exports"></a><strong>4.4. Exports</strong></h3><p><strong>By default, a module doesn&#39;t expose any of its API to other modules.</strong> This <em>strong encapsulation</em> was one of the key motivators for creating the module system in the first place.</p><p><strong>默认情况下，模块不会将任何API暴露给其他模块。</strong> <em>强封装</em>是创建模块系统的关键动机之一。</p><p>Our code is significantly more secure, but now we need to explicitly open our API up to the world if we want it to be usable.</p><p>如此我们的代码将更加安全，但是如果我们希望它能够被使用的话，就需要将其暴露到外界。</p><p><strong>We use the <em>exports</em> directive to expose all public members of the named package:</strong></p><p>我们使用<em>exports</em>指令来暴露已声明package中的所有public成员</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.my.<span class="keyword">package</span>.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now, when someone does <em>requires my.module</em>, they will have access to the public types in our <em>com.my.package.name</em> package, but not any other package.</p><p>现在，当有人<em>requires my.module</em>时，他们将可以访问到我们<em>com.my.package.name</em>包下的public成员，但是其他包无法访问。</p><h3 id="4-5-Exports-…-To"><a href="#4-5-Exports-…-To" class="headerlink" title="4.5. Exports … To"></a><strong>4.5. Exports … To</strong></h3><p><strong>We can use <em>exports…to</em> to open up our public classes to the world.</strong></p><p>我们可以使用<em>exports...to</em>开放给外界访问public类。</p><p>But, what if we don&#39;t want the entire world to access our API?</p><p>但是如果我们不希望暴露API给到所有使用者该怎么办呢？</p><p><strong>We can restrict which modules have access to our APIs using the <em>exports…to</em> directive.</strong></p><p><strong>我们可以使用<em>exports...to</em>指令，来限制哪些模块可以访问我们的API。</strong></p><p>Similar to the <em>exports</em> directive, we declare a package as exported. But, we also list which modules we are allowing to import this package as a <em>requires</em>. Let&#39;s see what this looks like:</p><p>类似于<em>export</em>指令，我们可以声明需要暴露的包， 但是还指定哪些模块可以访问这个包。 看起来就像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="comment">// 将com.my.package.name仅暴露给com.specific.package访问</span></span><br><span class="line">    export com.my.<span class="keyword">package</span>.name to com.specific.<span class="keyword">package</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-Uses"><a href="#4-6-Uses" class="headerlink" title="4.6. Uses"></a><strong>4.6. Uses</strong></h3><p>A <em>service</em> is an implementation of a specific interface or abstract class that can be <em>consumed</em> by other classes.</p><p>服务是一个可以被其他类消费的具体接口实现类或抽象类的扩展。</p><p><strong>We designate the services our module consumes with the <em>uses</em> directive.</strong></p><p><strong>可以通过<em>uses</em>指令来指定我们模块可以消费的服务。</strong></p><p>Note that <strong>the class name we <em>use</em> is either the interface or abstract class of the service, not the implementation class</strong>:</p><p>请注意，<strong><em>uses</em> 后面的类名是服务的接口或抽象类，而不是实现类</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    uses class.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We should note here that there&#39;s a difference between a <em>requires</em> directive and the <em>uses</em> directive.</p><p>我们应该注意到<em>requires</em>和<em>uses</em>指令之间的差异。</p><p>We might <em>require</em> a module that provides a service we want to consume, but that service implements an interface from one of its transitive dependencies.</p><p>我们可能需要一个可供消费所需服务的模块，但是该服务实现了一个来自它的一个传递依赖项的接口。</p><p>Instead of forcing our module to require <em>all</em> transitive dependencies just in case, we use the <em>uses</em> directive to add the required interface to the module path.</p><p>我们可以使用<em>uses</em>指令将所需的接口添加到模块路径，而不是为了以防万一强迫我们的模块导入<em>所有的</em>传递依赖。</p><h3 id="4-7-Provides-…-With"><a href="#4-7-Provides-…-With" class="headerlink" title="4.7. Provides … With"></a><strong>4.7. Provides … With</strong></h3><p><strong>A module can also be a <em>service provider</em> that other modules can consume.</strong></p><p><strong>一个模块也可以是可供其他模块使用的服务提供者。</strong></p><p>The first part of the directive is the <em>provides</em> keyword. Here is where we put the interface or abstract class name.</p><p>指令的第一部分是<em>provides</em>关键字。这里是我们放置接口或抽象类名的地方。</p><p>Next, we have the <em>with</em> directive where we provide the implementation class name that either <em>implements</em> the interface or <em>extends</em> the abstract class.</p><p>接下来，我们有<em>with</em>指令，其中我们需要提供实现类名，该实现类名要么实现了接口，要么扩展了抽象类。</p><p>Here&#39;s what it looks like put together:</p><p>下面是它组合的样子:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    provides MyInterface with MyInterfaceImpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-Open"><a href="#4-8-Open" class="headerlink" title="4.8. Open"></a><strong>4.8. Open</strong></h3><p>We mentioned earlier that encapsulation was a driving motivator for the design of this module system.</p><p>我们前面提到过封装是设计这个模块系统的一个驱动因素。</p><p>Before Java 9, it was possible to use reflection to examine every type and member in a package, even the <em>private</em> ones. Nothing was truly encapsulated, which can open up all kinds of problems for developers of the libraries.</p><p>Java 9之前，可以使用反射来检查包中所有类和成员，甚至<em>private</em>的。这并不是真正的封装，还可能会给库的开发人员带来各种问题。</p><p>Because Java 9 enforces <em>strong encapsulation</em>, <strong>we now have to explicitly grant permission for other modules to reflect on our classes.</strong></p><p>因为Java 9强制执行<em>强封装</em>，<strong>我们现在必须显式地授予其他模块反射类的权限。</strong></p><p>If we want to continue to allow full reflection as older versions of Java did, we can simply <em>open</em> the entire module up:</p><p>如果我们想继续像以前的Java版本那样允许完全反射，我们可以简单地<em>open</em>整个模块:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">open <span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-Opens"><a href="#4-9-Opens" class="headerlink" title="4.9. Opens"></a><strong>4.9. Opens</strong></h3><p>If we need to allow reflection of private types, but we don&#39;t want all of our code exposed, <strong>we can use the *opens* directive to expose specific packages.</strong></p><p>But remember, this will open the package up to the entire world, so make sure that is what you want:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">  opens com.my.<span class="keyword">package</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-10-Opens-…-To"><a href="#4-10-Opens-…-To" class="headerlink" title="4.10. Opens … To"></a><strong>4.10. Opens … To</strong></h3><p>Okay, so reflection is great sometimes, but we still want as much security as we can get from <em>encapsulation</em>. <strong>We can selectively open our packages to a pre-approved list of modules, in this case, using the *opens…to* directive</strong>:</p><p>反射总体是好的，但我们仍然希望从<em>封装</em>中获得尽可能多的安全性。<strong>我们可以有选择地打开我们的包到一个预先批准的模块列表，在本例中，使用* opened…to*指令</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    opens com.my.<span class="keyword">package</span> to moduleOne, moduleTwo, etc.;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Command-Line-Options"><a href="#5-Command-Line-Options" class="headerlink" title="5. Command Line Options"></a><strong>5. Command Line Options</strong></h2><p>By now, support for Java 9 modules has been added to Maven and Gradle, so you won&#39;t need to do a lot of manual building of your projects. However, it&#39;s still valuable to know <em>how</em> to use the module system from the command line.</p><p>到目前为止，Maven和Gradle已经添加了对Java 9模块的支持，因此您不需要进行大量的项目手工构建。然而，知道<em>如何</em>从命令行使用模块系统仍然是有必要的。</p><p>We&#39;ll be using the command line for our full example down below to help solidify how the entire system works in our minds.</p><p>在下面的完整示例中，我们将以理解中的工作方式，使用命令行来帮助巩固整个系统。</p><ul><li><em><strong>module-path</strong></em> <strong>–</strong> We use the <em>–module-path</em> option to specify the module path. This is a list of one or more directories that contain your modules. 我们使用 <em>--module-path</em> 选项来指定模块路径。这是包含模块的一个或多个目录的列表。（Windows用 <strong>;</strong> 分号隔开，Mac、Linux用 <strong>:</strong> 冒号）</li><li><em><strong>add-reads</strong></em> – Instead of relying on the module declaration file, we can use the command line equivalent of the <em>requires</em> directive; <em>–add-reads</em>. 代替依赖于模块声明文件，我们可以使用命令行中等效的<em>requires</em>; <em>--add-reads</em> 指令。</li><li><em><strong>add-exports</strong></em> <strong>–</strong> Command line replacement for the <em>exports</em> directive. 命令行替换<em>exports</em>指令。</li><li><em><strong>add-opens</strong></em> <em>–</em> Replace the <em>open</em> clause in the module declaration file. 替换模块声明文件中的<em>open</em>子句。</li><li><em><strong>add-modules</strong></em> <em>–</em> Adds the list of modules into the default set of modules. 将模块列表添加到默认模块集中</li><li><em><strong>list-modules</strong></em> <em>–</em> Prints a list of all modules and their version strings. 打印所有模块及其版本字符串的列表。</li><li><em><strong>patch-module</strong></em> – Add or override classes in a modules. 在模块中添加或覆盖类。</li><li><em><strong>illegal-access=permit|warn|deny</strong></em> – Either relax strong encapsulation by showing a single global warning, shows every warning, or fails with errors. The default is <em>permit</em>. 通过显示单个全局警告，可以放松强封装，显示每次警告，或者因错误而失败。 默认为<em>允许</em>。</li></ul><h2 id="6-Visibility"><a href="#6-Visibility" class="headerlink" title="6. Visibility"></a><strong>6. Visibility</strong></h2><p>We should spend a little time talking about the visibility of our code.</p><p>我们应该花一点时间讨论下代码的可见性。</p><p><strong>A lot of libraries depend on reflection to work their magic</strong> (JUnit and Spring come to mind).</p><p><strong>许多库依赖于反射操作来实现他们的神奇功能</strong>（JUnit和Spring就是如此）。</p><p>By default in Java 9, we will <em>only</em> have access to public classes, methods, and fields in our exported packages. Even if we use reflection to get access to non-public members and call <em>setAccessible(true),</em> we won&#39;t be able to access these members.</p><p>在Java 9中，默认情况下我们将<em>仅</em>访问我们暴露的包中的公共类，方法和字段。 即使我们使用反射来访问非公共成员并将其设置为可访问的，我们也无法访问这些成员。</p><p>We can use the <em>open</em>, <em>opens</em>, and <em>opens…to</em> options to grant runtime-only access for reflection. Note, <strong>this is runtime-only!</strong></p><p>我们可以使用<em>open</em>，<em>opens</em>，<em>open...to</em>选项授予反射以运行时的访问权限。 注意，<strong>这是运行时！</strong></p><p>We won&#39;t be able to compile against private types, and we should never need to anyway.</p><p>我们将无法针对私有类型进行编译，无论如何都不应该这样做。</p><p>If we must have access to a module for reflection, and we&#39;re not the owner of that module (i.e., we can&#39;t use the <em>opens…to</em> directive), then it&#39;s possible to use the command line <em>–add-opens</em> option to allow own modules reflection access to the locked down module at runtime.</p><p>如果我们必须通过反射来访问一个模块，并且我们不是那个模块的所有者(即，我们不能使用 <em>opened…to</em> 指令)，那么可以使用命令行 <em>--add-opened</em> 选项来允许自己的模块在运行时反射访问锁定的模块。</p><p>The only caveat here&#39;s that you need to have access to the command line arguments that are used to run a module for this to work.</p><p>这里唯一的警告是您需要访问用于运行模块的命令行参数以便工作。</p><h2 id="7-Putting-It-All-Together"><a href="#7-Putting-It-All-Together" class="headerlink" title="7. Putting It All Together"></a><strong>7. Putting It All Together</strong></h2><p>Now that we know what a module is and how to use them let&#39;s go ahead and build a simple project to demonstrate all the concepts we just learned.</p><p>既然我们知道模块是什么以及如何使用它们，接下来建立一个简单的项目来演示我们刚才学习的所有概念吧。</p><p>To keep things simple, we won&#39;t be using Maven or Gradle. Instead, we&#39;ll rely on the command line tools to build our modules.</p><p>简单起见，我们不会使用Maven或Gradle。 相反，我们将依靠命令行工具来构建我们的模块。</p><h3 id="7-1-Setting-Up-Our-Project"><a href="#7-1-Setting-Up-Our-Project" class="headerlink" title="7.1. Setting Up Our Project"></a><strong>7.1. Setting Up Our Project</strong></h3><p>First, we need to set up our project structure. We&#39;ll create several directories to organize our files.</p><p>首先，我们需要设置我们的项目结构。 我们将创建多个目录以组织我们的文件。</p><p>Start by creating the project folder:</p><p>首先创建项目文件夹：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir module-project</span><br><span class="line"><span class="built_in">cd</span> module-project</span><br></pre></td></tr></table></figure><p>This is the base of our whole project, so add files in here such as Maven or Gradle build files, other source directories, and resources.</p><p>这是我们整个项目的基础，因此在此添加文件，如Maven或Gradle构建文件，其他源目录和资源。</p><p>We also put a directory to hold all our project specific modules.</p><p>我们还将创建一个目录用来包含所有模块。</p><p>Next, we create a module directory:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir simple-modules</span><br></pre></td></tr></table></figure><p>Here&#39;s what our project structure will look like:</p><p>项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module-project</span><br><span class="line">|- // src if we use the default package</span><br><span class="line">|- // build files also go at this level</span><br><span class="line">|- simple-modules</span><br><span class="line">  |- hello.modules</span><br><span class="line">    |- com</span><br><span class="line">      |- baeldung</span><br><span class="line">        |- modules</span><br><span class="line">          |- hello</span><br><span class="line">  |- main.app</span><br><span class="line">    |- com</span><br><span class="line">      |- baeldung</span><br><span class="line">        |- modules</span><br><span class="line">          |- main</span><br></pre></td></tr></table></figure><h3 id="7-2-Our-First-Module"><a href="#7-2-Our-First-Module" class="headerlink" title="7.2. Our First Module"></a><strong>7.2. Our First Module</strong></h3><p>Now that we have the basic structure in place, let&#39;s add our first module.</p><p>现在我们已经有了一个基础结构，开始添加第一个模块吧。</p><p>Under the <em>simple-modules</em> directory, create a new directory called <em>hello.modules</em>.</p><p>在<em>simple-modules</em>目录下，创建一个叫做<em>hello.modules</em>的文件夹。</p><p><strong>We can name this anything we want but follow package naming rules</strong> (i.e., periods to separate words, etc.). We can even use the name of our main package as the module name if we want, but usually, we want to stick to the same name we would use to create a JAR of this module.</p><p><strong>我们可以随意命名，但请遵循包命名规则</strong>（如，分隔单词的点 . ）。 如果我们想要，我们甚至可以使用主要包的名称作为模块名称，但通常，我们希望使用与jar文件同名的方式来命名模块。</p><p>Under our new module, we can create the packages we want. In our case, we are going to create one package structure:</p><p>在新模块中，可以创建我们想要的包。在我们的例子中，包结构如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.baeldung.modules.hello</span><br></pre></td></tr></table></figure><p>Next, create a new class called <em>HelloModules.java</em> in this package. We will keep the code simple:</p><p>接下来，在包中新建一个名为<em>HelloModules.java</em>的类，尽可能让代码简单一点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baeldung.modules.hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloModules</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, Modules!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And finally, in the <em>hello.modules</em> root directory, add in our module descriptor; <em>module-info.java</em>:</p><p>最后，在<em>hello.modules</em>的的根路径下，添加<em>module-info.java</em>文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.modules &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.baeldung.modules.hello;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To keep this example simple, all we are doing is exporting all public members of the <em>com.baeldung.modules.hello</em> package.</p><p>为了保持示例简单，我们导出了 <em>com.baeldung.modules.hello</em> 包中的所有公共成员。</p><h3 id="7-3-Our-Second-Module"><a href="#7-3-Our-Second-Module" class="headerlink" title="7.3. Our Second Module"></a><strong>7.3. Our Second Module</strong></h3><p>Our first module is great, but it doesn&#39;t do anything.</p><p>第一个模块貌似啥都不能干。</p><p>We can create a second module that uses it now.</p><p>现在来创建第二个模块，并使用第一个模块。</p><p>Under our <em>simple-modules</em> directory, create another module directory called <em>main.app</em>. We are going to start with the module descriptor this time:</p><p>在我们的<em>简单模块</em>目录下，创建一个名为 <em>main.app</em> 的另一个模块目录。 我们将同时使用模块描述符：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> main.app &#123;</span><br><span class="line">    <span class="keyword">requires</span> hello.modules;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We don&#39;t need to expose anything to the outside world. Instead, all we need to do is depend on our first module, so we have access to the public classes it exports.</p><p>我们不需要向外界露出任何东西。 相反，我们需要做的就是依赖于我们的第一个模块，因此我们可以访问它暴露的公开类。</p><p>Now we can create an application that uses it.</p><p>现在创建一个应用来使用它。</p><p>Create a new package structure: <em>com.baeldung.modules.main</em>.</p><p>新建一个包：<em>com.baeldung.modules.main</em>。</p><p>Now, create a new class file called <em>MainApp.java.</em></p><p>然后新建一个<em>MainApp.java</em>类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baeldung.modules.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baeldung.modules.hello.HelloModules;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloModules.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And that is all the code we need to demonstrate modules. Our next step is to build and run this code from the command line.</p><p>这就是我们需要演示模块所需的所有代码。 下一步是从命令行构建和运行此代码。</p><h3 id="7-4-Building-Our-Modules"><a href="#7-4-Building-Our-Modules" class="headerlink" title="7.4. Building Our Modules"></a><strong>7.4. Building Our Modules</strong></h3><p>To build our project, we can create a simple bash script and place it at the root of our project.</p><p>要构建我们的项目，可以创建一个简单的Bash脚本并将其放在我们项目的根目录中。</p><p>Create a file called <em>compile-simple-modules.sh</em>:</p><p>新建一个<em>compile-simple-modules.sh</em>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">javac -d outDir --module-source-path simple-modules $(find simple-modules -name <span class="string">&quot;*.java&quot;</span>)</span><br></pre></td></tr></table></figure><p>There are two parts to this command, the <em>javac</em> and <em>find</em> commands.</p><p>此命令有两个部分，<em>javac</em> 和 <em>find</em> 命令。</p><p>The <em>find</em> command is simply outputting a list of all .<em>java</em> files under our simple-modules directory. We can then feed that list directly into the Java compiler.</p><p><em>find</em>命令仅简单的输出<em>simple-modules</em>目录下的所有*.java*文件，然后将这些文件直接输出给Java编译器。</p><p>The only thing we have to do differently than the older versions of Java is to provide a <em>module-source-path</em> parameter to inform the compiler that it&#39;s building modules.</p><p>我们唯一要做的不同之处在于旧版本的Java是提供一个 <em>modul-source-path</em> 参数来通知编译器是构建模块。</p><p>Once we run this command, we will have an <em>outDir</em> folder with two compiled modules inside.</p><p>运行此命令后，我们将拥有一个 <em>outDir</em> 文件夹，其中包含两个编译模块。</p><h3 id="7-5-Running-Our-Code"><a href="#7-5-Running-Our-Code" class="headerlink" title="7.5. Running Our Code"></a><strong>7.5. Running Our Code</strong></h3><p>And now we can finally run our code to verify modules are working correctly.</p><p>现在我们终于可以运行我们的代码来验证模块正常工作。</p><p>Create another file in the root of the project: <em>run-simple-module-app.sh</em>.</p><p>新建另一个文件放在项目的根路径下：<em>run-simple-module-app.sh</em>.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">java --module-path outDir -m main.app/com.baeldung.modules.main.MainApp</span><br></pre></td></tr></table></figure><p>To run a module, we must provide at least the <em>module-path</em> and the main class. If all works, you should see:</p><p>要运行模块，我们必须至少提供 <em>module-path</em> 和主类。 如果都正常执行了，你应该看到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;$ ./run-simple-module-app.sh </span><br><span class="line">Hello, Modules!</span><br></pre></td></tr></table></figure><h3 id="7-6-Adding-a-Service"><a href="#7-6-Adding-a-Service" class="headerlink" title="7.6. Adding a Service"></a><strong>7.6. Adding a Service</strong></h3><p>Now that we have a basic understanding of how to build a module, let&#39;s make it a little more complicated.</p><p>现在我们对如何构建模块有了基本了解，开始加点难度。</p><p>We&#39;re going to see how to use the <em>provides…with</em> and <em>uses</em> directives.</p><p>我们来了解下如何使用 <em>provides…with</em> 和 <em>uses</em> 指令。</p><p>Start by defining a new file in the <em>hello.modules</em> module named <em>HelloInterface.java</em>:</p><p>首先在 <em>hello.modules</em> 模块中新建一个 <em>HelloInterface.java</em>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To make things easy, we&#39;re going to implement this interface with our existing <em>HelloModules.java</em> class:</p><p>在 <em>HelloModules.java</em> 类上实现此接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloModules</span> <span class="keyword">implements</span> <span class="title">HelloInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, Modules!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>That is all we need to do to create a <em>service</em>.</p><p>这就是我们构建好的服务。</p><p>Now, we need to tell the world that our module provides this service.</p><p>现在我们需要对外公开我们的模块可以提供这个服务。</p><p>Add the following to our <em>module-info.java</em>:</p><p>添加如下内容到 <em>module-info.java</em>中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">provides com.baeldung.modules.hello.HelloInterface with com.baeldung.modules.hello.HelloModules;</span><br></pre></td></tr></table></figure><p>As we can see, we declare the interface and which class implements it.</p><p>正如我们所看到的，我们声明了该接口以及哪个类实现了它。</p><p>Next, we need to consume this <em>service</em>. In our <em>main.app</em> module, let&#39;s add the following to our <em>module-info.java</em>:</p><p>接下来，我们消费一下<em>service</em>。在我们的 <em>main.app</em> 模块中，让我们将以下内容添加到我们的 <em>module-info.java</em>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">uses com.baeldung.modules.hello.HelloInterface;</span><br></pre></td></tr></table></figure><p>Finally, in our main method we can use this service via a <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/ServiceLoader.html">ServiceLoader</a>:</p><p>最后，在我们的主要方法中，我们可以通过<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/serviceloader.html">ServiceLoader</a>使用此服务：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterable&lt;HelloInterface&gt; services = ServiceLoader.load(HelloInterface.class);</span><br><span class="line">HelloInterface service = services.iterator().next();</span><br><span class="line">service.sayHello();</span><br></pre></td></tr></table></figure><p>Compile and run:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&gt; ./run-simple-module-app.sh </span></span><br><span class="line">Hello, Modules!</span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure><p>We use these directives to be much more explicit about how our code is to be used.</p><p>我们使用这些指令更明确地了解如何处理我们的代码。</p><p>We could put the implementation into a private package while exposing the interface in a public package.</p><p>我们可以将实现放入私有软件包，同时在公共包装中公开接口。</p><p>This makes our code much more secure with very little extra overhead.</p><p>这将使我们的代码更加安全，并且减小额外的开销。</p><p>Go ahead and try out some of the other directives to learn more about modules and how they work.</p><p>让我们继续尝试一些其他指令，以了解更多有关模块以及它们的工作方式。</p><h2 id="8-Adding-Modules-to-the-Unnamed-Module"><a href="#8-Adding-Modules-to-the-Unnamed-Module" class="headerlink" title="8. Adding Modules to the Unnamed Module"></a>8. Adding Modules to the Unnamed Module</h2><p><strong>The unnamed module concept is similar to the default package.</strong> Therefore, it&#39;s not considered a real module, but can be viewed as the default module.</p><p><strong>未命名的模块概念类似于默认包。</strong>因此，它不被视为一个真实的模块，但可以被视为默认模块。</p><p>If a class is not a member of a named module, then it will be automatically considered as part of this unnamed module.</p><p>如果类不是命名模块的成员，那么它将被自动被视为未命名模块的一部分。</p><p>Sometimes, to ensure specific platform, library, or service-provider modules in the module graph, we need to add modules to the default root set. For example, when we try to run Java 8 programs as-is with Java 9 compiler we may need to add modules.</p><p>有时，为了确保模块图中的特殊平台，库或服务提供者模块，我们需要将模块添加到默认根路径中。 例如，当我们尝试使用Java 9编译器运行Java 8程序时，我们可能需要添加模块。</p><p>In general, <strong>the option to add the named modules to the default set of root modules is</strong> <em><strong>–add-modules<module></module></strong></em> (,<module>) where<em><module></module></em> is a module name.</module></p><p>通常，**将命名模块添加到默认的根模块集的选项为 *-add-modules<module> (,<module>)***，其中<em><module></module></em> 是模块名称。</module></module></p><p>For example, to provide access to all <em>java.xml.bind</em> modules the syntax would be:</p><p>例如，要提供对所有 <em>java.xml.bind</em> 模块的访问语法将是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--add-modules java.xml.bind</span><br></pre></td></tr></table></figure><p>To use this in Maven, we can embed the same to the <em>maven-compiler-plugin</em>:</p><p>要在Maven中使用此功能，我们可以将其嵌入<em>maven-compiler-plugin</em>：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>9<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>9<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">compilerArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span>&gt;</span>--add-modules<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span>&gt;</span>java.xml.bind<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">compilerArgs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="9-Conclusion"><a href="#9-Conclusion" class="headerlink" title="9. Conclusion"></a><strong>9. Conclusion</strong></h2><p>In this extensive guide, we focused on and covered the basics of the new Java 9 Module system.</p><p>在这个广泛的指南中，我们专注于并涵盖了新的Java 9模块系统的基础知识。</p><p>We started by talking about what a module is.</p><p>我们首先谈论模块是什么。</p><p>Next, we talked about how to discover which modules are included in the JDK.</p><p>接下来，我们讨论了如何发现JDK中包含哪些模块。</p><p>We also covered the module declaration file in detail.</p><p>我们还详细介绍了模块声明文件。</p><p>We rounded out the theory by talking about the various command line arguments we&#39;ll need to build our modules.</p><p>我们通过谈论我们需要构建模块的各种命令行参数来彻底彻底理解。</p><p>Finally, we put all our previous knowledge into practice and created a simple application built on top of the module system.</p><p>最后，我们将所有之前的知识用于实践中，并创建了一个基于模块系统的简单应用程序。</p><p>To see this code and more, be sure to <a target="_blank" rel="noopener" href="https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-9-jigsaw">check it out over on Github</a>.</p></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2021/10/16/Introduction-to-Project-Jigsaw/" rel="bookmark">Introduction to Project Jigsaw</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2021/10/29/2021-10-30-Life-Cycle-of-a-Thread-in-Java/" rel="bookmark">Life Cycle of a Thread in Java</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2021/11/05/2021-11-06-List-All-Classes-Loaded-in-a-Specific-Class-Loader/" rel="bookmark">List All Classes Loaded in a Specific Class Loader</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2021/10/13/Collectors.toMap不允许Null Value导致NPE/" rel="bookmark">Collectors.toMap不允许Null Value导致NPE</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2021/10/13/JDK9+之后使用JXAB/" rel="bookmark">JDK9+之后使用JXAB</a></div></li></ul><footer class="post-footer"><div class="post-tags"> <a href="/tags/Java/" rel="tag"># Java</a> <a href="/tags/JDK9/" rel="tag"># JDK9</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag"># 翻译</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag"># 转载</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/10/16/Introduction-to-Project-Jigsaw/" rel="prev" title="Introduction to Project Jigsaw"><i class="fa fa-chevron-left"></i> Introduction to Project Jigsaw</a></div><div class="post-nav-item"> <a href="/2021/10/20/New-Stream-Collectors-in-Java-9/" rel="next" title="New Stream Collectors in Java 9">New Stream Collectors in Java 9<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">湘ICP备19011756号-1</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">JIAHE</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.6/pdfobject.min.js","integrity":"sha256-77geM50MfxCD17eqyJR+Dag1svjJOLN+BJ2F/DMqMEY="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"ignores":null,"url":"http://xiaojianzheng.cn/2021/10/18/A-Guide-to-Java-9-Modularity/"}</script><script src="/js/third-party/quicklink.js"></script></body></html>